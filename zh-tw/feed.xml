<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://algorithm.yuanbin.me/zh-tw/</id>
    <title>Data Structure and Algorithm notes</title>
    <updated>2019-11-03T15:42:21Z</updated>
    <author>
        <uri>function link() { [native code] }</uri>
    </author>
    <link rel="alternate" href="https://algorithm.yuanbin.me/zh-tw/"/>
    <subtitle>Data Structure and Algorithm notes/数据结构与算法学习笔记/leetcode/lintcode 题解</subtitle>
    <generator>Feed for Node.js</generator>
    <category term="programming">
    </category>
    <category term="algorithm">
    </category>
    <category term="leetcode">
    </category>
    <entry>
        <title type="html"><![CDATA[Preface]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/">
        </link>
        <updated>2019-11-03T15:41:56Z</updated>
        <summary type="html"><![CDATA[<h1>資料結構與演算法/leetcode/lintcode題解</h1>
<!-- toc -->
<ul>
<li><a href="#簡介">簡介</a></li>
<li><a href="#授權條款">授權條款</a></li>
<li><a href="#多國文字">多國文字</a></li>
<li><a href="#如何貢獻">如何貢獻</a></li>
<li><a href="#如何練習演算法">如何練習演算法</a></li>
<li><a href="#線上oj及部分題解">線上OJ及部分題解</a></li>
<li><a href="#其他資源">其他資源</a></li>
<li><a href="#書籍推薦">書籍推薦</a></li>
<li><a href="#學習資源推薦繁體中文譯者">學習資源推薦(繁體中文譯者)</a></li>
</ul>
<!-- tocstop -->
<p><a href="https://travis-ci.org/billryan/algorithm-exercise"><img src="https://travis-ci.org/billryan/algorithm-exercise.svg?branch=master" alt="Build Status"></a>
<a href="https://slackin4ds-algo.herokuapp.com/"><img src="https://slackin4ds-algo.herokuapp.com/badge.svg" alt="Slack Status"></a>
<a href="https://ds-algo.slack.com/"><img src="https://img.shields.io/badge/chat-on_slack-orange.svg" alt="Chat on Slack"></a></p>
<ul>
<li>English via <a href="http://algorithm.yuanbin.me/en/index.html">Data Structure and Algorithm notes</a></li>
<li>简体中文请戳 <a href="http://algorithm.yuanbin.me/zh-hans/index.html">数据结构与算法/leetcode/lintcode题解</a></li>
<li>繁體中文請瀏覽 <a href="http://algorithm.yuanbin.me/zh-tw/index.html">資料結構與演算法/leetcode/lintcode題解</a></li>
</ul>
<h2>簡介</h2>
<p>本文檔為資料結構和演算法學習筆記，全文大致分為以下三大部分：</p>
<ol>
<li>Part I為資料結構和演算法基礎，介紹一些基礎的排序/鏈表/基礎演算法</li>
<li>Part II為 OJ 上的程式設計題目實戰，按題目的內容分章節編寫，主要來源為 <a href="https://leetcode.com/">https://leetcode.com/</a> 和 <a href="http://www.lintcode.com/">http://www.lintcode.com/</a>.</li>
<li>Part III 為附錄部分，包含如何寫履歷和其他附加資料</li>
</ol>
<p>本文參考了很多教材和部落格，凡參考過的幾乎都給出明確超連結，如果不小心忘記了，請不要吝惜你的評論和issue :)</p>
<p>本項目保管在 <a href="https://github.com/billryan/algorithm-exercise">https://github.com/billryan/algorithm-exercise</a> 由 <a href="https://www.gitbook.com/book/yuanbin/algorithm/details">Gitbook</a> 渲染生成 HTML 頁面。你可以在 GitHub(不是 Gitbook) 中 star 該項目查看更新，也可以訂閱 <a href="https://ds-algo.slack.com/messages/github_commit/">https://ds-algo.slack.com/messages/github_commit/</a> 中的 <code>#github_commit</code> channel 在郵件中查看更新細節。<del>RSS 種子功能正在開發中。</del></p>
<p>Slack 的自助邀請註冊功能已啟用，訪問 <a href="http://slackin4ds-algo.herokuapp.com">http://slackin4ds-algo.herokuapp.com</a> 即刻開啟~</p>
<p>你可以線上或者離線查看/搜索本文檔，以下方式任君選擇~</p>
<ul>
<li>線上閱讀(由 Gitbook 渲染) <a href="http://algorithm.yuanbin.me">http://algorithm.yuanbin.me</a></li>
<li><p>離線閱讀: 推送到GitHub後會觸發 travis-ci 的編譯，相應的部分編譯輸出提供七牛的靜態文件加速下載。</p>
<ol>
<li>EPUB. <a href="https://raw.githubusercontent.com/billryan/algorithm-exercise/deploy/epub/algorithm-ebook_zh-tw.epub">GitHub</a>, <a href="https://www.gitbook.com/download/epub/book/yuanbin/algorithm?lang=zh-tw">Gitbook</a>, <a href="http://7xojrx.com1.z0.glb.clouddn.com/docs/algorithm-exercise/algorithm-ebook_zh-tw.epub">七牛 CDN(中国大陆用户适用)</a> - 適合在 iPhone/iPad/MAC 上離線查看，實測效果極好。</li>
<li>PDF. <a href="https://raw.githubusercontent.com/billryan/algorithm-exercise/deploy/pdf/algorithm-ebook_zh-tw.pdf">GitHub</a>, <a href="https://www.gitbook.com/download/pdf/book/yuanbin/algorithm?lang=zh-tw">Gitbook</a>, <a href="http://7xojrx.com1.z0.glb.clouddn.com/docs/algorithm-exercise/algorithm-ebook_zh-tw.pdf">七牛 CDN(中国大陆用户适用)</a> - 推薦下載適合電子屏閱讀的版本，Gitbook 官方使用的中文字體有點問題。</li>
<li>MOBI. <a href="https://raw.githubusercontent.com/billryan/algorithm-exercise/deploy/mobi/algorithm-ebook_zh-tw.mobi">GitHub</a>, <a href="https://www.gitbook.com/download/mobi/book/yuanbin/algorithm?lang=zh-tw">Gitbook</a>, <a href="http://7xojrx.com1.z0.glb.clouddn.com/docs/algorithm-exercise/algorithm-ebook_zh-tw.mobi">七牛 CDN(中国大陆用户适用)</a> - Kindle 專用. 未測試，感覺不適合在 Kindle 上看此類書籍，儘管 Kindle 的屏幕對眼睛很好...</li>
</ol>
</li>
<li><p>Google 站內搜索: <code>keywords site:algorithm.yuanbin.me</code></p>
</li>
<li>Swiftype 站內搜索: 可使用網頁右下方的 <code>Search this site</code> 進行站內搜索</li>
</ul>
<h2>授權條款</h2>
<p>本作品採用 <strong>創用CC 姓名標示-相同方式分享 4.0 國際許可協議</strong>  進行許可。<strong>傳播此文檔時請注意遵循以上許可協議。</strong> 關於本授權的更多詳情可參考 <a href="http://creativecommons.org/licenses/by-sa/4.0/">http://creativecommons.org/licenses/by-sa/4.0/</a></p>
<p>本著獨樂樂不如眾樂樂的開源精神，我將自己的演算法學習筆記公開和小夥伴們討論，希望高手們不吝賜教。</p>
<h2>多國文字</h2>
<ul>
<li><a href="http://algorithm.yuanbin.me/en/index.html">English</a> maintained by <a href="https://github.com/billryan">@billryan</a></li>
<li><a href="http://algorithm.yuanbin.me/zh-hans/index.html">简体中文</a> maintained by <a href="https://github.com/billryan">@billryan</a></li>
<li><a href="http://algorithm.yuanbin.me/zh-tw/index.html">繁體中文</a> maintained by <a href="https://github.com/CrossLuna">@CrossLuna</a></li>
</ul>
<h2>如何貢獻</h2>
<p>如果你發現任何有錯誤的地方或是想更新/翻譯本文檔，請毫不猶豫地猛點擊 <a href="http://algorithm.yuanbin.me/zh-tw/faq/guidelines_for_contributing.md">貢獻指南</a>.</p>
<h2>如何練習演算法</h2>
<p>雖說練習演算法偏向於演算法本身，但是好的程式碼風格還是很有必要的。粗略可分為以下幾點：</p>
<ul>
<li>程式碼可為三大塊：異常處理（空串和邊界處理），主體，返回</li>
<li>程式碼風格(<strong>可參考Google的程式設計語言規範</strong>)<ol>
<li>變量名的命名(有意義的變數名)</li>
<li>縮排(語句塊)</li>
<li>空格(運算子兩邊)</li>
<li>程式碼可讀性(即使if語句只有一句也要加花括號)</li>
</ol>
</li>
<li>《Code Complete》中給出的參考</li>
</ul>
<p>而對於實戰演算法的過程中，我們可以採取如下策略：</p>
<ol>
<li>總結歸類相似題目</li>
<li>找出適合同一類題目的模板程序</li>
<li>對基礎題熟練掌握</li>
</ol>
<p>以下整理了一些最近練習演算法的網站資源，和大家共享之。</p>
<h2>線上OJ及部分題解</h2>
<ul>
<li><a href="https://leetcode.com/">LeetCode Online Judge</a> - 找工作方面非常出名的一個OJ，每道題都有 discuss 頁面，可以看別人分享的程式碼和討論，很有參考價值，相應的題解非常多。不過線上程式碼編輯框不太好用，寫著寫著框就拉下來了，最近評測速度比 lintcode 快很多，而且做完後可以看自己程式碼的運行時間分布，首推此 OJ 刷面試相關的題。</li>
<li><a href="http://www.lintcode.com">LintCode | Coding interview questions online training system</a> - 和leetcode類似的在線OJ，但是篩選和寫程式碼時比較方便，左邊為題目，右邊為程式碼框。還可以在<code>source</code>處選擇 CC150 或者其他來源的題。會根據系統locale選擇中文或者英文，可以拿此 OJ 輔助 leetcode 進行練習。</li>
<li><a href="https://www.gitbook.com/book/siddontang/leetcode-solution/details">LeetCode題解 - GitBook</a> - 題解部分十分詳細，比較容易理解，但部分題目不全。</li>
<li><a href="https://github.com/FreeTymeKiyan/LeetCode-Sol-Res">FreeTymeKiyan/LeetCode-Sol-Res</a> - Clean, Understandable Solutions and Resources on LeetCode Online Judge Algorithms Problems.</li>
<li><a href="https://github.com/soulmachine/leetcode">soulmachine/leetcode</a> - 含C++和Java兩個版本的題解。</li>
<li><a href="http://okckd.github.io/">Woodstock Blog</a> - IT，演算法及面試。有知識點及類型題總結，特別贊。</li>
<li><a href="http://www.itint5.com/">ITint5 | 專注於IT面試</a> - 文章品質很高，也有部分公司面試題評測。</li>
<li><a href="http://www.acmerblog.com/">Acm之家,專業的ACM學習網站</a> - 各類題解</li>
<li><a href="http://www.nowcoder.com/">牛客網-專業IT筆試面試備考平台,最全求職題庫,全面提升IT程式設計能力</a> - 中國一個IT求職方面的綜合性網站，比較適合想在中國求職的看看。感謝某位美女的推薦 :)</li>
</ul>
<h2>其他資源</h2>
<ul>
<li><a href="http://www.jiuzhang.com/">九章算法</a> - 程式碼品質不錯，整理得也很好。</li>
<li><a href="http://julyedu.com/">七月算法 - julyedu.com </a> - july大神主導的在線演算法輔導。</li>
<li><a href="http://www.1point3acres.com/bbs/forum-84-1.html">刷題 | 一畝三分地論壇 </a> - 時不時就會有驚喜放出。</li>
<li><a href="http://http://visualgo.net/">VisuAlgo - visualising data structures and algorithms through animation</a> - 相當猛的資料結構和演算法可視化。</li>
<li><a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualization</a> - 同上，非常好的動畫示例！！涵蓋了常用的各種資料結構/排序/演算法。</li>
<li><a href="http://blog.csdn.net/v_JULY_v">結構之法 算法之道</a> - 不得不服！</li>
<li><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July">julycoding/The-Art-Of-Programming-By-July</a> - 程序員面試藝術的電子版</li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/6543438">程序員面試、算法研究、程式設計藝術、紅黑樹、數據挖掘5大系列集錦</a></li>
<li><a href="http://blog.csdn.net/column/details/lf-algoritnote.html">專欄：算法筆記——《算法設計與分析》</a> - CSDN上對《算法設計與分析》一書的學習筆記。</li>
<li><a href="http://zh.lucida.me/blog/on-learning-algorithms/">我的算法學習之路 - Lucida</a> - Google 工程師的演算法學習經驗分享。</li>
</ul>
<h2>書籍推薦</h2>
<p>本節後三項參考自九章微信分享，謝過。</p>
<ul>
<li><a href="http://book.douban.com/subject/1475870/">Algorithm Design (豆瓣)</a></li>
<li><a href="http://www.amazon.com/exec/obidos/ASIN/1848000693/thealgorithmrepo">The Algorithm Design Manual</a>, 作者還放出了自己上課的影片和slides - <a href="http://www3.cs.stonybrook.edu/~algorith/video-lectures/">Skiena&#39;s Audio Lectures</a>，<a href="http://book.douban.com/subject/3072383/">The Algorithm Design Manual (豆瓣)</a></li>
<li>大部頭有 <em>Introduction to Algorithm</em> 和 TAOCP</li>
<li><em>Cracking The Coding Interview</em>. 著名的CTCI(又稱CC150)，Google, Mircosoft, LinkedIn 前HR離職之後寫的書，從很全面的角度剖析了面試的各個環節和題目。除了演算法資料結構等題以外，還包含OO Design, Database, System Design, Brain Teaser等類型的題目。準備北美面試的同學一定要看。</li>
<li><em>劍指Offer</em>。適合中國找工作的同學看看，英文版叫Coding Interviews. 作者是何海濤(Harry He)。Amazon.cn上可以買到。有大概50多題，題目的分析比較全面，會從面試官的角度給出很多的建議和show各種坑。</li>
<li><em>進軍矽谷</em> -- 程序員面試揭秘。有差不多150題。</li>
</ul>
<h2>學習資源推薦(繁體中文譯者)</h2>
<h3>入門</h3>
<ul>
<li><p><a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-EHEP001657.html">Data Structures and Algorithms in C++</a>
-by Michael T. Goodrich, Roberto Tamassia and David M. Mount</p>
<p>  台大資工系的<strong>資料結構與演算法</strong>上課用書，內容好懂易讀，習題量大且深度廣度兼具，程式碼風格俐落而不失功能完整性，對C++背景的同學來說是良好的資料結構入門書。</p>
</li>
<li><p><a href="https://www.edx.org/course/data-structures-shu-ju-jie-gou-tsinghuax-30240184x-2">Data Structures • 數據結構</a>(MOOC)</p>
<p>  北京清華大學的鄧俊輝老師開設的中文MOOC，以C++為主要的程式語言，對於一上來就看書覺得枯燥的同學是一帖入門良藥，講解深入淺出，投影片視覺化做得極好，程式作業禁用了部分STL如vector、list、set等，要求學生必須自己實現需要用的資料結構，程式作業使用清華自建的OJ平台，可以同時跟其他線上學習的同學競爭，作業表現優良的同學還可以加入清華內部的討論群組與清華的學生切磋，相當受用。</p>
</li>
</ul>
<h3>進階</h3>
]]></summary>
        <content type="html"><![CDATA[<h1>資料結構與演算法/leetcode/lintcode題解</h1>
<!-- toc -->
<ul>
<li><a href="#簡介">簡介</a></li>
<li><a href="#授權條款">授權條款</a></li>
<li><a href="#多國文字">多國文字</a></li>
<li><a href="#如何貢獻">如何貢獻</a></li>
<li><a href="#如何練習演算法">如何練習演算法</a></li>
<li><a href="#線上oj及部分題解">線上OJ及部分題解</a></li>
<li><a href="#其他資源">其他資源</a></li>
<li><a href="#書籍推薦">書籍推薦</a></li>
<li><a href="#學習資源推薦繁體中文譯者">學習資源推薦(繁體中文譯者)</a></li>
</ul>
<!-- tocstop -->
<p><a href="https://travis-ci.org/billryan/algorithm-exercise"><img src="https://travis-ci.org/billryan/algorithm-exercise.svg?branch=master" alt="Build Status"></a>
<a href="https://slackin4ds-algo.herokuapp.com/"><img src="https://slackin4ds-algo.herokuapp.com/badge.svg" alt="Slack Status"></a>
<a href="https://ds-algo.slack.com/"><img src="https://img.shields.io/badge/chat-on_slack-orange.svg" alt="Chat on Slack"></a></p>
<ul>
<li>English via <a href="http://algorithm.yuanbin.me/en/index.html">Data Structure and Algorithm notes</a></li>
<li>简体中文请戳 <a href="http://algorithm.yuanbin.me/zh-hans/index.html">数据结构与算法/leetcode/lintcode题解</a></li>
<li>繁體中文請瀏覽 <a href="http://algorithm.yuanbin.me/zh-tw/index.html">資料結構與演算法/leetcode/lintcode題解</a></li>
</ul>
<h2>簡介</h2>
<p>本文檔為資料結構和演算法學習筆記，全文大致分為以下三大部分：</p>
<ol>
<li>Part I為資料結構和演算法基礎，介紹一些基礎的排序/鏈表/基礎演算法</li>
<li>Part II為 OJ 上的程式設計題目實戰，按題目的內容分章節編寫，主要來源為 <a href="https://leetcode.com/">https://leetcode.com/</a> 和 <a href="http://www.lintcode.com/">http://www.lintcode.com/</a>.</li>
<li>Part III 為附錄部分，包含如何寫履歷和其他附加資料</li>
</ol>
<p>本文參考了很多教材和部落格，凡參考過的幾乎都給出明確超連結，如果不小心忘記了，請不要吝惜你的評論和issue :)</p>
<p>本項目保管在 <a href="https://github.com/billryan/algorithm-exercise">https://github.com/billryan/algorithm-exercise</a> 由 <a href="https://www.gitbook.com/book/yuanbin/algorithm/details">Gitbook</a> 渲染生成 HTML 頁面。你可以在 GitHub(不是 Gitbook) 中 star 該項目查看更新，也可以訂閱 <a href="https://ds-algo.slack.com/messages/github_commit/">https://ds-algo.slack.com/messages/github_commit/</a> 中的 <code>#github_commit</code> channel 在郵件中查看更新細節。<del>RSS 種子功能正在開發中。</del></p>
<p>Slack 的自助邀請註冊功能已啟用，訪問 <a href="http://slackin4ds-algo.herokuapp.com">http://slackin4ds-algo.herokuapp.com</a> 即刻開啟~</p>
<p>你可以線上或者離線查看/搜索本文檔，以下方式任君選擇~</p>
<ul>
<li>線上閱讀(由 Gitbook 渲染) <a href="http://algorithm.yuanbin.me">http://algorithm.yuanbin.me</a></li>
<li><p>離線閱讀: 推送到GitHub後會觸發 travis-ci 的編譯，相應的部分編譯輸出提供七牛的靜態文件加速下載。</p>
<ol>
<li>EPUB. <a href="https://raw.githubusercontent.com/billryan/algorithm-exercise/deploy/epub/algorithm-ebook_zh-tw.epub">GitHub</a>, <a href="https://www.gitbook.com/download/epub/book/yuanbin/algorithm?lang=zh-tw">Gitbook</a>, <a href="http://7xojrx.com1.z0.glb.clouddn.com/docs/algorithm-exercise/algorithm-ebook_zh-tw.epub">七牛 CDN(中国大陆用户适用)</a> - 適合在 iPhone/iPad/MAC 上離線查看，實測效果極好。</li>
<li>PDF. <a href="https://raw.githubusercontent.com/billryan/algorithm-exercise/deploy/pdf/algorithm-ebook_zh-tw.pdf">GitHub</a>, <a href="https://www.gitbook.com/download/pdf/book/yuanbin/algorithm?lang=zh-tw">Gitbook</a>, <a href="http://7xojrx.com1.z0.glb.clouddn.com/docs/algorithm-exercise/algorithm-ebook_zh-tw.pdf">七牛 CDN(中国大陆用户适用)</a> - 推薦下載適合電子屏閱讀的版本，Gitbook 官方使用的中文字體有點問題。</li>
<li>MOBI. <a href="https://raw.githubusercontent.com/billryan/algorithm-exercise/deploy/mobi/algorithm-ebook_zh-tw.mobi">GitHub</a>, <a href="https://www.gitbook.com/download/mobi/book/yuanbin/algorithm?lang=zh-tw">Gitbook</a>, <a href="http://7xojrx.com1.z0.glb.clouddn.com/docs/algorithm-exercise/algorithm-ebook_zh-tw.mobi">七牛 CDN(中国大陆用户适用)</a> - Kindle 專用. 未測試，感覺不適合在 Kindle 上看此類書籍，儘管 Kindle 的屏幕對眼睛很好...</li>
</ol>
</li>
<li><p>Google 站內搜索: <code>keywords site:algorithm.yuanbin.me</code></p>
</li>
<li>Swiftype 站內搜索: 可使用網頁右下方的 <code>Search this site</code> 進行站內搜索</li>
</ul>
<h2>授權條款</h2>
<p>本作品採用 <strong>創用CC 姓名標示-相同方式分享 4.0 國際許可協議</strong>  進行許可。<strong>傳播此文檔時請注意遵循以上許可協議。</strong> 關於本授權的更多詳情可參考 <a href="http://creativecommons.org/licenses/by-sa/4.0/">http://creativecommons.org/licenses/by-sa/4.0/</a></p>
<p>本著獨樂樂不如眾樂樂的開源精神，我將自己的演算法學習筆記公開和小夥伴們討論，希望高手們不吝賜教。</p>
<h2>多國文字</h2>
<ul>
<li><a href="http://algorithm.yuanbin.me/en/index.html">English</a> maintained by <a href="https://github.com/billryan">@billryan</a></li>
<li><a href="http://algorithm.yuanbin.me/zh-hans/index.html">简体中文</a> maintained by <a href="https://github.com/billryan">@billryan</a></li>
<li><a href="http://algorithm.yuanbin.me/zh-tw/index.html">繁體中文</a> maintained by <a href="https://github.com/CrossLuna">@CrossLuna</a></li>
</ul>
<h2>如何貢獻</h2>
<p>如果你發現任何有錯誤的地方或是想更新/翻譯本文檔，請毫不猶豫地猛點擊 <a href="http://algorithm.yuanbin.me/zh-tw/faq/guidelines_for_contributing.md">貢獻指南</a>.</p>
<h2>如何練習演算法</h2>
<p>雖說練習演算法偏向於演算法本身，但是好的程式碼風格還是很有必要的。粗略可分為以下幾點：</p>
<ul>
<li>程式碼可為三大塊：異常處理（空串和邊界處理），主體，返回</li>
<li>程式碼風格(<strong>可參考Google的程式設計語言規範</strong>)<ol>
<li>變量名的命名(有意義的變數名)</li>
<li>縮排(語句塊)</li>
<li>空格(運算子兩邊)</li>
<li>程式碼可讀性(即使if語句只有一句也要加花括號)</li>
</ol>
</li>
<li>《Code Complete》中給出的參考</li>
</ul>
<p>而對於實戰演算法的過程中，我們可以採取如下策略：</p>
<ol>
<li>總結歸類相似題目</li>
<li>找出適合同一類題目的模板程序</li>
<li>對基礎題熟練掌握</li>
</ol>
<p>以下整理了一些最近練習演算法的網站資源，和大家共享之。</p>
<h2>線上OJ及部分題解</h2>
<ul>
<li><a href="https://leetcode.com/">LeetCode Online Judge</a> - 找工作方面非常出名的一個OJ，每道題都有 discuss 頁面，可以看別人分享的程式碼和討論，很有參考價值，相應的題解非常多。不過線上程式碼編輯框不太好用，寫著寫著框就拉下來了，最近評測速度比 lintcode 快很多，而且做完後可以看自己程式碼的運行時間分布，首推此 OJ 刷面試相關的題。</li>
<li><a href="http://www.lintcode.com">LintCode | Coding interview questions online training system</a> - 和leetcode類似的在線OJ，但是篩選和寫程式碼時比較方便，左邊為題目，右邊為程式碼框。還可以在<code>source</code>處選擇 CC150 或者其他來源的題。會根據系統locale選擇中文或者英文，可以拿此 OJ 輔助 leetcode 進行練習。</li>
<li><a href="https://www.gitbook.com/book/siddontang/leetcode-solution/details">LeetCode題解 - GitBook</a> - 題解部分十分詳細，比較容易理解，但部分題目不全。</li>
<li><a href="https://github.com/FreeTymeKiyan/LeetCode-Sol-Res">FreeTymeKiyan/LeetCode-Sol-Res</a> - Clean, Understandable Solutions and Resources on LeetCode Online Judge Algorithms Problems.</li>
<li><a href="https://github.com/soulmachine/leetcode">soulmachine/leetcode</a> - 含C++和Java兩個版本的題解。</li>
<li><a href="http://okckd.github.io/">Woodstock Blog</a> - IT，演算法及面試。有知識點及類型題總結，特別贊。</li>
<li><a href="http://www.itint5.com/">ITint5 | 專注於IT面試</a> - 文章品質很高，也有部分公司面試題評測。</li>
<li><a href="http://www.acmerblog.com/">Acm之家,專業的ACM學習網站</a> - 各類題解</li>
<li><a href="http://www.nowcoder.com/">牛客網-專業IT筆試面試備考平台,最全求職題庫,全面提升IT程式設計能力</a> - 中國一個IT求職方面的綜合性網站，比較適合想在中國求職的看看。感謝某位美女的推薦 :)</li>
</ul>
<h2>其他資源</h2>
<ul>
<li><a href="http://www.jiuzhang.com/">九章算法</a> - 程式碼品質不錯，整理得也很好。</li>
<li><a href="http://julyedu.com/">七月算法 - julyedu.com </a> - july大神主導的在線演算法輔導。</li>
<li><a href="http://www.1point3acres.com/bbs/forum-84-1.html">刷題 | 一畝三分地論壇 </a> - 時不時就會有驚喜放出。</li>
<li><a href="http://http://visualgo.net/">VisuAlgo - visualising data structures and algorithms through animation</a> - 相當猛的資料結構和演算法可視化。</li>
<li><a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualization</a> - 同上，非常好的動畫示例！！涵蓋了常用的各種資料結構/排序/演算法。</li>
<li><a href="http://blog.csdn.net/v_JULY_v">結構之法 算法之道</a> - 不得不服！</li>
<li><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July">julycoding/The-Art-Of-Programming-By-July</a> - 程序員面試藝術的電子版</li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/6543438">程序員面試、算法研究、程式設計藝術、紅黑樹、數據挖掘5大系列集錦</a></li>
<li><a href="http://blog.csdn.net/column/details/lf-algoritnote.html">專欄：算法筆記——《算法設計與分析》</a> - CSDN上對《算法設計與分析》一書的學習筆記。</li>
<li><a href="http://zh.lucida.me/blog/on-learning-algorithms/">我的算法學習之路 - Lucida</a> - Google 工程師的演算法學習經驗分享。</li>
</ul>
<h2>書籍推薦</h2>
<p>本節後三項參考自九章微信分享，謝過。</p>
<ul>
<li><a href="http://book.douban.com/subject/1475870/">Algorithm Design (豆瓣)</a></li>
<li><a href="http://www.amazon.com/exec/obidos/ASIN/1848000693/thealgorithmrepo">The Algorithm Design Manual</a>, 作者還放出了自己上課的影片和slides - <a href="http://www3.cs.stonybrook.edu/~algorith/video-lectures/">Skiena&#39;s Audio Lectures</a>，<a href="http://book.douban.com/subject/3072383/">The Algorithm Design Manual (豆瓣)</a></li>
<li>大部頭有 <em>Introduction to Algorithm</em> 和 TAOCP</li>
<li><em>Cracking The Coding Interview</em>. 著名的CTCI(又稱CC150)，Google, Mircosoft, LinkedIn 前HR離職之後寫的書，從很全面的角度剖析了面試的各個環節和題目。除了演算法資料結構等題以外，還包含OO Design, Database, System Design, Brain Teaser等類型的題目。準備北美面試的同學一定要看。</li>
<li><em>劍指Offer</em>。適合中國找工作的同學看看，英文版叫Coding Interviews. 作者是何海濤(Harry He)。Amazon.cn上可以買到。有大概50多題，題目的分析比較全面，會從面試官的角度給出很多的建議和show各種坑。</li>
<li><em>進軍矽谷</em> -- 程序員面試揭秘。有差不多150題。</li>
</ul>
<h2>學習資源推薦(繁體中文譯者)</h2>
<h3>入門</h3>
<ul>
<li><p><a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-EHEP001657.html">Data Structures and Algorithms in C++</a>
-by Michael T. Goodrich, Roberto Tamassia and David M. Mount</p>
<p>  台大資工系的<strong>資料結構與演算法</strong>上課用書，內容好懂易讀，習題量大且深度廣度兼具，程式碼風格俐落而不失功能完整性，對C++背景的同學來說是良好的資料結構入門書。</p>
</li>
<li><p><a href="https://www.edx.org/course/data-structures-shu-ju-jie-gou-tsinghuax-30240184x-2">Data Structures • 數據結構</a>(MOOC)</p>
<p>  北京清華大學的鄧俊輝老師開設的中文MOOC，以C++為主要的程式語言，對於一上來就看書覺得枯燥的同學是一帖入門良藥，講解深入淺出，投影片視覺化做得極好，程式作業禁用了部分STL如vector、list、set等，要求學生必須自己實現需要用的資料結構，程式作業使用清華自建的OJ平台，可以同時跟其他線上學習的同學競爭，作業表現優良的同學還可以加入清華內部的討論群組與清華的學生切磋，相當受用。</p>
</li>
</ul>
<h3>進階</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FAQ]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/faq/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/faq/">
        </link>
        <updated>2019-11-03T15:41:57Z</updated>
        <summary type="html"><![CDATA[<h1>FAQ - Frequently Asked Question</h1>
<p>Some guidelines for contributing and other questions are listed here.</p>
<h2>How to Contribute?</h2>
<ul>
<li>Access <a href="http://algorithm.yuanbin.me/en/faq/guidelines_for_contributing.md">Guidelines for Contributing</a> for details.</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>FAQ - Frequently Asked Question</h1>
<p>Some guidelines for contributing and other questions are listed here.</p>
<h2>How to Contribute?</h2>
<ul>
<li>Access <a href="http://algorithm.yuanbin.me/en/faq/guidelines_for_contributing.md">Guidelines for Contributing</a> for details.</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Guidelines for Contributing]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/faq/guidelines_for_contributing.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/faq/guidelines_for_contributing.html">
        </link>
        <updated>2019-11-03T15:41:57Z</updated>
        <summary type="html"><![CDATA[<h1>Guidelines for Contributing</h1>
<!-- toc -->
<ul>
<li><a href="#更新翻譯特定語言">更新/翻譯特定語言</a></li>
<li><a href="#目錄生成">目錄生成</a></li>
<li><a href="#文檔格式及編輯工具---gfm--kramdown-markdown">文檔格式及編輯工具 - GFM &amp;&amp; kramdown Markdown</a></li>
<li><a href="#章節名及編號">章節名及編號</a></li>
<li><a href="#正文書寫風格">正文書寫風格</a><ul>
<li><a href="#數學公式">數學公式</a></li>
<li><a href="#附件及圖片引用">附件及圖片引用</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<ul>
<li>Access English via <a href="http://algorithm.yuanbin.me/en/faq/guidelines_for_contributing.md">Guidelines for Contributing</a></li>
<li>繁體中文請移步 <a href="http://algorithm.yuanbin.me/zh-tw/faq/guidelines_for_contributing.md">貢獻指南</a></li>
<li>简体中文请移步 <a href="http://algorithm.yuanbin.zh-hans/faq/guidelines_for_contributing.md">贡献指南</a></li>
</ul>
<p>除去 <a href="http://algorithm.yuanbin.me/zh-hans/faq/index.html">FAQ</a> 中提到的兩種輕量級貢獻方法外，你還可以採用 git 這種分佈式協作工具一起改進這個文檔。</p>
<p>如果你不確定自己是否會貢獻比較多的內容，那麼在 GitHub 上 fork 後發 Pull Reqeust 就好了。如果你想成爲 Collaborators 貢獻大量內容, 那麼請大膽發郵件到(yuanbin2014(at)gmail.com)，大歡迎~</p>
<p>總結一下 git 的工作流程就是：</p>
<ol>
<li>從遠端更新 - <code>git pull origin master</code></li>
<li>commit 本機更改 - <code>git commit -a -m &#39;xxx&#39;</code></li>
<li>推送回遠端 - <code>git push origin master</code></li>
</ol>
<p>有些時候在 commit 之前可能會忘記 pull, 那麼此時 pull 將會產生一個 merge commit, 這顯然是不太優雅的，建議使用<code>git rebase -i</code> 解決。</p>
<p>git 的簡明教學可參考 b哥的 <a href="https://gist.github.com/bigeagle/3953973">Git Manual</a>, 小清新極簡教程可參考 <a href="http://rogerdudler.github.io/git-guide/">git - the simple guide - no deep shit!</a>, rebase 的使用可參考 <a href="http://stackoverflow.com/questions/21115596/remove-a-merge-commit-keeping-current-changes">1</a>, <a href="https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E8%A1%8D%E5%90%88">2</a>, <a href="https://blog.yorkxin.org/posts/2011/07/29/git-rebase/">3</a></p>
<p>既然涉及到文檔合作，那麼最好是能有個像樣的文檔規範之類的東西方便大家更好的合(ㄐㄧㄠ)作(ㄐ一ˋ)，目前想到的有如下幾點。</p>
<h2>更新/翻譯特定語言</h2>
<p>Gitbook 支持多語言書寫，具體通過根目錄下的 <code>LANGs.md</code> 目錄指定，目前根目錄下有<code>en</code>, <code>zh-hans</code>, <code>zh-tw</code> 三個子文件夾分別用於三種語言的書寫，每個子文件夾相當於一個單獨的 Gitbook, 與其他語言的文檔是獨立的，所以更新時只需在各自語言的目錄下工作就好了。各語言的 SUMMARY.md 文件內容保持一致，且均使用英文。</p>
<h2>目錄生成</h2>
<p>Gitbook 中使用<code>SUMMARY.md</code>這個文件控制生成目錄，添加新內容時最好使用 Gitbook 家自帶的編輯器添加，這樣省事一點點。</p>
<h2>文檔格式及編輯工具 - GFM &amp;&amp; kramdown Markdown</h2>
<p>使用markdown編寫，只使用 Gitbook 支援的 markdown 語法。Gitbook 底層的 markdown renderer 爲改動的 kramdown，並增加了GFM支援, 支援的擴充 markdown 語法算是非常多了，具體特性詳見 <a href="https://github.com/GitbookIO/kramed">GitbookIO/kramed</a></p>
<p>推薦的 markdown 編輯器爲 Gitbook 自家的 <a href="https://www.gitbook.com/editor">editor</a>, 目前新版的 bug 太多，而且是自動 commit 的，不便於版本控制，希望他們後續能改進。所以目前推薦老版，老版的見 <a href="https://github.com/GitbookIO/editor-legacy/releases">editor-lagecy</a>, 支持 Windows/Linux/MAC 三大平臺，業界良心！但是實測在Arch Linux/OSX 下可能會出現佔用記憶體/CPU過高的情況... 編輯界面如下圖所示，最左邊爲章節預覽，中間爲 markdown 編輯框，右邊爲實時render頁面，可選擇使用全屏模式。</p>
<p><img src="../../shared-files/images/gitbook_editor.png" alt="Gitbook Editor"></p>
<p>使用其他如 Mou/Vim/Emacs/Sublime Text也不錯，但是在新增Chapter/Section時就比較麻煩了，嗯，你也可以新建 Section 後再使用其他編輯器編輯。</p>
<p>對 Gitbook 不熟的建議看看 <a href="http://help.gitbook.com/">Gitbook Documentation</a>，有助於瞭解 <a href="http://algorithm.yuanbin.me">http://algorithm.yuanbin.me</a> 網頁上的文字及各章節等是如何編輯及render的。</p>
<h2>章節名及編號</h2>
<p>章節等文件名全部採用英文，子章節最多到三級，章節編號無需操心，這種瑣事交給 Gitbook 去做就好，如果一定要手動調整，修改<code>SUMMARY.md</code>文件，注意其中的縮排關係，Gitbook就依靠這個自動給章節編號了。</p>
<p>舉個例子，我現在想新增「動態規劃」及其子章節。首先在 Gitbook 頂部menu欄「Book」中找到「Add Chapter」，填入「Dynamic Programming」。好了，在Gitbook左側章節欄中就能看到新生成的「10. Dynamic Programming」了，左鍵單擊，Gitbook 就會生成「dynamic_programming」目錄及本章的說明文件「dynamic_programming/README.md」。如果想在「10. Dynamic Programming」下新增子章節，右鍵單擊，「Add Section」即可，同上，子章節文件名仍然使用英文名，網頁顯示的標題可以通過 rename 更改再加入中文。</p>
<p>嗯，以上步驟均可直接新建文件夾及操作<code>SUMMARY.md</code>文件完成。</p>
<h2>正文書寫風格</h2>
<ol>
<li>中英文混排貫穿全文，優雅美觀起見，儘可能在英文單詞前後加空格，這個使用能在輸入法中英文間加入空格功能就好了。</li>
<li>程式碼的函數名或短的程式碼建議使用 `code`</li>
<li>使用空行進行分段，嗯，markdown通用</li>
</ol>
<p>Part II爲leetcode/lintcode題解，這部分的風格相對容易統一，感覺還不錯的風格 - <a href="https://github.com/billryan/algorithm-exercise/blob/master/zh-hans/dynamic_programming/distinct_subsequences.md">Distinct Subsequences</a></p>
<p>大致遵循如下風格：</p>
<ol>
<li>給出題目鏈接及原文，引用的原文部分簡單起見我對題目使用了blockquote ，具體可參考我的那些markdown文本。</li>
<li>給出自己的題解，儘可能清晰易懂。</li>
<li>給出能AC的code, 如遇TLE或者錯誤的看情況給出錯誤的實現。使用blockquote, 給出語言類別以便highlight。具體可參看原markdown文件。</li>
<li>題解中的核心部分對應的程式碼，程式碼中不能明顯看出來的邏輯和一些程式上常用的技巧。</li>
<li>程式碼順序：Python =&gt; C++ =&gt; Java 因爲 Python 的程式碼一般最爲簡潔...</li>
<li>如參考了其他資源，儘可能給出有用的參考鏈接，附簡單的說明。</li>
</ol>
<p>通過github合作時，添加/修改內容時給出能看懂的commit就好了。暫時就想到這麼多，其實沒那麼多講究啦，感覺看著清楚就好，其他想到的再補充。:-)</p>
<h3>數學公式</h3>
<p>其實程式碼裡是用不著寫數學公式的，但是偶爾分析演算法可能會用著，用過 LaTeX 的都知道她生成的數學公式有多優雅，以至於不用她來寫數學公式都有點不舒服...</p>
<p>這個文檔裡對於較複雜的數學公式建議使用 LaTeX, 因爲託管在gitbook上，所以就用了輕量級的katex插件，沒有用重量級的 MathJax。行內(inline)和行間公式都是 兩個$, 區別在於行間公式寫到下一行行首，而行內公式不能寫在行首(廢話...)。katex非常脆弱，對一些高級的 LaTeX 語法不支援，否則無法編譯輸出到網站和pdf，儘量用簡單的 LaTeX 語法或者不用。</p>
<h3>附件及圖片引用</h3>
<p>圖片統一存放在<code>images</code>目錄下，其他附件存放在<code>docs</code>目錄下。引用圖片鏈接一般可以通過<code>![Caption](../../shared-files/images/xxx.png)</code>聲明。</p>
<p>圖片體積太大不利於頁面載入，建議先壓縮後再放入，如果是png圖片可考慮使用 <a href="https://tinypng.com/">TinyPNG – Compress PNG images while preserving transparency</a></p>
]]></summary>
        <content type="html"><![CDATA[<h1>Guidelines for Contributing</h1>
<!-- toc -->
<ul>
<li><a href="#更新翻譯特定語言">更新/翻譯特定語言</a></li>
<li><a href="#目錄生成">目錄生成</a></li>
<li><a href="#文檔格式及編輯工具---gfm--kramdown-markdown">文檔格式及編輯工具 - GFM &amp;&amp; kramdown Markdown</a></li>
<li><a href="#章節名及編號">章節名及編號</a></li>
<li><a href="#正文書寫風格">正文書寫風格</a><ul>
<li><a href="#數學公式">數學公式</a></li>
<li><a href="#附件及圖片引用">附件及圖片引用</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<ul>
<li>Access English via <a href="http://algorithm.yuanbin.me/en/faq/guidelines_for_contributing.md">Guidelines for Contributing</a></li>
<li>繁體中文請移步 <a href="http://algorithm.yuanbin.me/zh-tw/faq/guidelines_for_contributing.md">貢獻指南</a></li>
<li>简体中文请移步 <a href="http://algorithm.yuanbin.zh-hans/faq/guidelines_for_contributing.md">贡献指南</a></li>
</ul>
<p>除去 <a href="http://algorithm.yuanbin.me/zh-hans/faq/index.html">FAQ</a> 中提到的兩種輕量級貢獻方法外，你還可以採用 git 這種分佈式協作工具一起改進這個文檔。</p>
<p>如果你不確定自己是否會貢獻比較多的內容，那麼在 GitHub 上 fork 後發 Pull Reqeust 就好了。如果你想成爲 Collaborators 貢獻大量內容, 那麼請大膽發郵件到(yuanbin2014(at)gmail.com)，大歡迎~</p>
<p>總結一下 git 的工作流程就是：</p>
<ol>
<li>從遠端更新 - <code>git pull origin master</code></li>
<li>commit 本機更改 - <code>git commit -a -m &#39;xxx&#39;</code></li>
<li>推送回遠端 - <code>git push origin master</code></li>
</ol>
<p>有些時候在 commit 之前可能會忘記 pull, 那麼此時 pull 將會產生一個 merge commit, 這顯然是不太優雅的，建議使用<code>git rebase -i</code> 解決。</p>
<p>git 的簡明教學可參考 b哥的 <a href="https://gist.github.com/bigeagle/3953973">Git Manual</a>, 小清新極簡教程可參考 <a href="http://rogerdudler.github.io/git-guide/">git - the simple guide - no deep shit!</a>, rebase 的使用可參考 <a href="http://stackoverflow.com/questions/21115596/remove-a-merge-commit-keeping-current-changes">1</a>, <a href="https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E8%A1%8D%E5%90%88">2</a>, <a href="https://blog.yorkxin.org/posts/2011/07/29/git-rebase/">3</a></p>
<p>既然涉及到文檔合作，那麼最好是能有個像樣的文檔規範之類的東西方便大家更好的合(ㄐㄧㄠ)作(ㄐ一ˋ)，目前想到的有如下幾點。</p>
<h2>更新/翻譯特定語言</h2>
<p>Gitbook 支持多語言書寫，具體通過根目錄下的 <code>LANGs.md</code> 目錄指定，目前根目錄下有<code>en</code>, <code>zh-hans</code>, <code>zh-tw</code> 三個子文件夾分別用於三種語言的書寫，每個子文件夾相當於一個單獨的 Gitbook, 與其他語言的文檔是獨立的，所以更新時只需在各自語言的目錄下工作就好了。各語言的 SUMMARY.md 文件內容保持一致，且均使用英文。</p>
<h2>目錄生成</h2>
<p>Gitbook 中使用<code>SUMMARY.md</code>這個文件控制生成目錄，添加新內容時最好使用 Gitbook 家自帶的編輯器添加，這樣省事一點點。</p>
<h2>文檔格式及編輯工具 - GFM &amp;&amp; kramdown Markdown</h2>
<p>使用markdown編寫，只使用 Gitbook 支援的 markdown 語法。Gitbook 底層的 markdown renderer 爲改動的 kramdown，並增加了GFM支援, 支援的擴充 markdown 語法算是非常多了，具體特性詳見 <a href="https://github.com/GitbookIO/kramed">GitbookIO/kramed</a></p>
<p>推薦的 markdown 編輯器爲 Gitbook 自家的 <a href="https://www.gitbook.com/editor">editor</a>, 目前新版的 bug 太多，而且是自動 commit 的，不便於版本控制，希望他們後續能改進。所以目前推薦老版，老版的見 <a href="https://github.com/GitbookIO/editor-legacy/releases">editor-lagecy</a>, 支持 Windows/Linux/MAC 三大平臺，業界良心！但是實測在Arch Linux/OSX 下可能會出現佔用記憶體/CPU過高的情況... 編輯界面如下圖所示，最左邊爲章節預覽，中間爲 markdown 編輯框，右邊爲實時render頁面，可選擇使用全屏模式。</p>
<p><img src="../../shared-files/images/gitbook_editor.png" alt="Gitbook Editor"></p>
<p>使用其他如 Mou/Vim/Emacs/Sublime Text也不錯，但是在新增Chapter/Section時就比較麻煩了，嗯，你也可以新建 Section 後再使用其他編輯器編輯。</p>
<p>對 Gitbook 不熟的建議看看 <a href="http://help.gitbook.com/">Gitbook Documentation</a>，有助於瞭解 <a href="http://algorithm.yuanbin.me">http://algorithm.yuanbin.me</a> 網頁上的文字及各章節等是如何編輯及render的。</p>
<h2>章節名及編號</h2>
<p>章節等文件名全部採用英文，子章節最多到三級，章節編號無需操心，這種瑣事交給 Gitbook 去做就好，如果一定要手動調整，修改<code>SUMMARY.md</code>文件，注意其中的縮排關係，Gitbook就依靠這個自動給章節編號了。</p>
<p>舉個例子，我現在想新增「動態規劃」及其子章節。首先在 Gitbook 頂部menu欄「Book」中找到「Add Chapter」，填入「Dynamic Programming」。好了，在Gitbook左側章節欄中就能看到新生成的「10. Dynamic Programming」了，左鍵單擊，Gitbook 就會生成「dynamic_programming」目錄及本章的說明文件「dynamic_programming/README.md」。如果想在「10. Dynamic Programming」下新增子章節，右鍵單擊，「Add Section」即可，同上，子章節文件名仍然使用英文名，網頁顯示的標題可以通過 rename 更改再加入中文。</p>
<p>嗯，以上步驟均可直接新建文件夾及操作<code>SUMMARY.md</code>文件完成。</p>
<h2>正文書寫風格</h2>
<ol>
<li>中英文混排貫穿全文，優雅美觀起見，儘可能在英文單詞前後加空格，這個使用能在輸入法中英文間加入空格功能就好了。</li>
<li>程式碼的函數名或短的程式碼建議使用 `code`</li>
<li>使用空行進行分段，嗯，markdown通用</li>
</ol>
<p>Part II爲leetcode/lintcode題解，這部分的風格相對容易統一，感覺還不錯的風格 - <a href="https://github.com/billryan/algorithm-exercise/blob/master/zh-hans/dynamic_programming/distinct_subsequences.md">Distinct Subsequences</a></p>
<p>大致遵循如下風格：</p>
<ol>
<li>給出題目鏈接及原文，引用的原文部分簡單起見我對題目使用了blockquote ，具體可參考我的那些markdown文本。</li>
<li>給出自己的題解，儘可能清晰易懂。</li>
<li>給出能AC的code, 如遇TLE或者錯誤的看情況給出錯誤的實現。使用blockquote, 給出語言類別以便highlight。具體可參看原markdown文件。</li>
<li>題解中的核心部分對應的程式碼，程式碼中不能明顯看出來的邏輯和一些程式上常用的技巧。</li>
<li>程式碼順序：Python =&gt; C++ =&gt; Java 因爲 Python 的程式碼一般最爲簡潔...</li>
<li>如參考了其他資源，儘可能給出有用的參考鏈接，附簡單的說明。</li>
</ol>
<p>通過github合作時，添加/修改內容時給出能看懂的commit就好了。暫時就想到這麼多，其實沒那麼多講究啦，感覺看著清楚就好，其他想到的再補充。:-)</p>
<h3>數學公式</h3>
<p>其實程式碼裡是用不著寫數學公式的，但是偶爾分析演算法可能會用著，用過 LaTeX 的都知道她生成的數學公式有多優雅，以至於不用她來寫數學公式都有點不舒服...</p>
<p>這個文檔裡對於較複雜的數學公式建議使用 LaTeX, 因爲託管在gitbook上，所以就用了輕量級的katex插件，沒有用重量級的 MathJax。行內(inline)和行間公式都是 兩個$, 區別在於行間公式寫到下一行行首，而行內公式不能寫在行首(廢話...)。katex非常脆弱，對一些高級的 LaTeX 語法不支援，否則無法編譯輸出到網站和pdf，儘量用簡單的 LaTeX 語法或者不用。</p>
<h3>附件及圖片引用</h3>
<p>圖片統一存放在<code>images</code>目錄下，其他附件存放在<code>docs</code>目錄下。引用圖片鏈接一般可以通過<code>![Caption](../../shared-files/images/xxx.png)</code>聲明。</p>
<p>圖片體積太大不利於頁面載入，建議先壓縮後再放入，如果是png圖片可考慮使用 <a href="https://tinypng.com/">TinyPNG – Compress PNG images while preserving transparency</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Part I - Basics]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/part_i_basics/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/part_i_basics/">
        </link>
        <updated>2019-11-03T15:41:57Z</updated>
        <summary type="html"><![CDATA[<h1>Part I - Basics</h1>
<p>第一節主要總結一些基礎知識，如基本的資料結構和基礎演算法。</p>
<p>本節主要由以下章節構成。</p>
<h2>Reference</h2>
<ul>
<li><a href="http://visualgo.net/">VisuAlgo - visualising data structures and algorithms through animation</a> - 相當厲害的資料結構和演算法可視化。</li>
<li><a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualization</a> - 非常好的動畫示例！！涵蓋了常用的各種資料結構/排序/演算法。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Part I - Basics</h1>
<p>第一節主要總結一些基礎知識，如基本的資料結構和基礎演算法。</p>
<p>本節主要由以下章節構成。</p>
<h2>Reference</h2>
<ul>
<li><a href="http://visualgo.net/">VisuAlgo - visualising data structures and algorithms through animation</a> - 相當厲害的資料結構和演算法可視化。</li>
<li><a href="http://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualization</a> - 非常好的動畫示例！！涵蓋了常用的各種資料結構/排序/演算法。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Basics Data Structure]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_data_structure/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_data_structure/">
        </link>
        <updated>2019-11-03T15:41:57Z</updated>
        <summary type="html"><![CDATA[<h1>Data Structure - 資料結構</h1>
<p>本章主要介紹一些基本的資料結構和演算法。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Data Structure - 資料結構</h1>
<p>本章主要介紹一些基本的資料結構和演算法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[String]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_data_structure/string.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_data_structure/string.html">
        </link>
        <updated>2019-11-03T15:41:58Z</updated>
        <summary type="html"><![CDATA[<h1>String 字串</h1>
<p>String 相關的題很常出現在面試題中，實際開發也經常用到，這裡總結一下 C++, Java, Python 中字串常用的方法。</p>
<h2>Python</h2>
<pre><code class="lang-python">s1 = str()
# in python `&#39;&#39;` and `&quot;&quot;` are the same
s2 = &quot;shaunwei&quot; # &#39;shaunwei&#39;
s2len = len(s2)
# last 3 chars
s2[-3:] # wei
s2[5:8] # wei
s3 = s2[:5] # shaun
s3 += &#39;wei&#39; # return &#39;shaunwei&#39;
# list in python is same as ArrayList in java
s2list = list(s3)
# string at index 4
s2[4] # &#39;n&#39;
# find index at first
s2.index(&#39;w&#39;)  # return 5, if not found, throw ValueError
s2.find(&#39;w&#39;) # return 5, if not found, return -1
</code></pre>
<p>在Python裡面，沒有StringBuffer 或者 StringBuilder。 但是在Python 裡面處理String本身就比較 cheap。</p>
<h2>Java</h2>
<pre><code class="lang-java">String s1 = new String();
String s2 = &quot;billryan&quot;;
int s2Len = s2.length();
s2.substring(4, 8); // return &quot;ryan&quot;
StringBuilder s3 = new StringBuilder(s2.substring(4, 8));
s3.append(&quot;bill&quot;);
String s2New = s3.toString(); // return &quot;ryanbill&quot;
// convert String to char array
char[] s2Char = s2.toCharArray();
// char at index 4
char ch = s2.charAt(4); // return &#39;r&#39;
// find index at first
int index = s2.indexOf(&#39;r&#39;); // return 4. if not found, return -1
</code></pre>
<p>StringBuffer 與 StringBuilder, 前者保證執行緒安全(Thread Safety)，後者不是，但單執行緒下效率高一些，一般使用 StringBuilder.</p>
]]></summary>
        <content type="html"><![CDATA[<h1>String 字串</h1>
<p>String 相關的題很常出現在面試題中，實際開發也經常用到，這裡總結一下 C++, Java, Python 中字串常用的方法。</p>
<h2>Python</h2>
<pre><code class="lang-python">s1 = str()
# in python `&#39;&#39;` and `&quot;&quot;` are the same
s2 = &quot;shaunwei&quot; # &#39;shaunwei&#39;
s2len = len(s2)
# last 3 chars
s2[-3:] # wei
s2[5:8] # wei
s3 = s2[:5] # shaun
s3 += &#39;wei&#39; # return &#39;shaunwei&#39;
# list in python is same as ArrayList in java
s2list = list(s3)
# string at index 4
s2[4] # &#39;n&#39;
# find index at first
s2.index(&#39;w&#39;)  # return 5, if not found, throw ValueError
s2.find(&#39;w&#39;) # return 5, if not found, return -1
</code></pre>
<p>在Python裡面，沒有StringBuffer 或者 StringBuilder。 但是在Python 裡面處理String本身就比較 cheap。</p>
<h2>Java</h2>
<pre><code class="lang-java">String s1 = new String();
String s2 = &quot;billryan&quot;;
int s2Len = s2.length();
s2.substring(4, 8); // return &quot;ryan&quot;
StringBuilder s3 = new StringBuilder(s2.substring(4, 8));
s3.append(&quot;bill&quot;);
String s2New = s3.toString(); // return &quot;ryanbill&quot;
// convert String to char array
char[] s2Char = s2.toCharArray();
// char at index 4
char ch = s2.charAt(4); // return &#39;r&#39;
// find index at first
int index = s2.indexOf(&#39;r&#39;); // return 4. if not found, return -1
</code></pre>
<p>StringBuffer 與 StringBuilder, 前者保證執行緒安全(Thread Safety)，後者不是，但單執行緒下效率高一些，一般使用 StringBuilder.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linked List]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_data_structure/linked_list.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_data_structure/linked_list.html">
        </link>
        <updated>2019-11-03T15:41:58Z</updated>
        <summary type="html"><![CDATA[<h1>Linked List - 鏈表</h1>
<!-- toc -->
<ul>
<li><a href="#程式碼實現">程式碼實現</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#java">Java</a></li>
</ul>
</li>
<li><a href="#鏈表的基本操作">鏈表的基本操作</a><ul>
<li><a href="#反轉單向鏈表singly-linked-list">反轉單向鏈表(singly linked list)</a><ul>
<li><a href="#雙向鏈表">雙向鏈表</a></li>
</ul>
</li>
<li><a href="#python-1">Python</a></li>
<li><a href="#java-1">Java</a></li>
<li><a href="#刪除鏈表中的某個節點">刪除鏈表中的某個節點</a></li>
</ul>
</li>
<li><a href="#鏈表指標的強健性robustness">鏈表指標的強健性(robustness)</a></li>
<li><a href="#dummy-node">Dummy Node</a></li>
<li><a href="#快慢指標fastslow-pointer">快慢指標(fast/slow pointer)</a><ul>
<li><a href="#python-2">Python</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>鏈表是線性表(linear list)的一種。線性表是最基本、最簡單、也是最常用的一種資料結構。線性表中數據元素之間的關係是一對一的關系，即除了第一個和最後一個數據元素之外，其它數據元素都是首尾相接的。線性表有兩種儲存方式，一種是順序儲存結構，另一種是鏈式儲存結構。我們常用的陣列(array)就是一種典型的順序儲存結構。</p>
<p>相反，鏈式儲存結構就是兩個相鄰的元素在記憶體中可能不是物理相鄰的，每一個元素都有一個指標，指標一般是儲存著到下一個元素的指標。這種儲存方式的<strong>優點</strong>是已知插入位置時，定點插入和定點刪除的時間複雜度為 O(1)，不會浪費太多記憶體，添加元素的時候才會申請記憶體空間，刪除元素會釋放記憶體空間。缺點是訪問的時間複雜度最壞為 O(n)。</p>
<p>順序表的特性是隨機讀取，也就是循下標訪問(call-by-index)一個元素的時間複雜度是O(1)，鏈式表的特性是插入和刪除的時間複雜度為O(1)。</p>
<p>鏈表就是鏈式儲存的線性表。根據指標域的不同，鏈表分為單向鏈表、雙向鏈表、循環鏈表等等。</p>
<h2>程式碼實現</h2>
<h3>Python</h3>
<pre><code class="lang-python">class ListNode:
    def __init__(self, val):
        self.val = val
        self.next = None
</code></pre>
<h3>C++</h3>
<pre><code class="lang-cpp">struct ListNode {
    int val;
    ListNode *next;
    ListNode(int val, ListNode *next=NULL):val(val),next(next){}
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class ListNode {
    public int val;
    public ListNode next;
    public ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}
</code></pre>
<h2>鏈表的基本操作</h2>
<h3>反轉單向鏈表(singly linked list)</h3>
<p>鏈表的基本形式是：<code>1 -&gt; 2 -&gt; 3 -&gt; null</code>，反轉需要變為 <code>3 -&gt; 2 -&gt; 1 -&gt; null</code>。這裡要注意：</p>
<ul>
<li>訪問某個節點 curt.next 時，要檢驗 curt 是否為 null。</li>
<li>要把反轉後的最後一個節點（即反轉前的第一個節點）指向 null。</li>
</ul>
<pre><code class="lang-java">public ListNode reverse(ListNode head) {
    ListNode prev = null;
    while (head != null) {
        ListNode next = head.next;
        head.next = prev;
        prev = head;
        head = next;
    }
    return prev;
}
</code></pre>
<h4>雙向鏈表</h4>
<p>和單向鏈表的區別在於：雙向鏈表的反轉核心在於<code>next</code>和<code>prev</code>域的交換，還需要注意的是目前節點和上一個節點的遞推。</p>
<h3>Python</h3>
<pre><code class="lang-python">class DListNode:
    def __init__(self, val):
        self.val = val
        self.prev = self.next = null

    def reverse(self, head):
        curt = None
        while head:
            curt = head
            head = curt.next
            curt.next = curt.prev
            curt.prev = head
        return curt
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">class DListNode {
    int val;
    DListNode prev, next;
    DListNode(int val) {
        this.val = val;
        this.prev = this.next = null;
    }
}

public DListNode reverse(DListNode head) {
    DListNode curr = null;
    while (head != null) {
        curr = head;
        head = curr.next;
        curr.next = curr.prev;
        curr.prev = head;
    }
    return curr;
}
</code></pre>
<h3>刪除鏈表中的某個節點</h3>
<p>刪除鏈表中的某個節點一定需要知道這個點的前繼節點，所以需要一直有指標指向前繼節點。</p>
<p>然後只需要把 <code>prev -&gt; next = prev -&gt; next -&gt; next</code> 即可。但是由於鏈表表頭可能在這個過程中產生變化，導致我們需要一些特別的技巧去處理這種情況。就是下面提到的 Dummy Node。</p>
<h2>鏈表指標的強健性(robustness)</h2>
<p>綜合上面討論的兩種基本操作，鏈表操作時的強健性問題主要包含兩個情況：</p>
<ul>
<li>當訪問鏈表中某個節點 curt.next 時，一定要先判斷 curt 是否為 null。</li>
<li>全部操作結束後，判斷是否有環；若有環，則置其中一端為 null。</li>
</ul>
<h2>Dummy Node</h2>
<p>Dummy node 是鏈表問題中一個重要的技巧，中文翻譯叫「啞節點」或者「假人頭結點」。</p>
<p>Dummy node 是一個虛擬節點，也可以認為是標竿節點。Dummy node 就是在鏈表表頭 head 前加一個節點指向 head，即 dummy -&gt; head。Dummy node 的使用多針對單向鏈表沒有前向指標的問題，保證鏈表的 head 不會在刪除操作中遺失。除此之外，還有一種用法比較少見，就是使用 dummy node 來進行head的刪除操作，比如 <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">Remove Duplicates From Sorted List II</a>，一般的方法current = current.next 是無法刪除 head 元素的，所以這個時候如果有一個dummy node在head的前面。</p>
<p>所以，當鏈表的 head 有可能變化（被修改或者被刪除）時，使用 dummy node 可以簡化程式碼及很多邊界情況的處理，最終返回 dummy.next 即新的鏈表。</p>
<h2>快慢指標(fast/slow pointer)</h2>
<p>快慢指標也是一個可以用於很多問題的技巧。所謂快慢指標中的快慢指的是指標向前移動的步長，每次移動的步長較大即為快，步長較小即為慢，常用的快慢指標一般是在單向鏈表中讓快指標每次向前移動2，慢指標則每次向前移動1。快慢兩個指標都從鏈表頭開始遍曆，於是快指標到達鏈表末尾的時候慢指標剛好到達中間位置，於是可以得到中間元素的值。快慢指標在鏈表相關問題中主要有兩個應用：</p>
<ul>
<li>快速找出未知長度單向鏈表的中間節點
  設置兩個指標 <code>*fast</code>、<code>*slow</code> 都指向單向鏈表的頭節點，其中<code>*fast</code>的移動速度是<code>*slow</code>的2倍，當<code>*fast</code>指向末尾節點的時候，<code>slow</code>正好就在中間了。此方法可以有效避免多次遍歷鏈表</li>
<li>判斷單向鏈表是否有環
  利用快慢指標的原理，同樣設置兩個指標 <code>*fast</code>、<code>*slow</code> 都指向單向鏈表的頭節點，其中 <code>*fast</code>的移動速度是<code>*slow</code>的2倍。如果 <code>*fast = NULL</code>，說明該單向鏈表 以 <code>NULL</code>結尾，不是循環鏈表；如果 <code>*fast = *slow</code>，則快指標追上慢指標，說明該鏈表是循環鏈表。</li>
</ul>
<h3>Python</h3>
<pre><code class="lang-python">class NodeCircle:
    def __init__(self, val):
        self.val = val
        self.next = None

    def has_circle(self, head):
        slow = head
        fast = head
        while (slow and fast):
            fast = fast.next
            slow = slow.next
            if fast:
                fast = fast.next
            if fast == slow:
                break
        if fast and slow and (fast == slow):
            return True
        else:
            return False
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1>Linked List - 鏈表</h1>
<!-- toc -->
<ul>
<li><a href="#程式碼實現">程式碼實現</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#java">Java</a></li>
</ul>
</li>
<li><a href="#鏈表的基本操作">鏈表的基本操作</a><ul>
<li><a href="#反轉單向鏈表singly-linked-list">反轉單向鏈表(singly linked list)</a><ul>
<li><a href="#雙向鏈表">雙向鏈表</a></li>
</ul>
</li>
<li><a href="#python-1">Python</a></li>
<li><a href="#java-1">Java</a></li>
<li><a href="#刪除鏈表中的某個節點">刪除鏈表中的某個節點</a></li>
</ul>
</li>
<li><a href="#鏈表指標的強健性robustness">鏈表指標的強健性(robustness)</a></li>
<li><a href="#dummy-node">Dummy Node</a></li>
<li><a href="#快慢指標fastslow-pointer">快慢指標(fast/slow pointer)</a><ul>
<li><a href="#python-2">Python</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>鏈表是線性表(linear list)的一種。線性表是最基本、最簡單、也是最常用的一種資料結構。線性表中數據元素之間的關係是一對一的關系，即除了第一個和最後一個數據元素之外，其它數據元素都是首尾相接的。線性表有兩種儲存方式，一種是順序儲存結構，另一種是鏈式儲存結構。我們常用的陣列(array)就是一種典型的順序儲存結構。</p>
<p>相反，鏈式儲存結構就是兩個相鄰的元素在記憶體中可能不是物理相鄰的，每一個元素都有一個指標，指標一般是儲存著到下一個元素的指標。這種儲存方式的<strong>優點</strong>是已知插入位置時，定點插入和定點刪除的時間複雜度為 O(1)，不會浪費太多記憶體，添加元素的時候才會申請記憶體空間，刪除元素會釋放記憶體空間。缺點是訪問的時間複雜度最壞為 O(n)。</p>
<p>順序表的特性是隨機讀取，也就是循下標訪問(call-by-index)一個元素的時間複雜度是O(1)，鏈式表的特性是插入和刪除的時間複雜度為O(1)。</p>
<p>鏈表就是鏈式儲存的線性表。根據指標域的不同，鏈表分為單向鏈表、雙向鏈表、循環鏈表等等。</p>
<h2>程式碼實現</h2>
<h3>Python</h3>
<pre><code class="lang-python">class ListNode:
    def __init__(self, val):
        self.val = val
        self.next = None
</code></pre>
<h3>C++</h3>
<pre><code class="lang-cpp">struct ListNode {
    int val;
    ListNode *next;
    ListNode(int val, ListNode *next=NULL):val(val),next(next){}
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class ListNode {
    public int val;
    public ListNode next;
    public ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}
</code></pre>
<h2>鏈表的基本操作</h2>
<h3>反轉單向鏈表(singly linked list)</h3>
<p>鏈表的基本形式是：<code>1 -&gt; 2 -&gt; 3 -&gt; null</code>，反轉需要變為 <code>3 -&gt; 2 -&gt; 1 -&gt; null</code>。這裡要注意：</p>
<ul>
<li>訪問某個節點 curt.next 時，要檢驗 curt 是否為 null。</li>
<li>要把反轉後的最後一個節點（即反轉前的第一個節點）指向 null。</li>
</ul>
<pre><code class="lang-java">public ListNode reverse(ListNode head) {
    ListNode prev = null;
    while (head != null) {
        ListNode next = head.next;
        head.next = prev;
        prev = head;
        head = next;
    }
    return prev;
}
</code></pre>
<h4>雙向鏈表</h4>
<p>和單向鏈表的區別在於：雙向鏈表的反轉核心在於<code>next</code>和<code>prev</code>域的交換，還需要注意的是目前節點和上一個節點的遞推。</p>
<h3>Python</h3>
<pre><code class="lang-python">class DListNode:
    def __init__(self, val):
        self.val = val
        self.prev = self.next = null

    def reverse(self, head):
        curt = None
        while head:
            curt = head
            head = curt.next
            curt.next = curt.prev
            curt.prev = head
        return curt
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">class DListNode {
    int val;
    DListNode prev, next;
    DListNode(int val) {
        this.val = val;
        this.prev = this.next = null;
    }
}

public DListNode reverse(DListNode head) {
    DListNode curr = null;
    while (head != null) {
        curr = head;
        head = curr.next;
        curr.next = curr.prev;
        curr.prev = head;
    }
    return curr;
}
</code></pre>
<h3>刪除鏈表中的某個節點</h3>
<p>刪除鏈表中的某個節點一定需要知道這個點的前繼節點，所以需要一直有指標指向前繼節點。</p>
<p>然後只需要把 <code>prev -&gt; next = prev -&gt; next -&gt; next</code> 即可。但是由於鏈表表頭可能在這個過程中產生變化，導致我們需要一些特別的技巧去處理這種情況。就是下面提到的 Dummy Node。</p>
<h2>鏈表指標的強健性(robustness)</h2>
<p>綜合上面討論的兩種基本操作，鏈表操作時的強健性問題主要包含兩個情況：</p>
<ul>
<li>當訪問鏈表中某個節點 curt.next 時，一定要先判斷 curt 是否為 null。</li>
<li>全部操作結束後，判斷是否有環；若有環，則置其中一端為 null。</li>
</ul>
<h2>Dummy Node</h2>
<p>Dummy node 是鏈表問題中一個重要的技巧，中文翻譯叫「啞節點」或者「假人頭結點」。</p>
<p>Dummy node 是一個虛擬節點，也可以認為是標竿節點。Dummy node 就是在鏈表表頭 head 前加一個節點指向 head，即 dummy -&gt; head。Dummy node 的使用多針對單向鏈表沒有前向指標的問題，保證鏈表的 head 不會在刪除操作中遺失。除此之外，還有一種用法比較少見，就是使用 dummy node 來進行head的刪除操作，比如 <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">Remove Duplicates From Sorted List II</a>，一般的方法current = current.next 是無法刪除 head 元素的，所以這個時候如果有一個dummy node在head的前面。</p>
<p>所以，當鏈表的 head 有可能變化（被修改或者被刪除）時，使用 dummy node 可以簡化程式碼及很多邊界情況的處理，最終返回 dummy.next 即新的鏈表。</p>
<h2>快慢指標(fast/slow pointer)</h2>
<p>快慢指標也是一個可以用於很多問題的技巧。所謂快慢指標中的快慢指的是指標向前移動的步長，每次移動的步長較大即為快，步長較小即為慢，常用的快慢指標一般是在單向鏈表中讓快指標每次向前移動2，慢指標則每次向前移動1。快慢兩個指標都從鏈表頭開始遍曆，於是快指標到達鏈表末尾的時候慢指標剛好到達中間位置，於是可以得到中間元素的值。快慢指標在鏈表相關問題中主要有兩個應用：</p>
<ul>
<li>快速找出未知長度單向鏈表的中間節點
  設置兩個指標 <code>*fast</code>、<code>*slow</code> 都指向單向鏈表的頭節點，其中<code>*fast</code>的移動速度是<code>*slow</code>的2倍，當<code>*fast</code>指向末尾節點的時候，<code>slow</code>正好就在中間了。此方法可以有效避免多次遍歷鏈表</li>
<li>判斷單向鏈表是否有環
  利用快慢指標的原理，同樣設置兩個指標 <code>*fast</code>、<code>*slow</code> 都指向單向鏈表的頭節點，其中 <code>*fast</code>的移動速度是<code>*slow</code>的2倍。如果 <code>*fast = NULL</code>，說明該單向鏈表 以 <code>NULL</code>結尾，不是循環鏈表；如果 <code>*fast = *slow</code>，則快指標追上慢指標，說明該鏈表是循環鏈表。</li>
</ul>
<h3>Python</h3>
<pre><code class="lang-python">class NodeCircle:
    def __init__(self, val):
        self.val = val
        self.next = None

    def has_circle(self, head):
        slow = head
        fast = head
        while (slow and fast):
            fast = fast.next
            slow = slow.next
            if fast:
                fast = fast.next
            if fast == slow:
                break
        if fast and slow and (fast == slow):
            return True
        else:
            return False
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Binary Tree]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_data_structure/binary_tree.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_data_structure/binary_tree.html">
        </link>
        <updated>2019-11-03T15:41:58Z</updated>
        <summary type="html"><![CDATA[<h1>Binary Tree - 二元樹</h1>
<!-- toc -->
<ul>
<li><a href="#程式實現">程式實現</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
</ul>
</li>
<li><a href="#tree-traversal-樹的遍歷">Tree traversal 樹的遍歷</a><ul>
<li><a href="#python-1">Python</a></li>
</ul>
</li>
<li><a href="#樹類題的複雜度分析">樹類題的複雜度分析</a></li>
<li><a href="#binary-search-tree---二元搜尋樹">Binary Search Tree - 二元搜尋樹</a></li>
</ul>
<!-- tocstop -->
<p>二元樹是每個節點最多有兩個子樹的樹結構，子樹有左右之分，二元樹常被用於實現<strong>二元搜尋樹(binary search tree)</strong>和<strong>二元堆(binary heap)</strong>。</p>
<p>二元樹的第i層(根結點為第1層，往下遞增)至多有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.824664em;"></span><span class="strut bottom" style="height:0.824664em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">i</span><span class="mbin mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span> 個結點；深度為k的二元樹至多有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.849108em;"></span><span class="strut bottom" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span> 個結點；對任何一棵二元樹T，如果其終端結點數為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>, 度為2的結點數為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>, 則 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0=n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span>。</p>
<p>一棵深度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>, 且有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.849108em;"></span><span class="strut bottom" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span> 個節點稱之為<strong>滿二元樹</strong>；深度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> 個節點的二元樹，若且唯若其每一個節點都與深度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span> 的滿二元樹中，序號為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> 的節點對應時，稱之為<strong>完全二元樹</strong>。完全二元樹中重在節點標號對應。</p>
<h2>程式實現</h2>
<h3>Python</h3>
<pre><code class="lang-python">class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class TreeNode {
    public int val;
    public TreeNode left, right;
    public TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}
</code></pre>
<h2>Tree traversal 樹的遍歷</h2>
<p>從二元樹的根節點出發，節點的遍歷分為三個主要步驟：對當前節點進行操作（稱為「訪問」節點，或者根節點）、遍歷左邊子節點、遍歷右邊子節點。訪問節點順序的不同也就形成了不同的遍歷方式。需要注意的是樹的遍歷通常使用遞迴的方法進行理解和實現，在訪問元素時也需要使用遞迴的思想去理解。</p>
<p>按照訪問根元素(當前元素)的前後順序，遍歷方式可劃分為如下幾種：</p>
<ul>
<li>深度優先(depth-first)：先訪問子節點，再訪問父節點，最後訪問第二個子節點。根據根節點相對於左右子節點的訪問先後順序又可細分為以下三種方式。<ol>
<li>前序(pre-order)：先根後左再右</li>
<li>中序(in-order)：先左後根再右</li>
<li>後序(post-order)：先左後右再根</li>
</ol>
</li>
<li>廣度優先(breadth-first)：先訪問根節點，沿著樹的寬度遍歷子節點，直到所有節點均被訪問為止，又稱為層次(level-order)遍歷。</li>
</ul>
<p>如下圖所示，遍歷順序在右側框中，紅色A為根節點。使用遞迴和整體的思想去分析遍歷順序較為清晰。</p>
<p>二元樹的廣度優先遍歷和樹的前序/中序/後序遍歷不太一樣，前/中/後序遍歷使用遞迴，也就是用堆疊(stack)的思想對二元樹進行遍歷，廣度優先一般使用隊列(queue)的思想對二元樹進行遍歷。</p>
<p>如果已知中序遍歷和前序遍歷或者後序遍歷，那麼就可以完全恢復出原二元樹結構。其中最爲關鍵的是前序遍歷中第一個一定是根，而後序遍歷最後一個一定是根，中序遍歷在得知根節點後又可進一步遞歸得知左右子樹的根節點。但是這種方法也是有適用範圍的：元素不能重複！否則無法完成定位。</p>
<p><img src="../../shared-files/images/binary_tree_traversal.png" alt="Binary Tree Traversal"></p>
<h3>Python</h3>
<pre><code class="lang-python">class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None

class Traversal(object):
    def __init__(self):
        self.traverse_path = list()

    def preorder(self, root):
        if root:
            self.traverse_path.append(root.val)
            self.preorder(root.left)
            self.preorder(root.right)

    def inorder(self,root):
        if root:
            self.inorder(root.left)
            self.traverse_path.append(root.val)
            self.inorder(root.right)

    def postorder(self,root):
        if root:
            self.postorder(root.left)
            self.postorder(root.right)
            self.traverse_path.append(root.val)
</code></pre>
<p>這裡只給出簡單的 python 遞迴版實現，C++ 和 Java 的程式碼以及非遞迴版本的實現，敬請期待後續章節。 </p>
<h2>樹類題的複雜度分析</h2>
<p>對樹相關的題進行複雜度分析時可統計對每個節點被訪問的次數，進而求得總的時間複雜度。</p>
<h2>Binary Search Tree - 二元搜尋樹</h2>
<p>一顆<strong>二元搜尋樹(BST)</strong>是一顆二元樹，其中每個節點都含有一個可進行比較的鍵及相應的值，且每個節點的鍵都<strong>大於等於左子樹中的任意節點的鍵</strong>，而<strong>小於右子樹中的任意節點的鍵</strong>。</p>
<p>使用中序遍歷可得到有序數列，這是二元搜尋樹的又一個重要特徵。</p>
<p>二元搜尋樹使用的每個節點含有<strong>兩個</strong>鏈接，它是將鏈表插入的靈活性和有序陣列查找的高效性結合起來的高效符號表實現。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Binary Tree - 二元樹</h1>
<!-- toc -->
<ul>
<li><a href="#程式實現">程式實現</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
</ul>
</li>
<li><a href="#tree-traversal-樹的遍歷">Tree traversal 樹的遍歷</a><ul>
<li><a href="#python-1">Python</a></li>
</ul>
</li>
<li><a href="#樹類題的複雜度分析">樹類題的複雜度分析</a></li>
<li><a href="#binary-search-tree---二元搜尋樹">Binary Search Tree - 二元搜尋樹</a></li>
</ul>
<!-- tocstop -->
<p>二元樹是每個節點最多有兩個子樹的樹結構，子樹有左右之分，二元樹常被用於實現<strong>二元搜尋樹(binary search tree)</strong>和<strong>二元堆(binary heap)</strong>。</p>
<p>二元樹的第i層(根結點為第1層，往下遞增)至多有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.824664em;"></span><span class="strut bottom" style="height:0.824664em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">i</span><span class="mbin mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span> 個結點；深度為k的二元樹至多有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.849108em;"></span><span class="strut bottom" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span> 個結點；對任何一棵二元樹T，如果其終端結點數為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>, 度為2的結點數為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>, 則 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0=n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span>。</p>
<p>一棵深度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>, 且有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.849108em;"></span><span class="strut bottom" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span> 個節點稱之為<strong>滿二元樹</strong>；深度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> 個節點的二元樹，若且唯若其每一個節點都與深度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span> 的滿二元樹中，序號為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> 的節點對應時，稱之為<strong>完全二元樹</strong>。完全二元樹中重在節點標號對應。</p>
<h2>程式實現</h2>
<h3>Python</h3>
<pre><code class="lang-python">class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class TreeNode {
    public int val;
    public TreeNode left, right;
    public TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}
</code></pre>
<h2>Tree traversal 樹的遍歷</h2>
<p>從二元樹的根節點出發，節點的遍歷分為三個主要步驟：對當前節點進行操作（稱為「訪問」節點，或者根節點）、遍歷左邊子節點、遍歷右邊子節點。訪問節點順序的不同也就形成了不同的遍歷方式。需要注意的是樹的遍歷通常使用遞迴的方法進行理解和實現，在訪問元素時也需要使用遞迴的思想去理解。</p>
<p>按照訪問根元素(當前元素)的前後順序，遍歷方式可劃分為如下幾種：</p>
<ul>
<li>深度優先(depth-first)：先訪問子節點，再訪問父節點，最後訪問第二個子節點。根據根節點相對於左右子節點的訪問先後順序又可細分為以下三種方式。<ol>
<li>前序(pre-order)：先根後左再右</li>
<li>中序(in-order)：先左後根再右</li>
<li>後序(post-order)：先左後右再根</li>
</ol>
</li>
<li>廣度優先(breadth-first)：先訪問根節點，沿著樹的寬度遍歷子節點，直到所有節點均被訪問為止，又稱為層次(level-order)遍歷。</li>
</ul>
<p>如下圖所示，遍歷順序在右側框中，紅色A為根節點。使用遞迴和整體的思想去分析遍歷順序較為清晰。</p>
<p>二元樹的廣度優先遍歷和樹的前序/中序/後序遍歷不太一樣，前/中/後序遍歷使用遞迴，也就是用堆疊(stack)的思想對二元樹進行遍歷，廣度優先一般使用隊列(queue)的思想對二元樹進行遍歷。</p>
<p>如果已知中序遍歷和前序遍歷或者後序遍歷，那麼就可以完全恢復出原二元樹結構。其中最爲關鍵的是前序遍歷中第一個一定是根，而後序遍歷最後一個一定是根，中序遍歷在得知根節點後又可進一步遞歸得知左右子樹的根節點。但是這種方法也是有適用範圍的：元素不能重複！否則無法完成定位。</p>
<p><img src="../../shared-files/images/binary_tree_traversal.png" alt="Binary Tree Traversal"></p>
<h3>Python</h3>
<pre><code class="lang-python">class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None

class Traversal(object):
    def __init__(self):
        self.traverse_path = list()

    def preorder(self, root):
        if root:
            self.traverse_path.append(root.val)
            self.preorder(root.left)
            self.preorder(root.right)

    def inorder(self,root):
        if root:
            self.inorder(root.left)
            self.traverse_path.append(root.val)
            self.inorder(root.right)

    def postorder(self,root):
        if root:
            self.postorder(root.left)
            self.postorder(root.right)
            self.traverse_path.append(root.val)
</code></pre>
<p>這裡只給出簡單的 python 遞迴版實現，C++ 和 Java 的程式碼以及非遞迴版本的實現，敬請期待後續章節。 </p>
<h2>樹類題的複雜度分析</h2>
<p>對樹相關的題進行複雜度分析時可統計對每個節點被訪問的次數，進而求得總的時間複雜度。</p>
<h2>Binary Search Tree - 二元搜尋樹</h2>
<p>一顆<strong>二元搜尋樹(BST)</strong>是一顆二元樹，其中每個節點都含有一個可進行比較的鍵及相應的值，且每個節點的鍵都<strong>大於等於左子樹中的任意節點的鍵</strong>，而<strong>小於右子樹中的任意節點的鍵</strong>。</p>
<p>使用中序遍歷可得到有序數列，這是二元搜尋樹的又一個重要特徵。</p>
<p>二元搜尋樹使用的每個節點含有<strong>兩個</strong>鏈接，它是將鏈表插入的靈活性和有序陣列查找的高效性結合起來的高效符號表實現。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Huffman Compression]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_data_structure/huffman_compression.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_data_structure/huffman_compression.html">
        </link>
        <updated>2019-11-03T15:41:58Z</updated>
        <summary type="html"><![CDATA[<h1>Huffman Compression - 霍夫曼壓縮</h1>
<p>主要思想：放棄文本文件的普通保存方式：不再使用7位或8位二進制數表示每一個字符，而是<strong>用較少的比特表示出現頻率最高的字符，用較多的比特表示出現頻率低的字符</strong>。</p>
<p>使用變動長度編碼(variable-length code)來表示字串，勢必會導致編解碼時碼字的唯一性問題，因此需要一種編解碼方式唯一的前綴碼(prefix code)，而表示前綴碼的一種簡單方式就是使用單詞搜尋樹，其中最優前綴碼即為Huffman首創。</p>
<p>以符號F, O, R, G, E, T為例，其出現的頻次如以下表格所示。</p>
<table>
<thead>
<tr>
<th>Symbol</th>
<th>F</th>
<th>O</th>
<th>R</th>
<th>G</th>
<th>E</th>
<th>T</th>
</tr>
</thead>
<tbody>
<tr>
<td>Frequence</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td>7</td>
</tr>
<tr>
<td>Code</td>
<td>000</td>
<td>001</td>
<td>100</td>
<td>101</td>
<td>01</td>
<td>11</td>
</tr>
</tbody>
</table>
<p>則對各符號進行霍夫曼編碼的動態示例如下圖所示。基本步驟是將出現頻率由小到大排列，組成子樹後頻率相加作為整體再和其他未加入二元樹中的節點頻率比較。加權路徑長為節點的頻率乘以樹的深度。</p>
<p><img src="../../shared-files/images/huffman_algorithm.gif" alt="Huffman"></p>
<p>有關霍夫曼編碼的具體步驟可參考 <a href="http://coolshell.cn/articles/7459.html">Huffman 編碼壓縮算法 | 酷 殼 - CoolShell.cn</a> 和 <a href="http://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81">霍夫曼編碼 - 維基百科，自由的百科全書</a>，清晰易懂。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Huffman Compression - 霍夫曼壓縮</h1>
<p>主要思想：放棄文本文件的普通保存方式：不再使用7位或8位二進制數表示每一個字符，而是<strong>用較少的比特表示出現頻率最高的字符，用較多的比特表示出現頻率低的字符</strong>。</p>
<p>使用變動長度編碼(variable-length code)來表示字串，勢必會導致編解碼時碼字的唯一性問題，因此需要一種編解碼方式唯一的前綴碼(prefix code)，而表示前綴碼的一種簡單方式就是使用單詞搜尋樹，其中最優前綴碼即為Huffman首創。</p>
<p>以符號F, O, R, G, E, T為例，其出現的頻次如以下表格所示。</p>
<table>
<thead>
<tr>
<th>Symbol</th>
<th>F</th>
<th>O</th>
<th>R</th>
<th>G</th>
<th>E</th>
<th>T</th>
</tr>
</thead>
<tbody>
<tr>
<td>Frequence</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td>7</td>
</tr>
<tr>
<td>Code</td>
<td>000</td>
<td>001</td>
<td>100</td>
<td>101</td>
<td>01</td>
<td>11</td>
</tr>
</tbody>
</table>
<p>則對各符號進行霍夫曼編碼的動態示例如下圖所示。基本步驟是將出現頻率由小到大排列，組成子樹後頻率相加作為整體再和其他未加入二元樹中的節點頻率比較。加權路徑長為節點的頻率乘以樹的深度。</p>
<p><img src="../../shared-files/images/huffman_algorithm.gif" alt="Huffman"></p>
<p>有關霍夫曼編碼的具體步驟可參考 <a href="http://coolshell.cn/articles/7459.html">Huffman 編碼壓縮算法 | 酷 殼 - CoolShell.cn</a> 和 <a href="http://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81">霍夫曼編碼 - 維基百科，自由的百科全書</a>，清晰易懂。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Queue]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_data_structure/queue.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_data_structure/queue.html">
        </link>
        <updated>2019-11-03T15:41:59Z</updated>
        <summary type="html"><![CDATA[<h1>Queue - 隊列</h1>
<!-- toc -->
<ul>
<li><a href="#程式碼實現">程式碼實現</a><ul>
<li><a href="#python">Python</a><ul>
<li><a href="#methods">Methods</a></li>
</ul>
</li>
<li><a href="#java">Java</a><ul>
<li><a href="#methods-1">Methods</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#priority-queue---優先隊列">Priority Queue - 優先隊列</a><ul>
<li><a href="#python-1">Python</a></li>
<li><a href="#java-1">Java</a></li>
</ul>
</li>
<li><a href="#deque---雙端隊列">Deque - 雙端隊列</a><ul>
<li><a href="#python-2">Python</a><ul>
<li><a href="#methods-2">Methods</a></li>
</ul>
</li>
<li><a href="#java-2">Java</a><ul>
<li><a href="#methods-3">Methods</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<p>Queue 是一個 FIFO（First-in First-out, 先進先出）的資料結構，併發(concurrent)中經常使用，可以安全地將對象從一個任務傳給另一個任務。</p>
<h2>程式碼實現</h2>
<h3>Python</h3>
<p>Queue 和 Stack 在 Python 中都是用 <code>list</code> ,<code>[]</code> 實現的。 在python 中list是一個dynamic array, 可以通過<code>append</code>在list的尾部添加元素， 通過<code>pop()</code>在list的尾部彈出元素實現<code>Stack</code>的<code>FILO</code>， 如果是<code>pop(0)</code>則彈出頭部的元素實現<code>Queue</code>的<code>FIFO</code>。</p>
<pre><code class="lang-python">queue = []  # same as list()
size = len(queue)
queue.append(1)
queue.append(2)
queue.pop(0) # return 1
queue[0] # return 2 examine the first element
</code></pre>
<h4>Methods</h4>
<table>
<thead>
<tr>
<th>\</th>
<th>methods</th>
</tr>
</thead>
<tbody>
<tr>
<td>Insert</td>
<td>queue.append(e)</td>
</tr>
<tr>
<td>Remove</td>
<td>queue.pop(0)</td>
</tr>
<tr>
<td>Examine</td>
<td>queue[0]</td>
</tr>
</tbody>
</table>
<h3>Java</h3>
<p>Queue 在 Java 中是 Interface, 一種實現是 LinkedList, LinkedList 向上轉型為 Queue, Queue 通常不能存儲 <code>null</code> 元素，否則與 <code>poll()</code> 等方法的返回值混淆。</p>
<pre><code class="lang-java">Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;();
int qLen = q.size(); // get queue length
</code></pre>
<h4>Methods</h4>
<table>
<thead>
<tr>
<th>0:0</th>
<th>Throws exception</th>
<th>Returns special value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Insert</td>
<td>add(e)</td>
<td>offer(e)</td>
</tr>
<tr>
<td>Remove</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>Examine</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody>
</table>
<p>優先考慮右側方法，右側元素不存在時返回 <code>null</code>. 判斷非空時使用<code>isEmpty()</code>方法，繼承自 Collection.</p>
<h2>Priority Queue - 優先隊列</h2>
<p>應用程式常常需要處理帶有優先級的業務，優先級最高的業務首先得到服務。因此優先隊列這種資料結構應運而生。優先隊列中的每個元素都有各自的優先級，優先級最高的元素最先得到服務；優先級相同的元素按照其在優先隊列中的順序得到服務。</p>
<p>優先隊列可以使用陣列或鏈表實現，從時間和空間覆雜度來說，往往用二叉堆(Binary heap)來實現。</p>
<h3>Python</h3>
<p>Python 中提供<code>heapq</code>的lib來實現 priority queue. 提供<code>push</code>和<code>pop</code>兩個基本操作和<code>heapify</code>初始化操作.</p>
<table>
<thead>
<tr>
<th>\</th>
<th>methods</th>
<th>time complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td>enqueue</td>
<td>heapq.push(queue, e)</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>dequeue</td>
<td>heapq.pop(queue)</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>init</td>
<td>heapq.heapify(queue)</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>peek</td>
<td>queue[0]</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<h3>Java</h3>
<p>Java 中提供<code>PriorityQueue</code>類，該類是 Interface Queue 的另外一種實現，和<code>LinkedList</code>的區別主要在於排序行為而不是性能，基於 priority heap 實現，非<code>synchronized</code>，故多執行緒(Multi-thread)下應使用<code>PriorityBlockingQueue</code>. 預設為自然序（小根堆），需要其他排序方式可自行實現<code>Comparator</code>接口，選用合適的構造器初始化。使用叠代器遍歷時不保證有序，有序訪問時需要使用<code>Arrays.sort(pq.toArray())</code>.</p>
<p>不同方法的時間覆雜度：</p>
<ul>
<li>enqueuing and dequeuing: <code>offer</code>, <code>poll</code>, <code>remove()</code> and <code>add</code> - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></li>
<li>Object: <code>remove(Object)</code> and <code>contains(Object)</code> - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></li>
<li>retrieval: <code>peek</code>, <code>element</code>, and <code>size</code> - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</li>
</ul>
<h2>Deque - 雙端隊列</h2>
<p>雙端隊列（deque，全名double-ended queue）可以讓你在任何一端添加或者移除元素，因此它是一種具有隊列和堆疊性質的資料結構。</p>
<h3>Python</h3>
<p>Python 的<code>list</code>就可以執行類似於<code>deque</code>的操作， 但是效率會過於慢。 為了提升數據的處理效率， 一些高效的資料結構放在了<code>collections</code>中。 在<code>collections</code> 中提供了<code>deque</code>的類， 如果需要多次對<code>list</code>執行頭尾元素的操作， 請使用<code>deque</code>。</p>
<pre><code class="lang-python">dq = collections.deque();
</code></pre>
<h4>Methods</h4>
<table>
<thead>
<tr>
<th>\</th>
<th>methods</th>
<th>time complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td>enqueue left</td>
<td>dq.appendleft(e)</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>enqueue right</td>
<td>dq.append(e)</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>dequeue left</td>
<td>dq.popleft()</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>dequeue right</td>
<td>dq.pop()</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>peek left</td>
<td>dq[0]</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>peek right</td>
<td>dq[-1]</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<h3>Java</h3>
<p>Java 在1.6之後提供了 Deque 介面，既可使用<code>ArrayDeque</code>（陣列）來實現，也可以使用<code>LinkedList</code>（鏈表）來實現。前者是一個數組外加首尾索引，後者是雙向鏈表。</p>
<pre><code class="lang-java">Deque&lt;Integer&gt; deque = new ArrayDeque&lt;Integer&gt;();
</code></pre>
<h4>Methods</h4>
<table>
  <tr>
    <td></td>
    <td colspan="2">First Element (Head)</td>
    <td colspan="2">Last Element (Tail)</td>
  </tr>
  <tr>
    <td></td>
    <td>Throws exception</td>
    <td>Special value</td>
    <td>Throws exception</td>
    <td>Special value</td>
  </tr>
  <tr>
    <td>Insert</td>
    <td>`addFirst(e)`</td>
    <td>`offerFirst(e)`</td>
    <td>`addLast(e)`</td>
    <td>`offerLast(e)`</td>
  </tr>
  <tr>
    <td>Remove</td>
    <td>`removeFirst()`</td>
    <td>`pollFirst()`</td>
    <td>`removeLast()`</td>
    <td>`pollLast()`</td>
  </tr>
  <tr>
    <td>Examine</td>
    <td>`getFirst()`</td>
    <td>`peekFirst()`</td>
    <td>`getLast()`</td>
    <td>`peekLast()`</td>
  </tr>
</table>

<p>其中<code>offerLast</code>和 Queue 中的<code>offer</code>功能相同，都是從尾部插入。</p>
<h2>Reference</h2>
<ul>
<li><a href="http://zh.wikipedia.org/zh/%E5%84%AA%E5%85%88%E4%BD%87%E5%88%97">優先隊列 - 維基百科，自由的百科全書</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97">雙端隊列 - 維基百科，自由的百科全書</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Queue - 隊列</h1>
<!-- toc -->
<ul>
<li><a href="#程式碼實現">程式碼實現</a><ul>
<li><a href="#python">Python</a><ul>
<li><a href="#methods">Methods</a></li>
</ul>
</li>
<li><a href="#java">Java</a><ul>
<li><a href="#methods-1">Methods</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#priority-queue---優先隊列">Priority Queue - 優先隊列</a><ul>
<li><a href="#python-1">Python</a></li>
<li><a href="#java-1">Java</a></li>
</ul>
</li>
<li><a href="#deque---雙端隊列">Deque - 雙端隊列</a><ul>
<li><a href="#python-2">Python</a><ul>
<li><a href="#methods-2">Methods</a></li>
</ul>
</li>
<li><a href="#java-2">Java</a><ul>
<li><a href="#methods-3">Methods</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<p>Queue 是一個 FIFO（First-in First-out, 先進先出）的資料結構，併發(concurrent)中經常使用，可以安全地將對象從一個任務傳給另一個任務。</p>
<h2>程式碼實現</h2>
<h3>Python</h3>
<p>Queue 和 Stack 在 Python 中都是用 <code>list</code> ,<code>[]</code> 實現的。 在python 中list是一個dynamic array, 可以通過<code>append</code>在list的尾部添加元素， 通過<code>pop()</code>在list的尾部彈出元素實現<code>Stack</code>的<code>FILO</code>， 如果是<code>pop(0)</code>則彈出頭部的元素實現<code>Queue</code>的<code>FIFO</code>。</p>
<pre><code class="lang-python">queue = []  # same as list()
size = len(queue)
queue.append(1)
queue.append(2)
queue.pop(0) # return 1
queue[0] # return 2 examine the first element
</code></pre>
<h4>Methods</h4>
<table>
<thead>
<tr>
<th>\</th>
<th>methods</th>
</tr>
</thead>
<tbody>
<tr>
<td>Insert</td>
<td>queue.append(e)</td>
</tr>
<tr>
<td>Remove</td>
<td>queue.pop(0)</td>
</tr>
<tr>
<td>Examine</td>
<td>queue[0]</td>
</tr>
</tbody>
</table>
<h3>Java</h3>
<p>Queue 在 Java 中是 Interface, 一種實現是 LinkedList, LinkedList 向上轉型為 Queue, Queue 通常不能存儲 <code>null</code> 元素，否則與 <code>poll()</code> 等方法的返回值混淆。</p>
<pre><code class="lang-java">Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;();
int qLen = q.size(); // get queue length
</code></pre>
<h4>Methods</h4>
<table>
<thead>
<tr>
<th>0:0</th>
<th>Throws exception</th>
<th>Returns special value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Insert</td>
<td>add(e)</td>
<td>offer(e)</td>
</tr>
<tr>
<td>Remove</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>Examine</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody>
</table>
<p>優先考慮右側方法，右側元素不存在時返回 <code>null</code>. 判斷非空時使用<code>isEmpty()</code>方法，繼承自 Collection.</p>
<h2>Priority Queue - 優先隊列</h2>
<p>應用程式常常需要處理帶有優先級的業務，優先級最高的業務首先得到服務。因此優先隊列這種資料結構應運而生。優先隊列中的每個元素都有各自的優先級，優先級最高的元素最先得到服務；優先級相同的元素按照其在優先隊列中的順序得到服務。</p>
<p>優先隊列可以使用陣列或鏈表實現，從時間和空間覆雜度來說，往往用二叉堆(Binary heap)來實現。</p>
<h3>Python</h3>
<p>Python 中提供<code>heapq</code>的lib來實現 priority queue. 提供<code>push</code>和<code>pop</code>兩個基本操作和<code>heapify</code>初始化操作.</p>
<table>
<thead>
<tr>
<th>\</th>
<th>methods</th>
<th>time complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td>enqueue</td>
<td>heapq.push(queue, e)</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>dequeue</td>
<td>heapq.pop(queue)</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>init</td>
<td>heapq.heapify(queue)</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>peek</td>
<td>queue[0]</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<h3>Java</h3>
<p>Java 中提供<code>PriorityQueue</code>類，該類是 Interface Queue 的另外一種實現，和<code>LinkedList</code>的區別主要在於排序行為而不是性能，基於 priority heap 實現，非<code>synchronized</code>，故多執行緒(Multi-thread)下應使用<code>PriorityBlockingQueue</code>. 預設為自然序（小根堆），需要其他排序方式可自行實現<code>Comparator</code>接口，選用合適的構造器初始化。使用叠代器遍歷時不保證有序，有序訪問時需要使用<code>Arrays.sort(pq.toArray())</code>.</p>
<p>不同方法的時間覆雜度：</p>
<ul>
<li>enqueuing and dequeuing: <code>offer</code>, <code>poll</code>, <code>remove()</code> and <code>add</code> - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></li>
<li>Object: <code>remove(Object)</code> and <code>contains(Object)</code> - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></li>
<li>retrieval: <code>peek</code>, <code>element</code>, and <code>size</code> - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</li>
</ul>
<h2>Deque - 雙端隊列</h2>
<p>雙端隊列（deque，全名double-ended queue）可以讓你在任何一端添加或者移除元素，因此它是一種具有隊列和堆疊性質的資料結構。</p>
<h3>Python</h3>
<p>Python 的<code>list</code>就可以執行類似於<code>deque</code>的操作， 但是效率會過於慢。 為了提升數據的處理效率， 一些高效的資料結構放在了<code>collections</code>中。 在<code>collections</code> 中提供了<code>deque</code>的類， 如果需要多次對<code>list</code>執行頭尾元素的操作， 請使用<code>deque</code>。</p>
<pre><code class="lang-python">dq = collections.deque();
</code></pre>
<h4>Methods</h4>
<table>
<thead>
<tr>
<th>\</th>
<th>methods</th>
<th>time complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td>enqueue left</td>
<td>dq.appendleft(e)</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>enqueue right</td>
<td>dq.append(e)</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>dequeue left</td>
<td>dq.popleft()</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>dequeue right</td>
<td>dq.pop()</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>peek left</td>
<td>dq[0]</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>peek right</td>
<td>dq[-1]</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<h3>Java</h3>
<p>Java 在1.6之後提供了 Deque 介面，既可使用<code>ArrayDeque</code>（陣列）來實現，也可以使用<code>LinkedList</code>（鏈表）來實現。前者是一個數組外加首尾索引，後者是雙向鏈表。</p>
<pre><code class="lang-java">Deque&lt;Integer&gt; deque = new ArrayDeque&lt;Integer&gt;();
</code></pre>
<h4>Methods</h4>
<table>
  <tr>
    <td></td>
    <td colspan="2">First Element (Head)</td>
    <td colspan="2">Last Element (Tail)</td>
  </tr>
  <tr>
    <td></td>
    <td>Throws exception</td>
    <td>Special value</td>
    <td>Throws exception</td>
    <td>Special value</td>
  </tr>
  <tr>
    <td>Insert</td>
    <td>`addFirst(e)`</td>
    <td>`offerFirst(e)`</td>
    <td>`addLast(e)`</td>
    <td>`offerLast(e)`</td>
  </tr>
  <tr>
    <td>Remove</td>
    <td>`removeFirst()`</td>
    <td>`pollFirst()`</td>
    <td>`removeLast()`</td>
    <td>`pollLast()`</td>
  </tr>
  <tr>
    <td>Examine</td>
    <td>`getFirst()`</td>
    <td>`peekFirst()`</td>
    <td>`getLast()`</td>
    <td>`peekLast()`</td>
  </tr>
</table>

<p>其中<code>offerLast</code>和 Queue 中的<code>offer</code>功能相同，都是從尾部插入。</p>
<h2>Reference</h2>
<ul>
<li><a href="http://zh.wikipedia.org/zh/%E5%84%AA%E5%85%88%E4%BD%87%E5%88%97">優先隊列 - 維基百科，自由的百科全書</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97">雙端隊列 - 維基百科，自由的百科全書</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Heap]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_data_structure/heap.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_data_structure/heap.html">
        </link>
        <updated>2019-11-03T15:41:59Z</updated>
        <summary type="html"><![CDATA[<h1>Heap - 堆</h1>
<!-- toc -->
<ul>
<li><a href="#特點">特點</a></li>
<li><a href="#堆的基本操作">堆的基本操作</a></li>
<li><a href="#python">Python</a></li>
</ul>
<!-- tocstop -->
<p>一般情況下，堆通常指的是<strong>二叉堆</strong>，<strong>二叉堆</strong>是一個近似<strong>完全二元樹</strong>的數據結構，<strong>即披著二元樹羊皮的陣列，</strong>故使用陣列來實現較為便利。子結點的鍵值(key)或索引總是小於（或者大於）它的父節點，且每個節點的左右子樹又是一個<strong>二叉堆</strong>(大根堆(Max Heap)或者小根堆(Min Heap))。根節點最大的堆叫做最大堆或大根堆，根節點最小的堆叫做最小堆或小根堆。<strong>常被用作實現優先隊列(Priority Queue)。</strong></p>
<h2>特點</h2>
<ol>
<li><strong>以陣列表示，但是以完全二元樹的方式理解</strong>。</li>
<li>唯一能夠同時最優地利用空間和時間的方法——最壞情況下也能保證使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>N</mi><mi>log</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">2N \log N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span> 次比較和恒定的額外空間。</li>
<li>在索引從0開始的陣列中：<ul>
<li>父節點 <code>i</code> 的左子節點在位置<code>(2*i+1)</code></li>
<li>父節點 <code>i</code> 的右子節點在位置<code>(2*i+2)</code></li>
<li>子節點 <code>i</code> 的父節點在位置<code>floor((i-1)/2)</code></li>
</ul>
</li>
</ol>
<h2>堆的基本操作</h2>
<p>以大根堆為例，堆的常用操作如下。</p>
<ol>
<li>最大堆調整（Max_Heapify）：將堆的末端子節點作調整，使得子節點永遠小於父節點</li>
<li>創建最大堆（Build_Max_Heap）：將堆所有數據重新排序</li>
<li>堆排序（HeapSort）：移除位在第一個數據的根節點，並做最大堆調整的遞迴運算</li>
</ol>
<p>其中步驟1是給步驟2和3用的。</p>
<p><img src="../../shared-files/images/Heapsort-example.gif" alt="Heapsort-example"></p>
<h2>Python</h2>
<pre><code class="lang-python">class MaxHeap:
    def __init__(self, array=None):
        if array:
            self.heap = self._max_heapify(array)
        else:
            self.heap = []

    def _sink(self, array, i):
        # move node down the tree
        left, right = 2 * i + 1, 2 * i + 2
        max_index = i
        if left &lt; len(array) and array[left] &gt; array[max_index]:
            max_index = left
        if right &lt; len(array) and array[right] &gt; array[max_index]:
            max_index = right
        if max_index != i:
            array[i], array[max_index] = array[max_index], array[i]
            self._sink(array, max_index)

    def _swim(self, array, i):
        # move node up the tree
        if i == 0:
            return
        father = (i - 1) / 2
        if array[father] &lt; array[i]:
            array[father], array[i] = array[i], array[father]
            self._swim(array, father)

    def _max_heapify(self, array):
        for i in xrange(len(array) / 2, -1, -1):
            self._sink(array, i)
        return array

    def push(self, item):
        self.heap.append(item)
        self._swim(self.heap, len(self.heap) - 1)

    def pop(self):
        self.heap[0], self.heap[-1] = self.heap[-1], self.heap[0]
        item = self.heap.pop()
        self._sink(self.heap, 0)
        return item
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1>Heap - 堆</h1>
<!-- toc -->
<ul>
<li><a href="#特點">特點</a></li>
<li><a href="#堆的基本操作">堆的基本操作</a></li>
<li><a href="#python">Python</a></li>
</ul>
<!-- tocstop -->
<p>一般情況下，堆通常指的是<strong>二叉堆</strong>，<strong>二叉堆</strong>是一個近似<strong>完全二元樹</strong>的數據結構，<strong>即披著二元樹羊皮的陣列，</strong>故使用陣列來實現較為便利。子結點的鍵值(key)或索引總是小於（或者大於）它的父節點，且每個節點的左右子樹又是一個<strong>二叉堆</strong>(大根堆(Max Heap)或者小根堆(Min Heap))。根節點最大的堆叫做最大堆或大根堆，根節點最小的堆叫做最小堆或小根堆。<strong>常被用作實現優先隊列(Priority Queue)。</strong></p>
<h2>特點</h2>
<ol>
<li><strong>以陣列表示，但是以完全二元樹的方式理解</strong>。</li>
<li>唯一能夠同時最優地利用空間和時間的方法——最壞情況下也能保證使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>N</mi><mi>log</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">2N \log N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span> 次比較和恒定的額外空間。</li>
<li>在索引從0開始的陣列中：<ul>
<li>父節點 <code>i</code> 的左子節點在位置<code>(2*i+1)</code></li>
<li>父節點 <code>i</code> 的右子節點在位置<code>(2*i+2)</code></li>
<li>子節點 <code>i</code> 的父節點在位置<code>floor((i-1)/2)</code></li>
</ul>
</li>
</ol>
<h2>堆的基本操作</h2>
<p>以大根堆為例，堆的常用操作如下。</p>
<ol>
<li>最大堆調整（Max_Heapify）：將堆的末端子節點作調整，使得子節點永遠小於父節點</li>
<li>創建最大堆（Build_Max_Heap）：將堆所有數據重新排序</li>
<li>堆排序（HeapSort）：移除位在第一個數據的根節點，並做最大堆調整的遞迴運算</li>
</ol>
<p>其中步驟1是給步驟2和3用的。</p>
<p><img src="../../shared-files/images/Heapsort-example.gif" alt="Heapsort-example"></p>
<h2>Python</h2>
<pre><code class="lang-python">class MaxHeap:
    def __init__(self, array=None):
        if array:
            self.heap = self._max_heapify(array)
        else:
            self.heap = []

    def _sink(self, array, i):
        # move node down the tree
        left, right = 2 * i + 1, 2 * i + 2
        max_index = i
        if left &lt; len(array) and array[left] &gt; array[max_index]:
            max_index = left
        if right &lt; len(array) and array[right] &gt; array[max_index]:
            max_index = right
        if max_index != i:
            array[i], array[max_index] = array[max_index], array[i]
            self._sink(array, max_index)

    def _swim(self, array, i):
        # move node up the tree
        if i == 0:
            return
        father = (i - 1) / 2
        if array[father] &lt; array[i]:
            array[father], array[i] = array[i], array[father]
            self._swim(array, father)

    def _max_heapify(self, array):
        for i in xrange(len(array) / 2, -1, -1):
            self._sink(array, i)
        return array

    def push(self, item):
        self.heap.append(item)
        self._swim(self.heap, len(self.heap) - 1)

    def pop(self):
        self.heap[0], self.heap[-1] = self.heap[-1], self.heap[0]
        item = self.heap.pop()
        self._sink(self.heap, 0)
        return item
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Stack]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_data_structure/stack.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_data_structure/stack.html">
        </link>
        <updated>2019-11-03T15:41:59Z</updated>
        <summary type="html"><![CDATA[<h1>Stack - 堆疊</h1>
<!-- toc -->
<ul>
<li><a href="#程式碼實現">程式碼實現</a><ul>
<li><a href="#python">Python</a><ul>
<li><a href="#methods">Methods</a></li>
</ul>
</li>
<li><a href="#java">Java</a><ul>
<li><a href="#methods-1">Methods</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>堆疊是一種 LIFO(Last In First Out) 的資料結構，常用方法有添加元素，讀Stack頂元素，彈出(pop) Stack頂元素，判斷堆疊是否為空。</p>
<h2>程式碼實現</h2>
<h3>Python</h3>
<pre><code class="lang-python">stack = []
len(stack) # size of stack

# more efficient stack
import collections
stack = collections.deque()
</code></pre>
<p><code>list</code>作為最基本的<code>python</code>資料結構之一， 可以很輕鬆地實現<code>stack</code>。 如果需要更高效的<code>stack</code>， 建議使用<code>deque</code>。</p>
<h4>Methods</h4>
<ul>
<li><code>len(stack) != 0</code> - 判斷<code>stack</code>是否為空</li>
<li><code>stack[-1]</code> - 取堆疊頂元素，不移除</li>
<li><code>pop()</code> - 移除堆疊頂元素並返回該元素</li>
<li><code>append(item)</code> - 向堆疊頂添加元素</li>
</ul>
<h3>Java</h3>
<pre><code class="lang-java">Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();
s.size(); // size of stack
</code></pre>
<p>JDK doc 中建議使用<code>Deque</code>代替<code>Stack</code>實現堆疊，因為<code>Stack</code>繼承自<code>Vector</code>，需要<code>synchronized</code>，性能略低。</p>
<h4>Methods</h4>
<ul>
<li><code>boolean    isEmpty()</code> - 判斷堆疊是否為空，若使用 Stack 類構造則為 empty()</li>
<li><code>E peek()</code> - 取堆疊頂元素，不移除</li>
<li><code>E pop()</code> - 移除堆疊頂元素並返回該元素</li>
<li><code>E push(E item)</code> - 向堆疊頂添加元素</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Stack - 堆疊</h1>
<!-- toc -->
<ul>
<li><a href="#程式碼實現">程式碼實現</a><ul>
<li><a href="#python">Python</a><ul>
<li><a href="#methods">Methods</a></li>
</ul>
</li>
<li><a href="#java">Java</a><ul>
<li><a href="#methods-1">Methods</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>堆疊是一種 LIFO(Last In First Out) 的資料結構，常用方法有添加元素，讀Stack頂元素，彈出(pop) Stack頂元素，判斷堆疊是否為空。</p>
<h2>程式碼實現</h2>
<h3>Python</h3>
<pre><code class="lang-python">stack = []
len(stack) # size of stack

# more efficient stack
import collections
stack = collections.deque()
</code></pre>
<p><code>list</code>作為最基本的<code>python</code>資料結構之一， 可以很輕鬆地實現<code>stack</code>。 如果需要更高效的<code>stack</code>， 建議使用<code>deque</code>。</p>
<h4>Methods</h4>
<ul>
<li><code>len(stack) != 0</code> - 判斷<code>stack</code>是否為空</li>
<li><code>stack[-1]</code> - 取堆疊頂元素，不移除</li>
<li><code>pop()</code> - 移除堆疊頂元素並返回該元素</li>
<li><code>append(item)</code> - 向堆疊頂添加元素</li>
</ul>
<h3>Java</h3>
<pre><code class="lang-java">Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();
s.size(); // size of stack
</code></pre>
<p>JDK doc 中建議使用<code>Deque</code>代替<code>Stack</code>實現堆疊，因為<code>Stack</code>繼承自<code>Vector</code>，需要<code>synchronized</code>，性能略低。</p>
<h4>Methods</h4>
<ul>
<li><code>boolean    isEmpty()</code> - 判斷堆疊是否為空，若使用 Stack 類構造則為 empty()</li>
<li><code>E peek()</code> - 取堆疊頂元素，不移除</li>
<li><code>E pop()</code> - 移除堆疊頂元素並返回該元素</li>
<li><code>E push(E item)</code> - 向堆疊頂添加元素</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Set]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_data_structure/set.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_data_structure/set.html">
        </link>
        <updated>2019-11-03T15:41:59Z</updated>
        <summary type="html"><![CDATA[<h1>Set</h1>
<!-- toc -->
<ul>
<li><a href="#程式實現">程式實現</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>Set 是一種用於保存不重複元素的資料結構。常被用作測試歸屬性，故其查找的性能十分重要。</p>
<h2>程式實現</h2>
<h3>Python</h3>
<p><code>Set</code> 是<code>python</code>自帶的基本資料結構， 有多種初始化方式。 <code>Python</code>的<code>set</code>跟<code>dict</code>的Implementation方式類似， 可以認爲<code>set</code>是只有<code>key</code>的<code>dict</code>.</p>
<pre><code class="lang-python">s = set()
s1 = {1, 2, 3}
s.add(&#39;shaunwei&#39;)
&#39;shaun&#39; in s  # return true
s.remove(&#39;shaunwei&#39;)
</code></pre>
<h3>C++</h3>
<p>STL提供的資料結構有 Set 以及 Multiset ，分別提供不重複與重複元素的版本，自C++11以後，STL提供兩種 Set 的實現方式，一個是基於紅-黑樹的<code>set</code>與<code>multiset</code>，包含在<code>&lt;set&gt;</code>標頭檔之中，有序。另一個則是基於湊雜函數的<code>unordered_set</code>及<code>unordered_multiset</code>，包含在標頭檔<code>&lt;unordered_set&gt;</code>，無序。基本的 Set 使用如下所示</p>
<pre><code class="lang-C++">set&lt;string&gt; s;
s.insert(&quot;crossluna&quot;);
s.insert(&quot;billryan&quot;);
auto it = s.find(&quot;lucifer&quot;);
if(it != s.end()) {
    // &quot;lucifer&quot; found
}
</code></pre>
<p>另外可以藉由在建構時傳遞自訂的 Functor 、 Hash Function 以達成更彈性的使用，詳細用法及更多的介面請參考 STL 使用文檔。</p>
<h3>Java</h3>
<p>Set 與 Collection 具有安全一樣的接口，通常有<code>HashSet</code>, <code>TreeSet</code> 或 <code>LinkedHashSet</code>三種實現。<code>HashSet</code>基於湊雜函數實現，無序，查詢速度最快；<code>TreeSet</code>基於紅-黑樹實現，有序。</p>
<pre><code class="lang-java">Set&lt;String&gt; hash = new HashSet&lt;String&gt;();
hash.add(&quot;billryan&quot;);
hash.contains(&quot;billryan&quot;);
</code></pre>
<p>在不允許重複元素時可當做哈希表來用。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Set</h1>
<!-- toc -->
<ul>
<li><a href="#程式實現">程式實現</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>Set 是一種用於保存不重複元素的資料結構。常被用作測試歸屬性，故其查找的性能十分重要。</p>
<h2>程式實現</h2>
<h3>Python</h3>
<p><code>Set</code> 是<code>python</code>自帶的基本資料結構， 有多種初始化方式。 <code>Python</code>的<code>set</code>跟<code>dict</code>的Implementation方式類似， 可以認爲<code>set</code>是只有<code>key</code>的<code>dict</code>.</p>
<pre><code class="lang-python">s = set()
s1 = {1, 2, 3}
s.add(&#39;shaunwei&#39;)
&#39;shaun&#39; in s  # return true
s.remove(&#39;shaunwei&#39;)
</code></pre>
<h3>C++</h3>
<p>STL提供的資料結構有 Set 以及 Multiset ，分別提供不重複與重複元素的版本，自C++11以後，STL提供兩種 Set 的實現方式，一個是基於紅-黑樹的<code>set</code>與<code>multiset</code>，包含在<code>&lt;set&gt;</code>標頭檔之中，有序。另一個則是基於湊雜函數的<code>unordered_set</code>及<code>unordered_multiset</code>，包含在標頭檔<code>&lt;unordered_set&gt;</code>，無序。基本的 Set 使用如下所示</p>
<pre><code class="lang-C++">set&lt;string&gt; s;
s.insert(&quot;crossluna&quot;);
s.insert(&quot;billryan&quot;);
auto it = s.find(&quot;lucifer&quot;);
if(it != s.end()) {
    // &quot;lucifer&quot; found
}
</code></pre>
<p>另外可以藉由在建構時傳遞自訂的 Functor 、 Hash Function 以達成更彈性的使用，詳細用法及更多的介面請參考 STL 使用文檔。</p>
<h3>Java</h3>
<p>Set 與 Collection 具有安全一樣的接口，通常有<code>HashSet</code>, <code>TreeSet</code> 或 <code>LinkedHashSet</code>三種實現。<code>HashSet</code>基於湊雜函數實現，無序，查詢速度最快；<code>TreeSet</code>基於紅-黑樹實現，有序。</p>
<pre><code class="lang-java">Set&lt;String&gt; hash = new HashSet&lt;String&gt;();
hash.add(&quot;billryan&quot;);
hash.contains(&quot;billryan&quot;);
</code></pre>
<p>在不允許重複元素時可當做哈希表來用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Map]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_data_structure/map.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_data_structure/map.html">
        </link>
        <updated>2019-11-03T15:41:59Z</updated>
        <summary type="html"><![CDATA[<h1>Map - 關聯容器</h1>
<!-- toc -->
<ul>
<li><a href="#程式實現">程式實現</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>Map 是一種關聯數組的資料結構，也常被稱爲字典(dictionary)或鍵值對(key-value pair)。</p>
<h2>程式實現</h2>
<h3>Python</h3>
<p>在 Python 中 <code>dict</code>(Map) 是一種基本的資料結構。</p>
<pre><code class="lang-python"># map 在 python 中是一個keyword
hash_map = {} # or dict()
hash_map[&#39;shaun&#39;] = 98
hash_map[&#39;wei&#39;] = 99
exist = &#39;wei&#39; in hash_map  # check existence
point = hash_map[&#39;shaun&#39;]  # get value by key
point = hash_map.pop(&#39;shaun&#39;) # remove by key, return value
keys = hash_map.keys()  # return key list
# iterate dictionary(map)
for key, value in hash_map.items():
    # do something with k, v
    pass
</code></pre>
<h3>C++</h3>
<p>與 Set 類似，STL提供了 Map 與 Multimap 兩種，提供同一鍵(key)對應單個或多個值(value)，自C++11以後，一樣提供兩種實現方式，基於紅-黑樹的<code>map</code>與<code>multimap</code>，包含在<code>&lt;map&gt;</code>標頭檔之中，鍵有序。另一個則是基於湊雜函數的<code>unordered_map</code>及<code>unordered_multimap</code>包含在標頭檔<code>&lt;unordered_map&gt;</code>，鍵無序。基本的 Map 使用如下所示</p>
<pre><code class="lang-C++">map&lt;string, int&gt; mp;
mp [&quot;billryan&quot;] = 69;
mp [&quot;crossluna&quot;] = 159;
auto it = mp.find(&quot;billryan&quot;); 
if(it != mp.end()) {
    // &quot;billryan&quot; found
    cout &lt;&lt; mp[&quot;billryan&quot;]; // output: 69
}
</code></pre>
<p>另外可以藉由在建構時傳遞自訂的 Functor 、 Hash Function 以達成更彈性的使用，詳細用法及更多的介面請參考 STL 使用文檔。</p>
<h3>Java</h3>
<p>Java 的實現中 Map 是一種將物件與物件相關聯的設計。常用的實現有<code>HashMap</code>和<code>TreeMap</code>, <code>HashMap</code>被用來快速訪問，而<code>TreeMap</code>則保證『鍵』始終有序。Map 可以返回鍵的 Set, 值的 Collection, 鍵值對的 Set.</p>
<pre><code class="lang-java">Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
map.put(&quot;bill&quot;, 98);
map.put(&quot;ryan&quot;, 99);
boolean exist = map.containsKey(&quot;ryan&quot;); // check key exists in map
int point = map.get(&quot;bill&quot;); // get value by key
int point = map.remove(&quot;bill&quot;) // remove by key, return value
Set&lt;String&gt; set = map.keySet();
// iterate Map
for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {
    String key = entry.getKey();
    int value = entry.getValue();
    // do some thing
}
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1>Map - 關聯容器</h1>
<!-- toc -->
<ul>
<li><a href="#程式實現">程式實現</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>Map 是一種關聯數組的資料結構，也常被稱爲字典(dictionary)或鍵值對(key-value pair)。</p>
<h2>程式實現</h2>
<h3>Python</h3>
<p>在 Python 中 <code>dict</code>(Map) 是一種基本的資料結構。</p>
<pre><code class="lang-python"># map 在 python 中是一個keyword
hash_map = {} # or dict()
hash_map[&#39;shaun&#39;] = 98
hash_map[&#39;wei&#39;] = 99
exist = &#39;wei&#39; in hash_map  # check existence
point = hash_map[&#39;shaun&#39;]  # get value by key
point = hash_map.pop(&#39;shaun&#39;) # remove by key, return value
keys = hash_map.keys()  # return key list
# iterate dictionary(map)
for key, value in hash_map.items():
    # do something with k, v
    pass
</code></pre>
<h3>C++</h3>
<p>與 Set 類似，STL提供了 Map 與 Multimap 兩種，提供同一鍵(key)對應單個或多個值(value)，自C++11以後，一樣提供兩種實現方式，基於紅-黑樹的<code>map</code>與<code>multimap</code>，包含在<code>&lt;map&gt;</code>標頭檔之中，鍵有序。另一個則是基於湊雜函數的<code>unordered_map</code>及<code>unordered_multimap</code>包含在標頭檔<code>&lt;unordered_map&gt;</code>，鍵無序。基本的 Map 使用如下所示</p>
<pre><code class="lang-C++">map&lt;string, int&gt; mp;
mp [&quot;billryan&quot;] = 69;
mp [&quot;crossluna&quot;] = 159;
auto it = mp.find(&quot;billryan&quot;); 
if(it != mp.end()) {
    // &quot;billryan&quot; found
    cout &lt;&lt; mp[&quot;billryan&quot;]; // output: 69
}
</code></pre>
<p>另外可以藉由在建構時傳遞自訂的 Functor 、 Hash Function 以達成更彈性的使用，詳細用法及更多的介面請參考 STL 使用文檔。</p>
<h3>Java</h3>
<p>Java 的實現中 Map 是一種將物件與物件相關聯的設計。常用的實現有<code>HashMap</code>和<code>TreeMap</code>, <code>HashMap</code>被用來快速訪問，而<code>TreeMap</code>則保證『鍵』始終有序。Map 可以返回鍵的 Set, 值的 Collection, 鍵值對的 Set.</p>
<pre><code class="lang-java">Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
map.put(&quot;bill&quot;, 98);
map.put(&quot;ryan&quot;, 99);
boolean exist = map.containsKey(&quot;ryan&quot;); // check key exists in map
int point = map.get(&quot;bill&quot;); // get value by key
int point = map.remove(&quot;bill&quot;) // remove by key, return value
Set&lt;String&gt; set = map.keySet();
// iterate Map
for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {
    String key = entry.getKey();
    int value = entry.getValue();
    // do some thing
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Graph]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_data_structure/graph.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_data_structure/graph.html">
        </link>
        <updated>2019-11-03T15:42:00Z</updated>
        <summary type="html"><![CDATA[<h1>Graph - 圖</h1>
<!-- toc -->
<ul>
<li><a href="#程式實現">程式實現</a><ul>
<li><a href="#鄰接矩陣-adjacency-matrix">鄰接矩陣 (Adjacency Matrix)</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#c">C++</a></li>
</ul>
</li>
<li><a href="#鄰接表-adjacency-list">鄰接表 (Adjacency List)</a></li>
<li><a href="#有向圖">有向圖</a><ul>
<li><a href="#python-1">Python</a></li>
<li><a href="#java-1">Java</a></li>
<li><a href="#c-1">C++</a></li>
</ul>
</li>
<li><a href="#無向圖同上，只不過在建圖時雙向同時加。">無向圖同上，只不過在建圖時雙向同時加。</a><ul>
<li><a href="#python-2">Python</a></li>
<li><a href="#java-2">Java</a></li>
<li><a href="#c-2">C++</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>圖的表示通常使用<strong>鄰接矩陣和鄰接表</strong>，前者易實現但是對於稀疏矩陣會浪費較多空間，後者使用鏈表的方式存儲資訊但是對於圖搜索時間複雜度較高。</p>
<h2>程式實現</h2>
<h3>鄰接矩陣 (Adjacency Matrix)</h3>
<p>設頂點個數爲 V, 那麼鄰接矩陣可以使用 V × V 的二維陣列來表示。
<code>g[i][j]</code>表示頂點<code>i</code>和頂點<code>j</code>的關係，對於無向圖(undirected graph)可以使用0/1表示是否有連接，對於帶有權重的圖則需要使用<code>INF</code>來區分。有重邊時保存邊數或者權值最大/小的邊即可。</p>
<h4>Python</h4>
<pre><code class="lang-python">g = [[0 for _ in range(V)] for _ in range(V)]
</code></pre>
<h4>Java</h4>
<pre><code class="lang-java">/* Java Definition */
int[][] g = new int[V][V];
</code></pre>
<h4>C++</h4>
<pre><code class="lang-C++">vector&lt;vector&lt;int&gt;&gt; g (V, vector&lt;int&gt;(V, 0));
</code></pre>
<h3>鄰接表 (Adjacency List)</h3>
<p>鄰接表通過表示從頂點<code>i</code>出發到其他所有可能能到的邊。</p>
<h3>有向圖</h3>
<h4>Python</h4>
<pre><code class="lang-python">class DirectedGraphNode:
    def __init__(self, x):
        self.label = x
        self.neighbors = []
</code></pre>
<h4>Java</h4>
<pre><code class="lang-java">/* Java Definition */
class DirectedGraphNode {
    int label;
    ArrayList&lt;DirectedGraphNode&gt; neighbors;
    DirectedGraphNode(int x) {
        label = x;
        neighbors = new ArrayList&lt;DirectedGraphNode&gt;();
    }
}
</code></pre>
<h4>C++</h4>
<pre><code class="lang-C++">struct DirectedGraphNode {
    int label;
    vector&lt;DirectedGraphNode*&gt; neighbors;

    DirectedGraphNode(int x): label(x) { }
};
</code></pre>
<h3>無向圖同上，只不過在建圖時雙向同時加。</h3>
<h4>Python</h4>
<pre><code class="lang-python">class UndirectedGraphNode:
    def __init__(self, x):
        self.label = x
        self.neighbors = []
</code></pre>
<h4>Java</h4>
<pre><code class="lang-java">class UndirectedGraphNode {
    int label;
    ArrayList&lt;UndirectedGraphNode&gt; neighbors;
    UndirectedGraphNode(int x) {
        this.label = x;
        this.neighbors = new ArrayList&lt;UndirectedGraphNode&gt;();
    }
}
</code></pre>
<h4>C++</h4>
<pre><code class="lang-C++">struct UndirectedGraphNode {
    int label;
    vector&lt;UndirectedGraphNode*&gt; neighbors;

    UndirectedGraphNode(int x): label(x) { }
};
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1>Graph - 圖</h1>
<!-- toc -->
<ul>
<li><a href="#程式實現">程式實現</a><ul>
<li><a href="#鄰接矩陣-adjacency-matrix">鄰接矩陣 (Adjacency Matrix)</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#c">C++</a></li>
</ul>
</li>
<li><a href="#鄰接表-adjacency-list">鄰接表 (Adjacency List)</a></li>
<li><a href="#有向圖">有向圖</a><ul>
<li><a href="#python-1">Python</a></li>
<li><a href="#java-1">Java</a></li>
<li><a href="#c-1">C++</a></li>
</ul>
</li>
<li><a href="#無向圖同上，只不過在建圖時雙向同時加。">無向圖同上，只不過在建圖時雙向同時加。</a><ul>
<li><a href="#python-2">Python</a></li>
<li><a href="#java-2">Java</a></li>
<li><a href="#c-2">C++</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>圖的表示通常使用<strong>鄰接矩陣和鄰接表</strong>，前者易實現但是對於稀疏矩陣會浪費較多空間，後者使用鏈表的方式存儲資訊但是對於圖搜索時間複雜度較高。</p>
<h2>程式實現</h2>
<h3>鄰接矩陣 (Adjacency Matrix)</h3>
<p>設頂點個數爲 V, 那麼鄰接矩陣可以使用 V × V 的二維陣列來表示。
<code>g[i][j]</code>表示頂點<code>i</code>和頂點<code>j</code>的關係，對於無向圖(undirected graph)可以使用0/1表示是否有連接，對於帶有權重的圖則需要使用<code>INF</code>來區分。有重邊時保存邊數或者權值最大/小的邊即可。</p>
<h4>Python</h4>
<pre><code class="lang-python">g = [[0 for _ in range(V)] for _ in range(V)]
</code></pre>
<h4>Java</h4>
<pre><code class="lang-java">/* Java Definition */
int[][] g = new int[V][V];
</code></pre>
<h4>C++</h4>
<pre><code class="lang-C++">vector&lt;vector&lt;int&gt;&gt; g (V, vector&lt;int&gt;(V, 0));
</code></pre>
<h3>鄰接表 (Adjacency List)</h3>
<p>鄰接表通過表示從頂點<code>i</code>出發到其他所有可能能到的邊。</p>
<h3>有向圖</h3>
<h4>Python</h4>
<pre><code class="lang-python">class DirectedGraphNode:
    def __init__(self, x):
        self.label = x
        self.neighbors = []
</code></pre>
<h4>Java</h4>
<pre><code class="lang-java">/* Java Definition */
class DirectedGraphNode {
    int label;
    ArrayList&lt;DirectedGraphNode&gt; neighbors;
    DirectedGraphNode(int x) {
        label = x;
        neighbors = new ArrayList&lt;DirectedGraphNode&gt;();
    }
}
</code></pre>
<h4>C++</h4>
<pre><code class="lang-C++">struct DirectedGraphNode {
    int label;
    vector&lt;DirectedGraphNode*&gt; neighbors;

    DirectedGraphNode(int x): label(x) { }
};
</code></pre>
<h3>無向圖同上，只不過在建圖時雙向同時加。</h3>
<h4>Python</h4>
<pre><code class="lang-python">class UndirectedGraphNode:
    def __init__(self, x):
        self.label = x
        self.neighbors = []
</code></pre>
<h4>Java</h4>
<pre><code class="lang-java">class UndirectedGraphNode {
    int label;
    ArrayList&lt;UndirectedGraphNode&gt; neighbors;
    UndirectedGraphNode(int x) {
        this.label = x;
        this.neighbors = new ArrayList&lt;UndirectedGraphNode&gt;();
    }
}
</code></pre>
<h4>C++</h4>
<pre><code class="lang-C++">struct UndirectedGraphNode {
    int label;
    vector&lt;UndirectedGraphNode*&gt; neighbors;

    UndirectedGraphNode(int x): label(x) { }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Basics Sorting]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_sorting/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_sorting/">
        </link>
        <updated>2019-11-03T15:42:00Z</updated>
        <summary type="html"><![CDATA[<h1>Basics Sorting - 基礎排序演算法</h1>
<h1>演算法複習——排序</h1>
<!-- 時間限制為1s時，大O為10000000時勉強可行，100,000,000時很懸。 -->
<h2>演算法分析</h2>
<ol>
<li>時間複雜度-執行時間(比較和交換次數)</li>
<li>空間複雜度-所消耗的額外記憶體空間<ul>
<li>使用小堆疊、隊列或表</li>
<li>使用鏈表或指針、數組索引來代表數據</li>
<li>排序數據的副本</li>
</ul>
</li>
</ol>
<p>在OJ上做題時，一些經驗法則(rule of thumb)以及封底估算(back-of-the-envelop calculation)可以幫助選擇適合的演算法，一個簡單的經驗法則是</p>
<pre><code>10^9 operations per second
</code></pre><p>舉例來說，如果今天遇到一個題目，時間限制是1s，但僅有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord"><span class="mord mathrm">0</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>筆輸入數據，此時即使使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>的演算法也沒問題，但若有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord"><span class="mord mathrm">0</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">5</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>筆輸入，則<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>的演算法則非常可能超時，在實作前就要先思考是不是有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>或更快的演算法。</p>
<p>對具有重鍵的數據(同一組數按不同鍵多次排序)進行排序時，需要考慮排序方法的穩定性，在非穩定性排序演算法中需要穩定性時可考慮加入小索引。</p>
<p>穩定性：如果排序後文件中擁有相同鍵的項的相對位置不變，這種排序方式是穩定的。</p>
<p>常見的排序演算法根據是否需要比較可以分為如下幾類：</p>
<ul>
<li>Comparison Sorting<ol>
<li>Bubble Sort</li>
<li>Selection Sort</li>
<li>Insertion Sort</li>
<li>Shell Sort</li>
<li>Merge Sort</li>
<li>Quck Sort</li>
<li>Heap Sort</li>
</ol>
</li>
<li>Bucket Sort</li>
<li>Counting Sort</li>
<li>Radix Sort</li>
</ul>
<p>從穩定性角度考慮可分為如下兩類：</p>
<ul>
<li>穩定</li>
<li>非穩定</li>
</ul>
<h2>Reference</h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Sorting_algorithm">Sorting algorithm - Wikipedia, the free encyclopedia</a> - 各類排序演算法的「平均、最好、最壞時間複雜度」總結。</li>
<li><a href="http://bigocheatsheet.com/">Big-O cheatsheet</a> - 更清晰的總結</li>
<li><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/">經典排序演算法總結與實現 | Jark&#39;s Blog</a> - 基於 Python 的較為清晰的總結。</li>
<li><a href="http://blog.sina.com.cn/s/blog_eb52001d0102v1k8.html">【面經】矽谷前沿Startup面試經驗-排序演算法總結及快速排序演算法代碼_九章演算法</a> - 總結了一些常用常問的排序演算法。</li>
<li><a href="http://algo.is/">雷克雅維克大學的程式競賽課程</a>
第一講的slide中提供了演算法分析的經驗法則</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Basics Sorting - 基礎排序演算法</h1>
<h1>演算法複習——排序</h1>
<!-- 時間限制為1s時，大O為10000000時勉強可行，100,000,000時很懸。 -->
<h2>演算法分析</h2>
<ol>
<li>時間複雜度-執行時間(比較和交換次數)</li>
<li>空間複雜度-所消耗的額外記憶體空間<ul>
<li>使用小堆疊、隊列或表</li>
<li>使用鏈表或指針、數組索引來代表數據</li>
<li>排序數據的副本</li>
</ul>
</li>
</ol>
<p>在OJ上做題時，一些經驗法則(rule of thumb)以及封底估算(back-of-the-envelop calculation)可以幫助選擇適合的演算法，一個簡單的經驗法則是</p>
<pre><code>10^9 operations per second
</code></pre><p>舉例來說，如果今天遇到一個題目，時間限制是1s，但僅有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord"><span class="mord mathrm">0</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>筆輸入數據，此時即使使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>的演算法也沒問題，但若有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord"><span class="mord mathrm">0</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">5</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>筆輸入，則<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>的演算法則非常可能超時，在實作前就要先思考是不是有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>或更快的演算法。</p>
<p>對具有重鍵的數據(同一組數按不同鍵多次排序)進行排序時，需要考慮排序方法的穩定性，在非穩定性排序演算法中需要穩定性時可考慮加入小索引。</p>
<p>穩定性：如果排序後文件中擁有相同鍵的項的相對位置不變，這種排序方式是穩定的。</p>
<p>常見的排序演算法根據是否需要比較可以分為如下幾類：</p>
<ul>
<li>Comparison Sorting<ol>
<li>Bubble Sort</li>
<li>Selection Sort</li>
<li>Insertion Sort</li>
<li>Shell Sort</li>
<li>Merge Sort</li>
<li>Quck Sort</li>
<li>Heap Sort</li>
</ol>
</li>
<li>Bucket Sort</li>
<li>Counting Sort</li>
<li>Radix Sort</li>
</ul>
<p>從穩定性角度考慮可分為如下兩類：</p>
<ul>
<li>穩定</li>
<li>非穩定</li>
</ul>
<h2>Reference</h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Sorting_algorithm">Sorting algorithm - Wikipedia, the free encyclopedia</a> - 各類排序演算法的「平均、最好、最壞時間複雜度」總結。</li>
<li><a href="http://bigocheatsheet.com/">Big-O cheatsheet</a> - 更清晰的總結</li>
<li><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/">經典排序演算法總結與實現 | Jark&#39;s Blog</a> - 基於 Python 的較為清晰的總結。</li>
<li><a href="http://blog.sina.com.cn/s/blog_eb52001d0102v1k8.html">【面經】矽谷前沿Startup面試經驗-排序演算法總結及快速排序演算法代碼_九章演算法</a> - 總結了一些常用常問的排序演算法。</li>
<li><a href="http://algo.is/">雷克雅維克大學的程式競賽課程</a>
第一講的slide中提供了演算法分析的經驗法則</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bubble Sort]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_sorting/bubble_sort.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_sorting/bubble_sort.html">
        </link>
        <updated>2019-11-03T15:42:00Z</updated>
        <summary type="html"><![CDATA[<h1>Bubble Sort - 氣泡排序</h1>
<!-- toc -->
<ul>
<li><a href="#implementation">Implementation</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<p>核心：<strong>氣泡</strong>，持續比較相鄰元素，大的挪到後面，因此大的會逐步往後挪，故稱之為氣泡。</p>
<p><img src="../../shared-files/images/bubble_sort.gif" alt="Bubble Sort"></p>
<h2>Implementation</h2>
<h3>Python</h3>
<pre><code class="lang-python">#!/usr/bin/env python


def bubbleSort(alist):
    for i in xrange(len(alist)):
        print(alist)
        for j in xrange(1, len(alist) - i):
            if alist[j - 1] &gt; alist[j]:
                alist[j - 1], alist[j] = alist[j], alist[j - 1]

    return alist

unsorted_list = [6, 5, 3, 1, 8, 7, 2, 4]
print(bubbleSort(unsorted_list))
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Sort {
    public static void main(String[] args) {
        int unsortedArray[] = new int[]{6, 5, 3, 1, 8, 7, 2, 4};
        bubbleSort(unsortedArray);
        System.out.println(&quot;After sort: &quot;);
        for (int item : unsortedArray) {
            System.out.print(item + &quot; &quot;);
        }
    }

    public static void bubbleSort(int[] array) {
        int len = array.length;
        for (int i = 0; i &lt; len; i++) {
            for (int item : array) {
                System.out.print(item + &quot; &quot;);
            }
            System.out.println();
            for (int j = 1; j &lt; len - i; j++) {
                if (array[j - 1] &gt; array[j]) {
                    int temp = array[j - 1];
                    array[j - 1] = array[j];
                    array[j] = temp;
                }
            }
        }
    }
}
</code></pre>
<h3>C++</h3>
<pre><code class="lang-C++">void bubbleSort(vector&lt;int&gt; &amp; arr){
    for(int i = 0; i &lt; arr.size(); i++){
        for(int j = 1; j &lt; arr.size() - i; j++){
            if(arr[j - 1] &gt; arr[j])){
                std::swap(arr[j-1], arr[j]);
            }
        }
    }
    return arr;
}
</code></pre>
<h3>複雜度分析</h3>
<p>平均情況與最壞情況均為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>, 使用了 temp 作為臨時交換變量，空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.
可以做適當程度的優化，當某一次外迴圈中發現陣列已經有序，就跳出迴圈不再執行，但這僅對於部分的輸入有效，平均及最壞時間複雜度仍為<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span></p>
<pre><code class="lang-C++">void bubbleSort(vector&lt;int&gt; &amp; arr){
    bool unsorted = true;
    for(int i = 0; i &lt; arr.size() &amp;&amp; unsorted; i++){
        unsorted = false;
        for(int j = 1; j &lt; arr.size() - i; j++){
            if(arr[j - 1] &gt; arr[j])){
                std::swap(arr[j-1], arr[j]);
                unsorted = true;
            }
        }
    }
    return arr;
}
</code></pre>
<h2>Reference</h2>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">氣泡排序 - 維基百科，自由的百科全書</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Bubble Sort - 氣泡排序</h1>
<!-- toc -->
<ul>
<li><a href="#implementation">Implementation</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<p>核心：<strong>氣泡</strong>，持續比較相鄰元素，大的挪到後面，因此大的會逐步往後挪，故稱之為氣泡。</p>
<p><img src="../../shared-files/images/bubble_sort.gif" alt="Bubble Sort"></p>
<h2>Implementation</h2>
<h3>Python</h3>
<pre><code class="lang-python">#!/usr/bin/env python


def bubbleSort(alist):
    for i in xrange(len(alist)):
        print(alist)
        for j in xrange(1, len(alist) - i):
            if alist[j - 1] &gt; alist[j]:
                alist[j - 1], alist[j] = alist[j], alist[j - 1]

    return alist

unsorted_list = [6, 5, 3, 1, 8, 7, 2, 4]
print(bubbleSort(unsorted_list))
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Sort {
    public static void main(String[] args) {
        int unsortedArray[] = new int[]{6, 5, 3, 1, 8, 7, 2, 4};
        bubbleSort(unsortedArray);
        System.out.println(&quot;After sort: &quot;);
        for (int item : unsortedArray) {
            System.out.print(item + &quot; &quot;);
        }
    }

    public static void bubbleSort(int[] array) {
        int len = array.length;
        for (int i = 0; i &lt; len; i++) {
            for (int item : array) {
                System.out.print(item + &quot; &quot;);
            }
            System.out.println();
            for (int j = 1; j &lt; len - i; j++) {
                if (array[j - 1] &gt; array[j]) {
                    int temp = array[j - 1];
                    array[j - 1] = array[j];
                    array[j] = temp;
                }
            }
        }
    }
}
</code></pre>
<h3>C++</h3>
<pre><code class="lang-C++">void bubbleSort(vector&lt;int&gt; &amp; arr){
    for(int i = 0; i &lt; arr.size(); i++){
        for(int j = 1; j &lt; arr.size() - i; j++){
            if(arr[j - 1] &gt; arr[j])){
                std::swap(arr[j-1], arr[j]);
            }
        }
    }
    return arr;
}
</code></pre>
<h3>複雜度分析</h3>
<p>平均情況與最壞情況均為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>, 使用了 temp 作為臨時交換變量，空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.
可以做適當程度的優化，當某一次外迴圈中發現陣列已經有序，就跳出迴圈不再執行，但這僅對於部分的輸入有效，平均及最壞時間複雜度仍為<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span></p>
<pre><code class="lang-C++">void bubbleSort(vector&lt;int&gt; &amp; arr){
    bool unsorted = true;
    for(int i = 0; i &lt; arr.size() &amp;&amp; unsorted; i++){
        unsorted = false;
        for(int j = 1; j &lt; arr.size() - i; j++){
            if(arr[j - 1] &gt; arr[j])){
                std::swap(arr[j-1], arr[j]);
                unsorted = true;
            }
        }
    }
    return arr;
}
</code></pre>
<h2>Reference</h2>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">氣泡排序 - 維基百科，自由的百科全書</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Selection Sort]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_sorting/selection_sort.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_sorting/selection_sort.html">
        </link>
        <updated>2019-11-03T15:42:00Z</updated>
        <summary type="html"><![CDATA[<h1>Selection Sort - 選擇排序</h1>
<!-- toc -->
<ul>
<li><a href="#implementation">Implementation</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#java">Java</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<p>核心：不斷地選擇剩餘元素中的最小者。</p>
<ol>
<li>找到陣列中最小元素並將其和陣列第一個元素交換位置。</li>
<li>在剩下的元素中找到最小元素並將其與陣列第二個元素交換，直至整個陣列排序。</li>
</ol>
<p>性質：</p>
<ul>
<li>比較次數=(N-1)+(N-2)+(N-3)+...+2+1~N^2/2</li>
<li>交換次數=N</li>
<li>運行時間與輸入無關</li>
<li>數據移動最少</li>
</ul>
<p>下圖來源為 <a href="http://wiki.ibcsstudent.org/index.php?title=File:Selection-Sort-Animation.gif">File:Selection-Sort-Animation.gif - IB Computer Science</a></p>
<p><img src="../../shared-files/images/selection_sort.gif" alt="Selection Sort"></p>
<h2>Implementation</h2>
<h3>Python</h3>
<pre><code class="lang-python">#!/usr/bin/env python


def selectionSort(alist):
    for i in xrange(len(alist)):
        print(alist)
        min_index = i
        for j in xrange(i + 1, len(alist)):
            if alist[j] &lt; alist[min_index]:
                min_index = j
        alist[min_index], alist[i] = alist[i], alist[min_index]
    return alist

unsorted_list = [8, 5, 2, 6, 9, 3, 1, 4, 0, 7]
print(selectionSort(unsorted_list))
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Sort {
    public static void main(String[] args) {
        int unsortedArray[] = new int[]{8, 5, 2, 6, 9, 3, 1, 4, 0, 7};
        selectionSort(unsortedArray);
        System.out.println(&quot;After sort: &quot;);
        for (int item : unsortedArray) {
            System.out.print(item + &quot; &quot;);
        }
    }

    public static void selectionSort(int[] array) {
        int len = array.length;
        for (int i = 0; i &lt; len; i++) {
            for (int item : array) {
                System.out.print(item + &quot; &quot;);
            }
            System.out.println();
            int min_index = i;
            for (int j = i + 1; j &lt; len; j++) {
                if (array[j] &lt; array[min_index]) {
                    min_index = j;
                }
            }
            int temp = array[min_index];
            array[min_index] = array[i];
            array[i] = temp;
        }
    }
}
</code></pre>
<h3>C++</h3>
<pre><code class="lang-C++">void selectionSort(vector&lt;int&gt; &amp; arr){
    int min_idx = 0;
    for(int i = 0; i &lt; arr.size(); i++){
        min_idx = i;
        for(int j = i + 1; j &lt; arr.size(); j++){
            if (arr[j] &lt; arr[min_idx])
                min_idx = j;
        }
        std::swap(arr[i], arr[min_idx]);
    }
}
</code></pre>
<h2>Reference</h2>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">選擇排序 - 維基百科，自由的百科全書</a></li>
<li><a href="http://interactivepython.org/runestone/static/pythonds/SortSearch/TheSelectionSort.html">The Selection Sort — Problem Solving with Algorithms and Data Structures</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Selection Sort - 選擇排序</h1>
<!-- toc -->
<ul>
<li><a href="#implementation">Implementation</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#java">Java</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<p>核心：不斷地選擇剩餘元素中的最小者。</p>
<ol>
<li>找到陣列中最小元素並將其和陣列第一個元素交換位置。</li>
<li>在剩下的元素中找到最小元素並將其與陣列第二個元素交換，直至整個陣列排序。</li>
</ol>
<p>性質：</p>
<ul>
<li>比較次數=(N-1)+(N-2)+(N-3)+...+2+1~N^2/2</li>
<li>交換次數=N</li>
<li>運行時間與輸入無關</li>
<li>數據移動最少</li>
</ul>
<p>下圖來源為 <a href="http://wiki.ibcsstudent.org/index.php?title=File:Selection-Sort-Animation.gif">File:Selection-Sort-Animation.gif - IB Computer Science</a></p>
<p><img src="../../shared-files/images/selection_sort.gif" alt="Selection Sort"></p>
<h2>Implementation</h2>
<h3>Python</h3>
<pre><code class="lang-python">#!/usr/bin/env python


def selectionSort(alist):
    for i in xrange(len(alist)):
        print(alist)
        min_index = i
        for j in xrange(i + 1, len(alist)):
            if alist[j] &lt; alist[min_index]:
                min_index = j
        alist[min_index], alist[i] = alist[i], alist[min_index]
    return alist

unsorted_list = [8, 5, 2, 6, 9, 3, 1, 4, 0, 7]
print(selectionSort(unsorted_list))
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Sort {
    public static void main(String[] args) {
        int unsortedArray[] = new int[]{8, 5, 2, 6, 9, 3, 1, 4, 0, 7};
        selectionSort(unsortedArray);
        System.out.println(&quot;After sort: &quot;);
        for (int item : unsortedArray) {
            System.out.print(item + &quot; &quot;);
        }
    }

    public static void selectionSort(int[] array) {
        int len = array.length;
        for (int i = 0; i &lt; len; i++) {
            for (int item : array) {
                System.out.print(item + &quot; &quot;);
            }
            System.out.println();
            int min_index = i;
            for (int j = i + 1; j &lt; len; j++) {
                if (array[j] &lt; array[min_index]) {
                    min_index = j;
                }
            }
            int temp = array[min_index];
            array[min_index] = array[i];
            array[i] = temp;
        }
    }
}
</code></pre>
<h3>C++</h3>
<pre><code class="lang-C++">void selectionSort(vector&lt;int&gt; &amp; arr){
    int min_idx = 0;
    for(int i = 0; i &lt; arr.size(); i++){
        min_idx = i;
        for(int j = i + 1; j &lt; arr.size(); j++){
            if (arr[j] &lt; arr[min_idx])
                min_idx = j;
        }
        std::swap(arr[i], arr[min_idx]);
    }
}
</code></pre>
<h2>Reference</h2>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">選擇排序 - 維基百科，自由的百科全書</a></li>
<li><a href="http://interactivepython.org/runestone/static/pythonds/SortSearch/TheSelectionSort.html">The Selection Sort — Problem Solving with Algorithms and Data Structures</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Insertion Sort]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_sorting/insertion_sort.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_sorting/insertion_sort.html">
        </link>
        <updated>2019-11-03T15:42:01Z</updated>
        <summary type="html"><![CDATA[<h1>Insertion Sort - 插入排序</h1>
<!-- toc -->
<ul>
<li><a href="#implementation">Implementation</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#java">Java</a></li>
</ul>
</li>
<li><a href="#希爾排序-shell-sort">希爾排序 Shell sort</a></li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<p>核心：通過構建有序序列，對於未排序序列，從後向前掃描(對於單向鏈表則只能從前往後遍歷)，找到相應位置並插入。實現上通常使用in-place排序(需用到O(1)的額外空間)</p>
<ol>
<li>從第一個元素開始，該元素可認為已排序</li>
<li>取下一個元素，對已排序陣列從後往前掃描</li>
<li>若從排序陣列中取出的元素大於新元素，則移至下一位置</li>
<li>重複步驟3，直至找到已排序元素小於或等於新元素的位置</li>
<li>插入新元素至該位置</li>
<li>重複2~5</li>
</ol>
<p>性質：</p>
<ul>
<li>交換操作和陣列中導致的數量相同</li>
<li>比較次數&gt;=倒置數量，&lt;=倒置的數量加上陣列的大小減一</li>
<li>每次交換都改變了兩個順序顛倒的元素的位置，即減少了一對倒置，倒置數量為0時即完成排序。</li>
<li>每次交換對應著一次比較，且1到N-1之間的每個i都可能需要一次額外的記錄(a[i]未到達陣列左端時)</li>
<li>最壞情況下需要~<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">N^2/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathrm">/</span><span class="mord mathrm">2</span></span></span></span>次比較和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext> </mtext><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">~N^2/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mspace"> </span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathrm">/</span><span class="mord mathrm">2</span></span></span></span>次交換，最好情況下需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span>次比較和0次交換。</li>
<li>平均情況下需要~<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">N^2/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathrm">/</span><span class="mord mathrm">4</span></span></span></span>次比較和~<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">N^2/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathrm">/</span><span class="mord mathrm">4</span></span></span></span>次交換</li>
</ul>
<p><img src="../../shared-files/images/insertion_sort.gif" alt="Insertion Sort"></p>
<h2>Implementation</h2>
<h3>Python</h3>
<pre><code class="lang-python">#!/usr/bin/env python


def insertionSort(alist):
    for i, item_i in enumerate(alist):
        print alist
        index = i
        while index &gt; 0 and alist[index - 1] &gt; item_i:
            alist[index] = alist[index - 1]
            index -= 1

        alist[index] = item_i

    return alist

unsorted_list = [6, 5, 3, 1, 8, 7, 2, 4]
print(insertionSort(unsorted_list))
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Sort {
    public static void main(String[] args) {
        int unsortedArray[] = new int[]{6, 5, 3, 1, 8, 7, 2, 4};
        insertionSort(unsortedArray);
        System.out.println(&quot;After sort: &quot;);
        for (int item : unsortedArray) {
            System.out.print(item + &quot; &quot;);
        }
    }

    public static void insertionSort(int[] array) {
        int len = array.length;
        for (int i = 0; i &lt; len; i++) {
            int index = i, array_i = array[i];
            while (index &gt; 0 &amp;&amp; array[index - 1] &gt; array_i) {
                array[index] = array[index - 1];
                index -= 1;
            }
            array[index] = array_i;

            /* print sort process */
            for (int item : array) {
                System.out.print(item + &quot; &quot;);
            }
            System.out.println();
        }
    }
}
</code></pre>
<p>實現(C++)：</p>
<pre><code>template&lt;typename T&gt;
void insertion_sort(T arr[], int len) {
    int i, j;
    T temp;
    for (int i = 1; i &lt; len; i++) {
        temp = arr[i];
        for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j--) {
            a[j + 1] = a[j];
        }
        arr[j + 1] = temp;
    }
}
</code></pre><h2>希爾排序 Shell sort</h2>
<p>核心：基於插入排序，使陣列中任意間隔為h的元素都是有序的，即將全部元素分為h個區域使用插入排序。其實現可類似於插入排序但使用不同增量。更高效的原因是它權衡了子陣列的規模和有序性。</p>
<p>實現(C++):</p>
<pre><code>template&lt;typename T&gt;
void shell_sort(T arr[], int len) {
    int gap, i, j;
    T temp;
    for (gap = len &gt;&gt; 1; gap &gt; 0; gap &gt;&gt;= 1)
        for (i = gap; i &lt; len; i++) {
            temp = arr[i];
            for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap)
                arr[j + gap] = arr[j];
            arr[j + gap] = temp;
        }
}
</code></pre><p>希爾排序只描述了分為多個h做插入排序，並沒有規定h的值，事實上有很多研究就是在探討不同的h值對於複雜度的影響，在英文版的wiki百科的<a href="https://en.wikipedia.org/wiki/Shellsort">希爾排序</a>條目中，給出了多種不同的h序列及分析，事實上可以看到Sedgewick給出的序列已經可以達到最差<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><msup><mi>N</mi><mrow><mn>4</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(N^{4/3})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8879999999999999em;"></span><span class="strut bottom" style="height:1.138em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">4</span><span class="mord mathrm mtight">/</span><span class="mord mathrm mtight">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>的複雜度。在實際應用上，若不是排序非常大的序列，這個複雜度已經可以接受，另外希爾排序的實現簡單，尤其是在硬體上，因此可以用應用在嵌入式系統之中。</p>
<h2>Reference</h2>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序 - 維基百科，自由的百科全書</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希爾排序 - 維基百科，自由的百科全書</a></li>
<li><a href="http://interactivepython.org/runestone/static/pythonds/SortSearch/TheInsertionSort.html">The Insertion Sort — Problem Solving with Algorithms and Data Structures</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Insertion Sort - 插入排序</h1>
<!-- toc -->
<ul>
<li><a href="#implementation">Implementation</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#java">Java</a></li>
</ul>
</li>
<li><a href="#希爾排序-shell-sort">希爾排序 Shell sort</a></li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<p>核心：通過構建有序序列，對於未排序序列，從後向前掃描(對於單向鏈表則只能從前往後遍歷)，找到相應位置並插入。實現上通常使用in-place排序(需用到O(1)的額外空間)</p>
<ol>
<li>從第一個元素開始，該元素可認為已排序</li>
<li>取下一個元素，對已排序陣列從後往前掃描</li>
<li>若從排序陣列中取出的元素大於新元素，則移至下一位置</li>
<li>重複步驟3，直至找到已排序元素小於或等於新元素的位置</li>
<li>插入新元素至該位置</li>
<li>重複2~5</li>
</ol>
<p>性質：</p>
<ul>
<li>交換操作和陣列中導致的數量相同</li>
<li>比較次數&gt;=倒置數量，&lt;=倒置的數量加上陣列的大小減一</li>
<li>每次交換都改變了兩個順序顛倒的元素的位置，即減少了一對倒置，倒置數量為0時即完成排序。</li>
<li>每次交換對應著一次比較，且1到N-1之間的每個i都可能需要一次額外的記錄(a[i]未到達陣列左端時)</li>
<li>最壞情況下需要~<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">N^2/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathrm">/</span><span class="mord mathrm">2</span></span></span></span>次比較和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext> </mtext><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">~N^2/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mspace"> </span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathrm">/</span><span class="mord mathrm">2</span></span></span></span>次交換，最好情況下需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span>次比較和0次交換。</li>
<li>平均情況下需要~<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">N^2/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathrm">/</span><span class="mord mathrm">4</span></span></span></span>次比較和~<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">N^2/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathrm">/</span><span class="mord mathrm">4</span></span></span></span>次交換</li>
</ul>
<p><img src="../../shared-files/images/insertion_sort.gif" alt="Insertion Sort"></p>
<h2>Implementation</h2>
<h3>Python</h3>
<pre><code class="lang-python">#!/usr/bin/env python


def insertionSort(alist):
    for i, item_i in enumerate(alist):
        print alist
        index = i
        while index &gt; 0 and alist[index - 1] &gt; item_i:
            alist[index] = alist[index - 1]
            index -= 1

        alist[index] = item_i

    return alist

unsorted_list = [6, 5, 3, 1, 8, 7, 2, 4]
print(insertionSort(unsorted_list))
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Sort {
    public static void main(String[] args) {
        int unsortedArray[] = new int[]{6, 5, 3, 1, 8, 7, 2, 4};
        insertionSort(unsortedArray);
        System.out.println(&quot;After sort: &quot;);
        for (int item : unsortedArray) {
            System.out.print(item + &quot; &quot;);
        }
    }

    public static void insertionSort(int[] array) {
        int len = array.length;
        for (int i = 0; i &lt; len; i++) {
            int index = i, array_i = array[i];
            while (index &gt; 0 &amp;&amp; array[index - 1] &gt; array_i) {
                array[index] = array[index - 1];
                index -= 1;
            }
            array[index] = array_i;

            /* print sort process */
            for (int item : array) {
                System.out.print(item + &quot; &quot;);
            }
            System.out.println();
        }
    }
}
</code></pre>
<p>實現(C++)：</p>
<pre><code>template&lt;typename T&gt;
void insertion_sort(T arr[], int len) {
    int i, j;
    T temp;
    for (int i = 1; i &lt; len; i++) {
        temp = arr[i];
        for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j--) {
            a[j + 1] = a[j];
        }
        arr[j + 1] = temp;
    }
}
</code></pre><h2>希爾排序 Shell sort</h2>
<p>核心：基於插入排序，使陣列中任意間隔為h的元素都是有序的，即將全部元素分為h個區域使用插入排序。其實現可類似於插入排序但使用不同增量。更高效的原因是它權衡了子陣列的規模和有序性。</p>
<p>實現(C++):</p>
<pre><code>template&lt;typename T&gt;
void shell_sort(T arr[], int len) {
    int gap, i, j;
    T temp;
    for (gap = len &gt;&gt; 1; gap &gt; 0; gap &gt;&gt;= 1)
        for (i = gap; i &lt; len; i++) {
            temp = arr[i];
            for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap)
                arr[j + gap] = arr[j];
            arr[j + gap] = temp;
        }
}
</code></pre><p>希爾排序只描述了分為多個h做插入排序，並沒有規定h的值，事實上有很多研究就是在探討不同的h值對於複雜度的影響，在英文版的wiki百科的<a href="https://en.wikipedia.org/wiki/Shellsort">希爾排序</a>條目中，給出了多種不同的h序列及分析，事實上可以看到Sedgewick給出的序列已經可以達到最差<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><msup><mi>N</mi><mrow><mn>4</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(N^{4/3})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8879999999999999em;"></span><span class="strut bottom" style="height:1.138em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">4</span><span class="mord mathrm mtight">/</span><span class="mord mathrm mtight">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>的複雜度。在實際應用上，若不是排序非常大的序列，這個複雜度已經可以接受，另外希爾排序的實現簡單，尤其是在硬體上，因此可以用應用在嵌入式系統之中。</p>
<h2>Reference</h2>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序 - 維基百科，自由的百科全書</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希爾排序 - 維基百科，自由的百科全書</a></li>
<li><a href="http://interactivepython.org/runestone/static/pythonds/SortSearch/TheInsertionSort.html">The Insertion Sort — Problem Solving with Algorithms and Data Structures</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Merge Sort]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_sorting/merge_sort.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_sorting/merge_sort.html">
        </link>
        <updated>2019-11-03T15:42:01Z</updated>
        <summary type="html"><![CDATA[<h1>Merge Sort - 合併排序</h1>
<!-- toc -->
<ul>
<li><a href="#python">Python</a><ul>
<li><a href="#原地in-place合併">原地(in-place)合併</a></li>
</ul>
</li>
<li><a href="#java">Java</a><ul>
<li><a href="#reference">Reference</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>核心：將兩個有序對數組合併成一個更大的有序數組。通常做法為遞歸排序，並將兩個不同的有序數組合併到第三個數組中。</p>
<p>先來看看動圖，合併排序是一種典型的分治(divide and conquer)應用。</p>
<p><img src="../../shared-files/images/merge_sort.gif" alt="Merge Sort"></p>
<h3>Python</h3>
<pre><code class="lang-python">#!/usr/bin/env python


class Sort:
    def mergeSort(self, alist):
        if len(alist) &lt;= 1:
            return alist

        mid = len(alist) / 2
        left = self.mergeSort(alist[:mid])
        print(&quot;left = &quot; + str(left))
        right = self.mergeSort(alist[mid:])
        print(&quot;right = &quot; + str(right))
        return self.mergeSortedArray(left, right)

    #@param A and B: sorted integer array A and B.
    #@return: A new sorted integer array
    def mergeSortedArray(self, A, B):
        sortedArray = []
        l = 0
        r = 0
        while l &lt; len(A) and r &lt; len(B):
            if A[l] &lt; B[r]:
                sortedArray.append(A[l])
                l += 1
            else:
                sortedArray.append(B[r])
                r += 1
        sortedArray += A[l:]
        sortedArray += B[r:]

        return sortedArray

unsortedArray = [6, 5, 3, 1, 8, 7, 2, 4]
merge_sort = Sort()
print(merge_sort.mergeSort(unsortedArray))
</code></pre>
<h2>原地(in-place)合併</h2>
<h3>Java</h3>
<pre><code>public class MergeSort {
    public static void main(String[] args) {
        int unsortedArray[] = new int[]{6, 5, 3, 1, 8, 7, 2, 4};
        mergeSort(unsortedArray);
        System.out.println(&quot;After sort: &quot;);
        for (int item : unsortedArray) {
            System.out.print(item + &quot; &quot;);
        }
    }

    private static void merge(int[] array, int low, int mid, int high) {
        int[] helper = new int[array.length];
        // copy array to helper
        for (int k = low; k &lt;= high; k++) {
            helper[k] = array[k];
        }
        // merge array[low...mid] and array[mid + 1...high]
        int i = low, j = mid + 1;
        for (int k = low; k &lt;= high; k++) {
            // k means current location
            if (i &gt; mid) {
            // no item in left part
                array[k] = helper[j];
                j++;
            } else if (j &gt; high) {
            // no item in right part
                array[k] = helper[i];
                i++;
            } else if (helper[i] &gt; helper[j]) {
            // get smaller item in the right side
                array[k] = helper[j];
                j++;
            } else {
            // get smaller item in the left side
                array[k] = helper[i];
                i++;
            }
        }
    }

    public static void sort(int[] array, int low, int high) {
        if (high &lt;= low) return;
        int mid = low + (high - low) / 2;
        sort(array, low, mid);
        sort(array, mid + 1, high);
        merge(array, low, mid, high);
        for (int item : array) {
            System.out.print(item + &quot; &quot;);
        }
        System.out.println();
    }

    public static void mergeSort(int[] array) {
        sort(array, 0, array.length - 1);
    }
}
</code></pre><h3>C++</h3>
<pre><code>void merge (vector&lt;int&gt;&amp; arr, int low, int mid, int high){
    vector&lt;int&gt; helper(arr.size());
    for(int k = low; k &lt;= high; k++){
        helper[k] = arr[k];
    }
    int i = low, j = mid+1;
    for(int k = low; k &lt;= high; k++){
        if(i &gt; mid){
            arr[k] = helper[j];
            j++;
        }
        else if(j &gt; high){
            arr[k] = helper[i];
            i++;
        }
        else if(helper[j] &gt; helper[i]){
            arr[k] = helper[j];
            j++;
        }
        else{
            arr[k] = helper[i];
            i++;
        }
    }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int low, int high){
    int mid = low + (high - low)/2;
    mergeSort(arr, low, mid);
    mergeSort(arr, mid + 1, high);
    merge(arr, low, mid, high);
}
</code></pre><p>時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mi>log</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N \log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>, 使用了等長的輔助陣列，空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p>
<h2>Reference</h2>
<ul>
<li><a href="http://algs4.cs.princeton.edu/22mergesort/">Mergesort</a> - Robert Sedgewick 的大作，非常清晰。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Merge Sort - 合併排序</h1>
<!-- toc -->
<ul>
<li><a href="#python">Python</a><ul>
<li><a href="#原地in-place合併">原地(in-place)合併</a></li>
</ul>
</li>
<li><a href="#java">Java</a><ul>
<li><a href="#reference">Reference</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>核心：將兩個有序對數組合併成一個更大的有序數組。通常做法為遞歸排序，並將兩個不同的有序數組合併到第三個數組中。</p>
<p>先來看看動圖，合併排序是一種典型的分治(divide and conquer)應用。</p>
<p><img src="../../shared-files/images/merge_sort.gif" alt="Merge Sort"></p>
<h3>Python</h3>
<pre><code class="lang-python">#!/usr/bin/env python


class Sort:
    def mergeSort(self, alist):
        if len(alist) &lt;= 1:
            return alist

        mid = len(alist) / 2
        left = self.mergeSort(alist[:mid])
        print(&quot;left = &quot; + str(left))
        right = self.mergeSort(alist[mid:])
        print(&quot;right = &quot; + str(right))
        return self.mergeSortedArray(left, right)

    #@param A and B: sorted integer array A and B.
    #@return: A new sorted integer array
    def mergeSortedArray(self, A, B):
        sortedArray = []
        l = 0
        r = 0
        while l &lt; len(A) and r &lt; len(B):
            if A[l] &lt; B[r]:
                sortedArray.append(A[l])
                l += 1
            else:
                sortedArray.append(B[r])
                r += 1
        sortedArray += A[l:]
        sortedArray += B[r:]

        return sortedArray

unsortedArray = [6, 5, 3, 1, 8, 7, 2, 4]
merge_sort = Sort()
print(merge_sort.mergeSort(unsortedArray))
</code></pre>
<h2>原地(in-place)合併</h2>
<h3>Java</h3>
<pre><code>public class MergeSort {
    public static void main(String[] args) {
        int unsortedArray[] = new int[]{6, 5, 3, 1, 8, 7, 2, 4};
        mergeSort(unsortedArray);
        System.out.println(&quot;After sort: &quot;);
        for (int item : unsortedArray) {
            System.out.print(item + &quot; &quot;);
        }
    }

    private static void merge(int[] array, int low, int mid, int high) {
        int[] helper = new int[array.length];
        // copy array to helper
        for (int k = low; k &lt;= high; k++) {
            helper[k] = array[k];
        }
        // merge array[low...mid] and array[mid + 1...high]
        int i = low, j = mid + 1;
        for (int k = low; k &lt;= high; k++) {
            // k means current location
            if (i &gt; mid) {
            // no item in left part
                array[k] = helper[j];
                j++;
            } else if (j &gt; high) {
            // no item in right part
                array[k] = helper[i];
                i++;
            } else if (helper[i] &gt; helper[j]) {
            // get smaller item in the right side
                array[k] = helper[j];
                j++;
            } else {
            // get smaller item in the left side
                array[k] = helper[i];
                i++;
            }
        }
    }

    public static void sort(int[] array, int low, int high) {
        if (high &lt;= low) return;
        int mid = low + (high - low) / 2;
        sort(array, low, mid);
        sort(array, mid + 1, high);
        merge(array, low, mid, high);
        for (int item : array) {
            System.out.print(item + &quot; &quot;);
        }
        System.out.println();
    }

    public static void mergeSort(int[] array) {
        sort(array, 0, array.length - 1);
    }
}
</code></pre><h3>C++</h3>
<pre><code>void merge (vector&lt;int&gt;&amp; arr, int low, int mid, int high){
    vector&lt;int&gt; helper(arr.size());
    for(int k = low; k &lt;= high; k++){
        helper[k] = arr[k];
    }
    int i = low, j = mid+1;
    for(int k = low; k &lt;= high; k++){
        if(i &gt; mid){
            arr[k] = helper[j];
            j++;
        }
        else if(j &gt; high){
            arr[k] = helper[i];
            i++;
        }
        else if(helper[j] &gt; helper[i]){
            arr[k] = helper[j];
            j++;
        }
        else{
            arr[k] = helper[i];
            i++;
        }
    }
}

void mergeSort(vector&lt;int&gt;&amp; arr, int low, int high){
    int mid = low + (high - low)/2;
    mergeSort(arr, low, mid);
    mergeSort(arr, mid + 1, high);
    merge(arr, low, mid, high);
}
</code></pre><p>時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mi>log</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N \log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>, 使用了等長的輔助陣列，空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p>
<h2>Reference</h2>
<ul>
<li><a href="http://algs4.cs.princeton.edu/22mergesort/">Mergesort</a> - Robert Sedgewick 的大作，非常清晰。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Heap Sort]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_sorting/heap_sort.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_sorting/heap_sort.html">
        </link>
        <updated>2019-11-03T15:42:01Z</updated>
        <summary type="html"><![CDATA[<h1>Heap Sort - 堆排序</h1>
<!-- toc -->
<ul>
<li><a href="#堆的操作">堆的操作</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<p>堆排序通常基於<a href="http://algorithm.yuanbin.me/zh-hans/basics_data_structure/heap.html"><strong>二元堆</strong> </a>實現，以大根堆(根結點為最大值)爲例，堆排序的實現過程分爲兩個子過程。第一步爲取出大根堆的根節點(當前堆的最大值), 由於取走了一個節點，故需要對餘下的元素重新建堆。重新建堆後繼續取根節點，循環直至取完所有節點，此時數組已經有序。基本思想就是這樣，不過實現上還是有些小技巧的。</p>
<h2>堆的操作</h2>
<p>以大根堆爲例，堆的常用操作如下。</p>
<ol>
<li>最大堆調整（Max_Heapify）：將堆的末端子節點作調整，使得子節點永遠小於父節點</li>
<li>創建最大堆（Build_Max_Heap）：將堆所有數據重新排序</li>
<li>堆排序（HeapSort）：移除位在第一個數據的根節點，並做最大堆調整的遞歸運算</li>
</ol>
<p>其中步驟1是給步驟2和3用的。</p>
<p><img src="../../shared-files/images/Heapsort-example.gif" alt="Heapsort-example"></p>
<p>建堆時可以自頂向下，也可以採取自底向上，以下先採用自底向上的思路分析。我們可以將數組的後半部分節點想象爲堆的最下面的那些節點，由於是單個節點，故顯然滿足二叉堆的定義，於是乎我們就可以從中間節點向上逐步構建二叉堆，每前進一步都保證其後的節點都是二叉堆，這樣一來前進到第一個節點時整個數組就是一個二叉堆了。下面用 C++/Java 實現一個堆的類。C++/Java 中推薦使用 PriorityQueue 來使用堆。</p>
<p>堆排在空間比較小(嵌入式設備和手機)時特別有用，但是因爲現代系統往往有較多的快取，堆排序無法有效利用快取，數組元素很少和相鄰的其他元素比較，故快取未命中的機率遠大於其他在相鄰元素間比較的算法。但是在大數據的排序下又重新發揮了重要作用，因爲它在插入操作和刪除最大元素的混合動態場景中能保證對數級別的運行時間。</p>
<h3>C++</h3>
<pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class HeapSort {
    // get the parent node index
    int parent(int i) {
        return (i - 1) / 2;
    }

    // get the left child node index
    int left(int i) {
        return 2 * i + 1;
    }

    // get the right child node index
    int right(int i) {
        return 2 * i + 2;
    }

    // build max heap
    void build_max_heapify(vector&lt;int&gt; &amp;nums, int heap_size) {
        for (int i = heap_size / 2; i &gt;= 0; --i) {
            max_heapify(nums, i, heap_size);
        }
        print_heap(nums, heap_size);
    }

    // build min heap
    void build_min_heapify(vector&lt;int&gt; &amp;nums, int heap_size) {
        for (int i = heap_size / 2; i &gt;= 0; --i) {
            min_heapify(nums, i, heap_size);
        }
        print_heap(nums, heap_size);
    }

    // adjust the heap to max-heap
    void max_heapify(vector&lt;int&gt; &amp;nums, int k, int len) {
        // int len = nums.size();
        while (k &lt; len) {
            int max_index = k;
            // left leaf node search
            int l = left(k);
            if (l &lt; len &amp;&amp; nums[l] &gt; nums[max_index]) {
                max_index = l;
            }
            // right leaf node search
            int r = right(k);
            if (r &lt; len &amp;&amp; nums[r] &gt; nums[max_index]) {
                max_index = r;
            }
            // node after k are max-heap already
            if (k == max_index) {
                break;
            }
            // keep the root node the largest
            int temp = nums[k];
            nums[k] = nums[max_index];
            nums[max_index] = temp;
            // adjust not only just current index
            k = max_index;
        }
    }

    // adjust the heap to min-heap
    void min_heapify(vector&lt;int&gt; &amp;nums, int k, int len) {
        // int len = nums.size();
        while (k &lt; len) {
            int min_index = k;
            // left leaf node search
            int l = left(k);
            if (l &lt; len &amp;&amp; nums[l] &lt; nums[min_index]) {
                min_index = l;
            }
            // right leaf node search
            int r = right(k);
            if (r &lt; len &amp;&amp; nums[r] &lt; nums[min_index]) {
                min_index = r;
            }
            // node after k are min-heap already
            if (k == min_index) {
                break;
            }
            // keep the root node the largest
            int temp = nums[k];
            nums[k] = nums[min_index];
            nums[min_index] = temp;
            // adjust not only just current index
            k = min_index;
        }
    }

public:
    // heap sort
    void heap_sort(vector&lt;int&gt; &amp;nums) {
        int len = nums.size();
        // init heap structure
        build_max_heapify(nums, len);
        // heap sort
        for (int i = len - 1; i &gt;= 0; --i) {
            // put the largest number int the last
            int temp = nums[0];
            nums[0] = nums[i];
            nums[i] = temp;
            // reconstruct heap
            build_max_heapify(nums, i);
        }
        print_heap(nums, len);
    }

    // print heap between [0, heap_size - 1]
    void print_heap(vector&lt;int&gt; &amp;nums, int heap_size) {
        for (int i = 0; i &lt; heap_size; ++i) {
            cout &lt;&lt; nums[i] &lt;&lt; &quot;, &quot;;
        }
        cout &lt;&lt; endl;
    }
};

int main(int argc, char *argv[])
{
    int A[] = {19, 1, 10, 14, 16, 4, 7, 9, 3, 2, 8, 5, 11};
    vector&lt;int&gt; nums;
    for (int i = 0; i &lt; sizeof(A) / sizeof(A[0]); ++i) {
        nums.push_back(A[i]);
    }

    HeapSort sort;
    sort.print_heap(nums, nums.size());
    sort.heap_sort(nums);

    return 0;
}
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">import java.util.*;

public class HeapSort {
    // sign = 1 ==&gt; min-heap, sign = -1 ==&gt; max-heap
    private void siftDown(int[] nums, int k, int size, int sign) {
        int half = (size &gt;&gt;&gt; 1);
        while (k &lt; half) {
            int index = k;
            // left leaf node search
            int l = (k &lt;&lt; 1) + 1;
            if (l &lt; size &amp;&amp; (sign * nums[l]) &lt; (sign * nums[index])) {
                index = l;
            }
            // right leaf node search
            int r = l + 1;
            if (r &lt; size &amp;&amp; (sign * nums[r]) &lt; (sign * nums[index])) {
                index = r;
            }
            // already heapify
            if (k == index) break;
            // keep the root node the smallest/largest
            int temp = nums[k];
            nums[k] = nums[index];
            nums[index] = temp;
            // adjust next index
            k = index;
        }
    }

    private void heapify(int[] nums, int size, int sign) {
        for (int i = size / 2; i &gt;= 0; i--) {
            siftDown(nums, i, size, sign);
        }
    }

    private void minHeap(int[] nums, int size) {
        heapify(nums, size, 1);
    }

    private void maxHeap(int[] nums, int size) {
        heapify(nums, size, -1);
    }

    public void sort(int[] nums, boolean ascending) {
        if (ascending) {
            // build max heap
            maxHeap(nums, nums.length);
            // heap sort
            for (int i = nums.length - 1; i &gt;= 0; i--) {
                int temp = nums[0];
                nums[0] = nums[i];
                nums[i] = temp;
                // reconstruct max heap
                maxHeap(nums, i);
            }
        } else {
            // build min heap
            minHeap(nums, nums.length);
            // heap sort
            for (int i = nums.length - 1; i &gt;= 0; i--) {
                int temp = nums[0];
                nums[0] = nums[i];
                nums[i] = temp;
                // reconstruct min heap
                minHeap(nums, i);
            }
        }
    }

    public static void main(String[] args) {
        int[] A = new int[]{19, 1, 10, 14, 16, 4, 4, 7, 9, 3, 2, 8, 5, 11};
        HeapSort heapsort = new HeapSort();
        heapsort.sort(A, true);
        for (int i : A) {
            System.out.println(i);
        }
    }
}
</code></pre>
<h3>複雜度分析</h3>
<p>從程式碼中可以發現堆排最費時間的地方在於構建二叉堆的過程。</p>
<p>上述構建大根堆和小根堆都是自底向上的方法，建堆過程時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>2</mn><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>, 堆化過程(可結合圖形分析，最多需要調整的層數爲最大深度)時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">\log i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">i</span></span></span></span>, 故堆排過程中總的時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mi>log</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N \log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>.</p>
<p>先看看建堆的過程，畫圖分析(比如以8個節點爲例)可知在最壞情況下，每次都需要調整之前已經成爲堆的節點，那麼就意味着有二分之一的節點向下比較了一次，四分之一的節點向下比較了兩次，八分之一的節點比較了三次... 等差等比數列求和，具體過程可參考下面的連結。</p>
<h2>Reference</h2>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序 - 維基百科，自由的百科全書</a></li>
<li><a href="http://algs4.cs.princeton.edu/24pq/">Priority Queues</a> - Robert Sedgewick 的大作，詳解了關於堆的操作。</li>
<li><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/">經典排序算法總結與實現 | Jark&#39;s Blog</a> - 堆排序講的很好。</li>
<li><em>Algorithm</em> - Robert Sedgewick</li>
<li><a href="http://www.zhihu.com/question/20729324">堆排序中建堆過程時間複雜度O(n)怎麼來的？</a></li>
<li><a href="http://www.cnblogs.com/cj723/archive/2011/04/21/2024261.html">《大話數據結構》第9章 排序 9.7 堆排序（上） - 伍迷 - 博客園</a></li>
<li><a href="http://www.cnblogs.com/cj723/archive/2011/04/22/2024269.html">《大話數據結構》第9章 排序 9.7 堆排序（下） - 伍迷 - 博客園</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Heap Sort - 堆排序</h1>
<!-- toc -->
<ul>
<li><a href="#堆的操作">堆的操作</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<p>堆排序通常基於<a href="http://algorithm.yuanbin.me/zh-hans/basics_data_structure/heap.html"><strong>二元堆</strong> </a>實現，以大根堆(根結點為最大值)爲例，堆排序的實現過程分爲兩個子過程。第一步爲取出大根堆的根節點(當前堆的最大值), 由於取走了一個節點，故需要對餘下的元素重新建堆。重新建堆後繼續取根節點，循環直至取完所有節點，此時數組已經有序。基本思想就是這樣，不過實現上還是有些小技巧的。</p>
<h2>堆的操作</h2>
<p>以大根堆爲例，堆的常用操作如下。</p>
<ol>
<li>最大堆調整（Max_Heapify）：將堆的末端子節點作調整，使得子節點永遠小於父節點</li>
<li>創建最大堆（Build_Max_Heap）：將堆所有數據重新排序</li>
<li>堆排序（HeapSort）：移除位在第一個數據的根節點，並做最大堆調整的遞歸運算</li>
</ol>
<p>其中步驟1是給步驟2和3用的。</p>
<p><img src="../../shared-files/images/Heapsort-example.gif" alt="Heapsort-example"></p>
<p>建堆時可以自頂向下，也可以採取自底向上，以下先採用自底向上的思路分析。我們可以將數組的後半部分節點想象爲堆的最下面的那些節點，由於是單個節點，故顯然滿足二叉堆的定義，於是乎我們就可以從中間節點向上逐步構建二叉堆，每前進一步都保證其後的節點都是二叉堆，這樣一來前進到第一個節點時整個數組就是一個二叉堆了。下面用 C++/Java 實現一個堆的類。C++/Java 中推薦使用 PriorityQueue 來使用堆。</p>
<p>堆排在空間比較小(嵌入式設備和手機)時特別有用，但是因爲現代系統往往有較多的快取，堆排序無法有效利用快取，數組元素很少和相鄰的其他元素比較，故快取未命中的機率遠大於其他在相鄰元素間比較的算法。但是在大數據的排序下又重新發揮了重要作用，因爲它在插入操作和刪除最大元素的混合動態場景中能保證對數級別的運行時間。</p>
<h3>C++</h3>
<pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class HeapSort {
    // get the parent node index
    int parent(int i) {
        return (i - 1) / 2;
    }

    // get the left child node index
    int left(int i) {
        return 2 * i + 1;
    }

    // get the right child node index
    int right(int i) {
        return 2 * i + 2;
    }

    // build max heap
    void build_max_heapify(vector&lt;int&gt; &amp;nums, int heap_size) {
        for (int i = heap_size / 2; i &gt;= 0; --i) {
            max_heapify(nums, i, heap_size);
        }
        print_heap(nums, heap_size);
    }

    // build min heap
    void build_min_heapify(vector&lt;int&gt; &amp;nums, int heap_size) {
        for (int i = heap_size / 2; i &gt;= 0; --i) {
            min_heapify(nums, i, heap_size);
        }
        print_heap(nums, heap_size);
    }

    // adjust the heap to max-heap
    void max_heapify(vector&lt;int&gt; &amp;nums, int k, int len) {
        // int len = nums.size();
        while (k &lt; len) {
            int max_index = k;
            // left leaf node search
            int l = left(k);
            if (l &lt; len &amp;&amp; nums[l] &gt; nums[max_index]) {
                max_index = l;
            }
            // right leaf node search
            int r = right(k);
            if (r &lt; len &amp;&amp; nums[r] &gt; nums[max_index]) {
                max_index = r;
            }
            // node after k are max-heap already
            if (k == max_index) {
                break;
            }
            // keep the root node the largest
            int temp = nums[k];
            nums[k] = nums[max_index];
            nums[max_index] = temp;
            // adjust not only just current index
            k = max_index;
        }
    }

    // adjust the heap to min-heap
    void min_heapify(vector&lt;int&gt; &amp;nums, int k, int len) {
        // int len = nums.size();
        while (k &lt; len) {
            int min_index = k;
            // left leaf node search
            int l = left(k);
            if (l &lt; len &amp;&amp; nums[l] &lt; nums[min_index]) {
                min_index = l;
            }
            // right leaf node search
            int r = right(k);
            if (r &lt; len &amp;&amp; nums[r] &lt; nums[min_index]) {
                min_index = r;
            }
            // node after k are min-heap already
            if (k == min_index) {
                break;
            }
            // keep the root node the largest
            int temp = nums[k];
            nums[k] = nums[min_index];
            nums[min_index] = temp;
            // adjust not only just current index
            k = min_index;
        }
    }

public:
    // heap sort
    void heap_sort(vector&lt;int&gt; &amp;nums) {
        int len = nums.size();
        // init heap structure
        build_max_heapify(nums, len);
        // heap sort
        for (int i = len - 1; i &gt;= 0; --i) {
            // put the largest number int the last
            int temp = nums[0];
            nums[0] = nums[i];
            nums[i] = temp;
            // reconstruct heap
            build_max_heapify(nums, i);
        }
        print_heap(nums, len);
    }

    // print heap between [0, heap_size - 1]
    void print_heap(vector&lt;int&gt; &amp;nums, int heap_size) {
        for (int i = 0; i &lt; heap_size; ++i) {
            cout &lt;&lt; nums[i] &lt;&lt; &quot;, &quot;;
        }
        cout &lt;&lt; endl;
    }
};

int main(int argc, char *argv[])
{
    int A[] = {19, 1, 10, 14, 16, 4, 7, 9, 3, 2, 8, 5, 11};
    vector&lt;int&gt; nums;
    for (int i = 0; i &lt; sizeof(A) / sizeof(A[0]); ++i) {
        nums.push_back(A[i]);
    }

    HeapSort sort;
    sort.print_heap(nums, nums.size());
    sort.heap_sort(nums);

    return 0;
}
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">import java.util.*;

public class HeapSort {
    // sign = 1 ==&gt; min-heap, sign = -1 ==&gt; max-heap
    private void siftDown(int[] nums, int k, int size, int sign) {
        int half = (size &gt;&gt;&gt; 1);
        while (k &lt; half) {
            int index = k;
            // left leaf node search
            int l = (k &lt;&lt; 1) + 1;
            if (l &lt; size &amp;&amp; (sign * nums[l]) &lt; (sign * nums[index])) {
                index = l;
            }
            // right leaf node search
            int r = l + 1;
            if (r &lt; size &amp;&amp; (sign * nums[r]) &lt; (sign * nums[index])) {
                index = r;
            }
            // already heapify
            if (k == index) break;
            // keep the root node the smallest/largest
            int temp = nums[k];
            nums[k] = nums[index];
            nums[index] = temp;
            // adjust next index
            k = index;
        }
    }

    private void heapify(int[] nums, int size, int sign) {
        for (int i = size / 2; i &gt;= 0; i--) {
            siftDown(nums, i, size, sign);
        }
    }

    private void minHeap(int[] nums, int size) {
        heapify(nums, size, 1);
    }

    private void maxHeap(int[] nums, int size) {
        heapify(nums, size, -1);
    }

    public void sort(int[] nums, boolean ascending) {
        if (ascending) {
            // build max heap
            maxHeap(nums, nums.length);
            // heap sort
            for (int i = nums.length - 1; i &gt;= 0; i--) {
                int temp = nums[0];
                nums[0] = nums[i];
                nums[i] = temp;
                // reconstruct max heap
                maxHeap(nums, i);
            }
        } else {
            // build min heap
            minHeap(nums, nums.length);
            // heap sort
            for (int i = nums.length - 1; i &gt;= 0; i--) {
                int temp = nums[0];
                nums[0] = nums[i];
                nums[i] = temp;
                // reconstruct min heap
                minHeap(nums, i);
            }
        }
    }

    public static void main(String[] args) {
        int[] A = new int[]{19, 1, 10, 14, 16, 4, 4, 7, 9, 3, 2, 8, 5, 11};
        HeapSort heapsort = new HeapSort();
        heapsort.sort(A, true);
        for (int i : A) {
            System.out.println(i);
        }
    }
}
</code></pre>
<h3>複雜度分析</h3>
<p>從程式碼中可以發現堆排最費時間的地方在於構建二叉堆的過程。</p>
<p>上述構建大根堆和小根堆都是自底向上的方法，建堆過程時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>2</mn><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>, 堆化過程(可結合圖形分析，最多需要調整的層數爲最大深度)時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">\log i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">i</span></span></span></span>, 故堆排過程中總的時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>N</mi><mi>log</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N \log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>.</p>
<p>先看看建堆的過程，畫圖分析(比如以8個節點爲例)可知在最壞情況下，每次都需要調整之前已經成爲堆的節點，那麼就意味着有二分之一的節點向下比較了一次，四分之一的節點向下比較了兩次，八分之一的節點比較了三次... 等差等比數列求和，具體過程可參考下面的連結。</p>
<h2>Reference</h2>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序 - 維基百科，自由的百科全書</a></li>
<li><a href="http://algs4.cs.princeton.edu/24pq/">Priority Queues</a> - Robert Sedgewick 的大作，詳解了關於堆的操作。</li>
<li><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/">經典排序算法總結與實現 | Jark&#39;s Blog</a> - 堆排序講的很好。</li>
<li><em>Algorithm</em> - Robert Sedgewick</li>
<li><a href="http://www.zhihu.com/question/20729324">堆排序中建堆過程時間複雜度O(n)怎麼來的？</a></li>
<li><a href="http://www.cnblogs.com/cj723/archive/2011/04/21/2024261.html">《大話數據結構》第9章 排序 9.7 堆排序（上） - 伍迷 - 博客園</a></li>
<li><a href="http://www.cnblogs.com/cj723/archive/2011/04/22/2024269.html">《大話數據結構》第9章 排序 9.7 堆排序（下） - 伍迷 - 博客園</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bucket Sort]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_sorting/bucket_sort.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_sorting/bucket_sort.html">
        </link>
        <updated>2019-11-03T15:42:01Z</updated>
        <summary type="html"><![CDATA[<h1>Bucket Sort</h1>
<p>桶排序和合併排序有那麼點點類似，也使用了合併的思想。大致步驟如下：</p>
<ol>
<li>設置一個定量的數組當作空桶。</li>
<li>Divide - 從待排序數組中取出元素，將元素按照一定的規則塞進對應的桶子去。</li>
<li>對每個非空桶進行排序，通常可在塞元素入桶時進行插入排序。</li>
<li>Conquer - 從非空桶把元素再放回原來的數組中。</li>
</ol>
<h2>Reference</h2>
<ul>
<li><a href="http://www.cs.usfca.edu/~galles/visualization/BucketSort.html">Bucket Sort Visualization</a> - 動態示例。</li>
<li><a href="http://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F">桶排序 - 維基百科，自由的百科全書</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Bucket Sort</h1>
<p>桶排序和合併排序有那麼點點類似，也使用了合併的思想。大致步驟如下：</p>
<ol>
<li>設置一個定量的數組當作空桶。</li>
<li>Divide - 從待排序數組中取出元素，將元素按照一定的規則塞進對應的桶子去。</li>
<li>對每個非空桶進行排序，通常可在塞元素入桶時進行插入排序。</li>
<li>Conquer - 從非空桶把元素再放回原來的數組中。</li>
</ol>
<h2>Reference</h2>
<ul>
<li><a href="http://www.cs.usfca.edu/~galles/visualization/BucketSort.html">Bucket Sort Visualization</a> - 動態示例。</li>
<li><a href="http://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F">桶排序 - 維基百科，自由的百科全書</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Counting Sort]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_sorting/counting_sort.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_sorting/counting_sort.html">
        </link>
        <updated>2019-11-03T15:42:02Z</updated>
        <summary type="html"><![CDATA[<h1>Counting Sort</h1>
<p>計數排序，顧名思義，就是對待排序陣列按元素進行計數。使用前提是需要先知道待排序陣列的元素範圍，將這些一定範圍的元素置於新陣列中，新陣列的大小爲待排序陣列中最大元素與最小元素的差值。</p>
<p>維基上總結的四個步驟如下：</p>
<ol>
<li>定新陣列大小——找出待排序的陣列中最大和最小的元素</li>
<li>統計次數——統計陣列中每個值爲i的元素出現的次數，存入新陣列C的第i項</li>
<li>對統計次數逐個累加——對所有的計數累加（從C中的第一個元素開始，每一項和前一項相加）</li>
<li>反向填充目標陣列——將每個元素i放在新陣列的第C(i)項，每放一個元素就將C(i)減去1</li>
</ol>
<p>其中反向填充主要是爲了避免重復元素落入新陣列的同一索引處。</p>
<h2>Reference</h2>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F">計數排序 - 維基百科，自由的百科全書</a> - 中文版的維基感覺比英文版的好理解些。</li>
<li><a href="https://www.cs.usfca.edu/~galles/visualization/CountingSort.html">Counting Sort Visualization</a> - 動畫真心不錯~ 結合著看一遍就理解了。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Counting Sort</h1>
<p>計數排序，顧名思義，就是對待排序陣列按元素進行計數。使用前提是需要先知道待排序陣列的元素範圍，將這些一定範圍的元素置於新陣列中，新陣列的大小爲待排序陣列中最大元素與最小元素的差值。</p>
<p>維基上總結的四個步驟如下：</p>
<ol>
<li>定新陣列大小——找出待排序的陣列中最大和最小的元素</li>
<li>統計次數——統計陣列中每個值爲i的元素出現的次數，存入新陣列C的第i項</li>
<li>對統計次數逐個累加——對所有的計數累加（從C中的第一個元素開始，每一項和前一項相加）</li>
<li>反向填充目標陣列——將每個元素i放在新陣列的第C(i)項，每放一個元素就將C(i)減去1</li>
</ol>
<p>其中反向填充主要是爲了避免重復元素落入新陣列的同一索引處。</p>
<h2>Reference</h2>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F">計數排序 - 維基百科，自由的百科全書</a> - 中文版的維基感覺比英文版的好理解些。</li>
<li><a href="https://www.cs.usfca.edu/~galles/visualization/CountingSort.html">Counting Sort Visualization</a> - 動畫真心不錯~ 結合著看一遍就理解了。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Radix Sort]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_sorting/radix_sort.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_sorting/radix_sort.html">
        </link>
        <updated>2019-11-03T15:42:02Z</updated>
        <summary type="html"><![CDATA[<h1>Radix Sort</h1>
<p>經典排序演算法 - 基數排序Radix sort</p>
<p>原理類似桶排序 Bucket Sort,這裡總是需要10個桶,多次使用</p>
<p>首先以個位數的值進行裝桶,即個位數爲1則放入1號桶,爲9則放入9號桶,暫時忽視十位數</p>
<p>例如</p>
<p>取一個簡單的待排序陣列[62,14,59,88,16]</p>
<p>分配10個桶,桶編號爲0-9,以個位數數字爲桶編號依次放入桶,變成下邊這樣</p>
<p>|  0  |  0  | 62 |  0  | 14 |  0  | 16 |  0  |  88 | 59 |</p>
<p>|  0  |  1  |  2  |  3  |  4 |  5  |  6  |  7  |  8  |  9  |桶編號</p>
<p>將桶裏的數字順序取出來,</p>
<p>輸出結果:[62,14,16,88,59]</p>
<p>再次入桶,不過這次以十位數的數字爲準,進入相應的桶,變成下邊這樣:</p>
<p>由於前邊做了個位數的排序,所以當十位數相等時,個位數字是由小到大的順序入桶的,就是說,入完桶還是有序</p>
<p>|  0  | 14,16 |  0  |  0  |  0  | 59 | 62  | 0  | 88  |  0  |</p>
<p>|  0  |  1      |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |桶編號</p>
<p>因爲沒有大過100的數字,沒有百位數,所以到這排序完畢,順序取出即可</p>
<p>最後輸出結果:[14,16,59,62,88]</p>
<p>文章引用自
<a href="http://www.cnblogs.com/kkun/archive/2011/11/23/2260275.html">http://www.cnblogs.com/kkun/archive/2011/11/23/2260275.html</a></p>
]]></summary>
        <content type="html"><![CDATA[<h1>Radix Sort</h1>
<p>經典排序演算法 - 基數排序Radix sort</p>
<p>原理類似桶排序 Bucket Sort,這裡總是需要10個桶,多次使用</p>
<p>首先以個位數的值進行裝桶,即個位數爲1則放入1號桶,爲9則放入9號桶,暫時忽視十位數</p>
<p>例如</p>
<p>取一個簡單的待排序陣列[62,14,59,88,16]</p>
<p>分配10個桶,桶編號爲0-9,以個位數數字爲桶編號依次放入桶,變成下邊這樣</p>
<p>|  0  |  0  | 62 |  0  | 14 |  0  | 16 |  0  |  88 | 59 |</p>
<p>|  0  |  1  |  2  |  3  |  4 |  5  |  6  |  7  |  8  |  9  |桶編號</p>
<p>將桶裏的數字順序取出來,</p>
<p>輸出結果:[62,14,16,88,59]</p>
<p>再次入桶,不過這次以十位數的數字爲準,進入相應的桶,變成下邊這樣:</p>
<p>由於前邊做了個位數的排序,所以當十位數相等時,個位數字是由小到大的順序入桶的,就是說,入完桶還是有序</p>
<p>|  0  | 14,16 |  0  |  0  |  0  | 59 | 62  | 0  | 88  |  0  |</p>
<p>|  0  |  1      |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |桶編號</p>
<p>因爲沒有大過100的數字,沒有百位數,所以到這排序完畢,順序取出即可</p>
<p>最後輸出結果:[14,16,59,62,88]</p>
<p>文章引用自
<a href="http://www.cnblogs.com/kkun/archive/2011/11/23/2260275.html">http://www.cnblogs.com/kkun/archive/2011/11/23/2260275.html</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Basics Algorithm]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_algorithm/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_algorithm/">
        </link>
        <updated>2019-11-03T15:42:02Z</updated>
        <summary type="html"><![CDATA[<h1>Basics Algorithm</h1>
<p>本章主要介紹一些常用的基本演算法，後序章節介紹一些高級演算法。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Basics Algorithm</h1>
<p>本章主要介紹一些常用的基本演算法，後序章節介紹一些高級演算法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Divide and Conquer]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_algorithm/divide_and_conquer.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_algorithm/divide_and_conquer.html">
        </link>
        <updated>2019-11-03T15:42:02Z</updated>
        <summary type="html"><![CDATA[<h1>Divide and Conquer - 分治法</h1>
<p>在計算機科學中，分治法是一種很重要的演算法。分治法即『分而治之』，把一個複雜的問題分成兩個或更多的相同或相似的子問題，再把子問題分成更小的子問題……直到最後子問題可以簡單的直接求解，原問題的解即子問題的解的合併。這個思想是很多高效演算法的基礎，如排序演算法（快速排序，合併排序）等。</p>
<h2>分治法思想</h2>
<p>分治法所能解決的問題一般具有以下幾個特徵：</p>
<ol>
<li>問題的規模縮小到一定的程度就可以容易地解決。</li>
<li>問題可以分解爲若干個規模較小的相同問題，即該問題具有<strong>最優子結構</strong>性質。</li>
<li>利用該問題分解出的子問題的解可以合併爲該問題的解。</li>
<li>該問題所分解出的各個子問題是相互獨立的，即子問題之間不包含公共的子問題。</li>
</ol>
<p>分治法的三個步驟是：</p>
<ol>
<li>分解（Divide）：將原問題分解爲若乾子問題，這些子問題都是原問題規模較小的實例。</li>
<li>解決（Conquer）：遞歸地求解各子問題。如果子問題規模足夠小，則直接求解。</li>
<li>合併（Combine）：將所有子問題的解合併爲原問題的解。</li>
</ol>
<p>分治法的經典題目：</p>
<ol>
<li>二分搜索</li>
<li>大整數乘法</li>
<li>Strassen矩陣乘法</li>
<li>棋盤覆蓋</li>
<li>歸並排序</li>
<li>快速排序</li>
<li>循環賽日程表</li>
<li>河內塔</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h1>Divide and Conquer - 分治法</h1>
<p>在計算機科學中，分治法是一種很重要的演算法。分治法即『分而治之』，把一個複雜的問題分成兩個或更多的相同或相似的子問題，再把子問題分成更小的子問題……直到最後子問題可以簡單的直接求解，原問題的解即子問題的解的合併。這個思想是很多高效演算法的基礎，如排序演算法（快速排序，合併排序）等。</p>
<h2>分治法思想</h2>
<p>分治法所能解決的問題一般具有以下幾個特徵：</p>
<ol>
<li>問題的規模縮小到一定的程度就可以容易地解決。</li>
<li>問題可以分解爲若干個規模較小的相同問題，即該問題具有<strong>最優子結構</strong>性質。</li>
<li>利用該問題分解出的子問題的解可以合併爲該問題的解。</li>
<li>該問題所分解出的各個子問題是相互獨立的，即子問題之間不包含公共的子問題。</li>
</ol>
<p>分治法的三個步驟是：</p>
<ol>
<li>分解（Divide）：將原問題分解爲若乾子問題，這些子問題都是原問題規模較小的實例。</li>
<li>解決（Conquer）：遞歸地求解各子問題。如果子問題規模足夠小，則直接求解。</li>
<li>合併（Combine）：將所有子問題的解合併爲原問題的解。</li>
</ol>
<p>分治法的經典題目：</p>
<ol>
<li>二分搜索</li>
<li>大整數乘法</li>
<li>Strassen矩陣乘法</li>
<li>棋盤覆蓋</li>
<li>歸並排序</li>
<li>快速排序</li>
<li>循環賽日程表</li>
<li>河內塔</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Binary Search]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_algorithm/binary_search.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_algorithm/binary_search.html">
        </link>
        <updated>2019-11-03T15:42:03Z</updated>
        <summary type="html"><![CDATA[<h1>Binary Search - 二分搜索</h1>
<!-- toc -->
<ul>
<li><a href="#模板一---lowerupper-bound">模板一 - lower/upper bound</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
</ul>
</li>
<li><a href="#模板二---最優解">模板二 - 最優解</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#輸入">輸入</a></li>
<li><a href="#輸出">輸出</a></li>
</ul>
</li>
<li><a href="#題解">題解</a></li>
<li><a href="#java-1">Java</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
</ul>
</li>
<li><a href="#模板三---二分搜索的-while-結束條件判定">模板三 - 二分搜索的 <code>while</code> 結束條件判定</a></li>
<li><a href="#模板四-－-（九章算法）模版">模板四 － （九章算法）模版</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#java-2">Java</a></li>
<li><a href="#problem-statement-1">Problem Statement</a><ul>
<li><a href="#樣例">樣例</a></li>
</ul>
</li>
<li><a href="#python-1">Python</a></li>
<li><a href="#源碼分析-2">源碼分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<p>二分搜索是一種在有序陣列中尋找目標值的經典方法，也就是說使用前提是『有序陣列』。非常簡單的題中『有序』特徵非常明顯，但更多時候可能需要我們自己去構造『有序陣列』。下面我們從最基本的二分搜索開始逐步深入。</p>
<h2>模板一 - lower/upper bound</h2>
<p>定義 lower bound 爲在給定升序陣列中大於等於目標值的最小索引，upper bound 則爲小於等於目標值的最大索引，下面給出程式碼和測試用例。</p>
<h3>Java</h3>
<pre><code class="lang-java">import java.util.*;

public class Main {
    public static void main(String[] args) {
        int[] nums = new int[]{1,2,2,3,4,6,6,6,13,18};
        System.out.println(lowerBound(nums, 6)); // 5
        System.out.println(upperBound(nums, 6)); // 7
        System.out.println(lowerBound(nums, 7)); // 8
        System.out.println(upperBound(nums, 7)); // 7
    }

    /*
    * nums[index] &gt;= target, min(index)
    */
    public static int lowerBound(int[] nums, int target) {
        if (nums == null || nums.length == 0) return -1;
        int lb = -1, ub = nums.length;
        while (lb + 1 &lt; ub) {
            int mid = lb + (ub - lb) / 2;
            if (nums[mid] &lt; target) {
                lb = mid;
            } else {
                ub = mid;
            }
        }

        return lb + 1;
    }

    /*
    * nums[index] &lt;= target, max(index)
    */
    public static int upperBound(int[] nums, int target) {
        if (nums == null || nums.length == 0) return -1;
        int lb = -1, ub = nums.length;
        while (lb + 1 &lt; ub) {
            int mid = lb + (ub - lb) / 2;
            if (nums[mid] &gt; target) {
                ub = mid;
            } else {
                lb = mid;
            }
        }

        return ub - 1;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>以<code>lowerBound</code>的實現爲例，以上二分搜索的模板有幾個非常優雅的實現：</p>
<ol>
<li><code>while</code> 循環中 <code>lb + 1 &lt; ub</code>, 而不是等號，因爲取等號可能會引起死循環。初始化<code>lb &lt; ub</code> 時，最後循環退出時一定有<code>lb + 1 == ub</code>.</li>
<li><code>mid = lb + (ub - lb) / 2</code>, 可有效防止兩數相加後溢出。</li>
<li><code>lb</code> 和 <code>ub</code> 的初始化，初始化爲陣列的兩端以外，這種初始化方式比起<code>0</code> 和<code>nums.length - 1</code> 有不少優點，詳述如下。</li>
</ol>
<p>如果遇到有問插入索引的位置時，可以分三種典型情況：</p>
<ol>
<li>目標值在陣列範圍之內，最後返回值一定是<code>lb + 1</code></li>
<li>目標值比陣列最小值還小，此時<code>lb</code> 一直爲<code>-1</code>, 故最後返回<code>lb + 1</code> 也沒錯，也可以將<code>-1</code> 理解爲陣列前一個更小的值</li>
<li>目標值大於等於陣列最後一個值，由於循環退出條件爲<code>lb + 1 == ub</code>, 那麼循環退出時一定有<code>lb = A.length - 1</code>, 應該返回<code>lb + 1</code></li>
</ol>
<p>綜上所述，返回<code>lb + 1</code>是非常優雅的實現。其實以上三種情況都可以統一爲一種方式來理解，即索引<code>-1</code> 對應於陣列前方一個非常小的數，索引<code>ub</code> 即對應陣列後方一個非常大的數，那麼要插入的數就一定在<code>lb</code> 和<code>ub</code> 之間了。</p>
<p><strong>有時複雜的邊界條件處理可以通過『補項』這種優雅的方式巧妙處理。</strong></p>
<p>關於lb 和 ub 的初始化，由於<code>mid = lb + (ub - lb) / 2</code>, 且有<code>lb + 1 &lt; ub</code>，故 mid 還是有可能爲<code>ub - 1</code>或者<code>lb + 1</code>的，在需要訪問<code>mid + 1</code>或者<code>mid - 1</code>處索引的元素時可能會越界。這時候就需要將初始化方式改爲<code>lb = 0, ub = A.length - 1</code> 了，最後再加一個關於<code>lb, ub</code> 處索引元素的判斷即可。如 <a href="http://algorithm.yuanbin.me/zh-hans/binary_search/search_for_a_range.html">Search for a Range</a> 和 <a href="http://algorithm.yuanbin.me/zh-hans/binary_search/find_peak_element.html">Find Peak Element</a>. 尤其是 Find Peak Element 中 lb 和 ub 的初始值如果初始化爲-1和陣列長度會帶來一些麻煩。</p>
<h2>模板二 - 最優解</h2>
<p>除了在有序陣列中尋找目標值這種非常直接的二分搜索外，我們還可以利用二分搜索求最優解（最大值/最小值），通常這種題中只是隱含了『有序陣列』，需要我們自己構造。</p>
<p>用數學語言來描述就是『求滿足某條件 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">C(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span> 的最小/大的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>』，以求最小值爲例，對於任意滿足條件的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>, 如果所有的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>≤</mo><msup><mi>x</mi><mi mathvariant="normal">′</mi></msup><mo>≤</mo><mi>U</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">x \leq x^\prime \leq UB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.887862em;vertical-align:-0.13597em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">≤</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> 對於 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>(</mo><msup><mi>x</mi><mi mathvariant="normal">′</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">C(x^\prime)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span> 都爲真（其中 <code>UB</code> 可能爲無窮大，也可能爲滿足條件的最大的解，如果不滿足此條件就不能保證二分搜索的正確性），那麼我們就能使用二分搜索進行求解，其中初始化時下界<code>lb</code> 初始化爲不滿足條件的值<code>LB</code>, 上界初始化爲滿足條件的上界<code>UB</code>. 隨後在<code>while</code> 循環內部每次取中，滿足條件就取<code>ub = mid</code>, 否則<code>lb = mid</code>, 那麼最後<code>ub</code> 就是要求的最小值。求最大值時類似，只不過處理的是<code>lb</code>.</p>
<p>以 <a href="http://poj.org/problem?id=1064">POJ No.1064</a> 爲例。</p>
<h3>Problem Statement</h3>
<p>有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span> 條繩子，它們的長度分別爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>. 如果從它們中切割出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span> 條長度相同的繩子的話，這 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span> 條繩子每條最長能有多長？答案保留到小數點後兩位。</p>
<h4>輸入</h4>
<pre><code>N = 4, L = {8.02, 7.43, 4.57, 5.39}, K = 11
</code></pre><h4>輸出</h4>
<p>2.00</p>
<h3>題解</h3>
<p>這道題看似是一個最優化問題，我們來嘗試下使用模板二的思想求解，<strong>令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">C(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span> 爲『可以得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span> 條長度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span> 的繩子』。</strong>根據題意，我們可以將上述條件進一步細化爲：
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msub><mo>∑</mo><mi>i</mi></msub><mo>(</mo><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo>(</mo><msub><mi>L</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><mi>x</mi><mo>)</mo><mo>)</mo><mo>≥</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">
C(x) = \sum_i(floor(L_i / x)) \geq K
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.0500050000000003em;"></span><span class="strut bottom" style="height:2.327674em;vertical-align:-1.277669em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mrel">=</span><span class="mop op-limits"><span class="vlist"><span style="top:1.1776689999999999em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span style="top:-0.000005000000000143778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span><span class="mop op-symbol large-op">∑</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathrm">/</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">≥</span><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span></span></p>
<p>我們現在來分析下可行解的上下界。由於答案保留小數點後兩位，顯然繩子長度一定大於0，大於0的小數點後保留兩位的最小值爲<code>0.01</code>, 顯然如果問題最後有解，<code>0.01</code> 一定是可行解中最小的，且這個解可以分割出的繩子條數是最多的。一般在 OJ 上不同變量都是會給出範圍限制，那麼我們將上界初始化爲<code>最大範圍 + 0.01</code>, 它一定在可行解之外（也可以遍歷一遍陣列取陣列最大值，但其實二分後複雜度相差不大）。使用二分搜索後最後返回<code>lb</code> 即可。</p>
<h3>Java</h3>
<pre><code class="lang-java">import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int k = in.nextInt();
        double[] nums = new double[n];
        for (int i = 0; i &lt; n; i++) {
            nums[i] = in.nextDouble();
        }
        System.out.printf(&quot;%.2f\n&quot;, Math.floor(solve(nums, k) * 100) / 100);
    }

    public static double solve(double[] nums, int K) {
        double lb = 0.00, ub = 10e5 + 0.01;
        // while (lb + 0.001 &lt; ub) {
    for (int i = 0; i &lt; 100; i++) {
            double mid = lb + (ub - lb) / 2;
            if (C(nums, mid, K)) {
                lb = mid;
            } else {
                ub = mid;
            }
        }
        return lb;
    }

    public static boolean C(double[] nums, double seg, int k) {
        int count = 0;
        for (double num : nums) {
            count += Math.floor(num / seg);
        }
        return count &gt;= k;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>方法<code>C</code> 只做一件事，給定陣列<code>nums</code>, 判斷是否能切割出<code>K</code> 條長度均爲<code>seg</code> 的繩子。<code>while</code> 循環中使用<code>lb + 0.001 &lt; ub</code>, 不能使用<code>0.01</code>, 因爲計算<code>mid</code> 時有均值的計算，對於<code>double</code> 型數值否則會有較大誤差。</p>
<h2>模板三 - 二分搜索的 <code>while</code> 結束條件判定</h2>
<p>對於整型我們通常使用<code>lb + 1 &lt; ub</code>, 但對於<code>double</code>型數據來說會有些精度上的丟失，使得結束條件不是那麼好確定。像上題中採用的方法是題目中使用的精度除10。但有時候這種精度可能還是不夠，如果結束條件<code>lb + EPS &lt; ub</code>中使用的 EPS 過小時 double 型數據精度有可能不夠從而導致死循環的產生！這時候我們將<code>while</code>循環體替換爲<code>for (int i = 0; i &lt; 100; i++)</code>, 100 次循環後可以達到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>3</mn><mn>0</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord"><span class="mord mathrm">0</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">3</span><span class="mord mathrm mtight">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span> 精度範圍，一般都沒問題。</p>
<h2>模板四 － （九章算法）模版</h2>
<p>這個模版跟第一個模版類似， 但是相對更容易上手。這個模版的核心是， <code>將binary search 問題轉化成：尋找第一個或者最後一個，該target元素出現的位置的問題</code>，<code>Find the any/first/last position of target in nums</code>. 詳解請見下面的例題。這個模版有四個要素。</p>
<ol>
<li>start + 1 &lt; end
 表示， 當指針指到兩個元素，相鄰或者相交的時候， 循環停止。 這樣的話在最終分情況討論的時候，只用考慮<code>1～2</code>個元素。</li>
<li>start + (end - start) / 2
 寫C++ 和 Java的同學要考慮到int overflow的問題， 所以需要考慮邊界情況。 寫Python的同學就不用考慮了， 因爲python這個語言本身已經非常努力的保證了number不會overflow。</li>
<li>A[mid] ==, &gt;, &lt;
 在循環中， 分三種情況討論邊界。 要注意， 在移動<code>start</code>和<code>end</code>的時候， 只要單純的把指針指向<code>mid</code>的位置， 不要<code>+1</code>或者<code>-1</code>。 因爲只移動邊界到<code>mid</code>的位置， 不會誤刪除target。在工程中，儘量在程序最後的時候統一寫<code>return</code>, 這樣可以增強可讀性。</li>
<li>A[start], A[end]? target
 在循環結束時，因爲只有1～2個元素需要討論，所以結果非常容易解釋清楚。 只存在的2種情況爲， 1. <code>start + 1 == end</code> 邊界指向相鄰的兩個元素， 這時只需要分情況討論<code>start</code>和<code>end</code>與target的關係，就可以得出結果。 2. <code>start == end</code> 邊界指向同一元素， 其實這個情況還是可以按照1的方法，分成<code>start``end</code>討論，只不過討論結果一樣而已。</li>
</ol>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    def binary_search(self, array, target):
        if not array:
            return -1

        start, end = 0, len(array) - 1
        while start + 1 &lt; end:
            mid = (start + end) / 2
            if array[mid] == target:
                start = mid
            elif array[mid] &lt; target:
                start = mid
            else:
                end = mid

        if array[start] == target:
            return start
        if array[end] == target:
            return end
        return -1
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">class Solution {
    public int binarySearch(int[] array, int target) {
        if (array == null || array.length == 0) {
            return -1;
        }

        int start = 0, end = array.length - 1;
        while (start + 1 &lt; end) {
            int mid = start + (end - start) / 2;
            if (array[mid] == target) {
                start = mid;
            } else if (array[mid] &lt; target) {
                start = mid;
            } else {
                end = mid;
            }
        }
        if (array[start] == target) {
            return start;
        }
        if (array[end] == target) {
            return end;
        }
        return -1;
    }
}
</code></pre>
<h3>Problem Statement</h3>
<p><a href="http://www.lintcode.com/zh-hans/problem/search-for-a-range/">Search for a Range</a></p>
<h4>樣例</h4>
<p>給出[5, 7, 7, 8, 8, 10]和目標值target=8,</p>
<p>返回[3, 4]</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    def search_range(self, array, target):
        ret = [-1, -1]
        if not array:
            return ret
        # search first position of target
        st, ed = 0, len(array) - 1
        while st + 1 &lt; ed:
            mid = (st + ed) / 2
            if array[mid] == target:
                ed = mid
            elif array[mid] &lt; target:
                st = mid
            else:
                ed = mid
        if array[st] == target:
            ret[0] = st
        elif array[ed] == target:
            ret[0] = ed

        # search last position of target
        st, ed = 0, len(array) - 1
        while st + 1 &lt; ed:
            mid = (st + ed) / 2
            if array[mid] == target:
                st = mid
            elif array[mid] &lt; target:
                st = mid
            else:
                ed = mid
        if array[ed] == target:
            ret[1] = ed
        elif array[st] == target:
            ret[1] = st

        return ret
</code></pre>
<h3>源碼分析</h3>
<p>search range的問題可以理解爲， 尋找第一次target出現的位置和最後一次target出現的位置。 當尋找第一次target出現位置的循環中， <code>array[mid] == target</code>表示， target可以出現在mid或者mid更前的位置， 所以將ed移動到mid。當循環跳出時， st的位置在ed之前，所以先判斷在st位置上是否是target， 再判斷ed位置。當尋找最後一次target出現位置的循環中，<code>array[mid] == target</code>表示， target可以出現在mid或者mid之後的位置， 所以將st移動到mid。 當循環結束時，ed的位置比st的位置更靠後， 所以先判斷ed的位置是否爲target， 再判斷st位置。 最後返回ret。</p>
<h2>Reference</h2>
<ul>
<li>《挑戰程序設計競賽》</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Binary Search - 二分搜索</h1>
<!-- toc -->
<ul>
<li><a href="#模板一---lowerupper-bound">模板一 - lower/upper bound</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
</ul>
</li>
<li><a href="#模板二---最優解">模板二 - 最優解</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#輸入">輸入</a></li>
<li><a href="#輸出">輸出</a></li>
</ul>
</li>
<li><a href="#題解">題解</a></li>
<li><a href="#java-1">Java</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
</ul>
</li>
<li><a href="#模板三---二分搜索的-while-結束條件判定">模板三 - 二分搜索的 <code>while</code> 結束條件判定</a></li>
<li><a href="#模板四-－-（九章算法）模版">模板四 － （九章算法）模版</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#java-2">Java</a></li>
<li><a href="#problem-statement-1">Problem Statement</a><ul>
<li><a href="#樣例">樣例</a></li>
</ul>
</li>
<li><a href="#python-1">Python</a></li>
<li><a href="#源碼分析-2">源碼分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<p>二分搜索是一種在有序陣列中尋找目標值的經典方法，也就是說使用前提是『有序陣列』。非常簡單的題中『有序』特徵非常明顯，但更多時候可能需要我們自己去構造『有序陣列』。下面我們從最基本的二分搜索開始逐步深入。</p>
<h2>模板一 - lower/upper bound</h2>
<p>定義 lower bound 爲在給定升序陣列中大於等於目標值的最小索引，upper bound 則爲小於等於目標值的最大索引，下面給出程式碼和測試用例。</p>
<h3>Java</h3>
<pre><code class="lang-java">import java.util.*;

public class Main {
    public static void main(String[] args) {
        int[] nums = new int[]{1,2,2,3,4,6,6,6,13,18};
        System.out.println(lowerBound(nums, 6)); // 5
        System.out.println(upperBound(nums, 6)); // 7
        System.out.println(lowerBound(nums, 7)); // 8
        System.out.println(upperBound(nums, 7)); // 7
    }

    /*
    * nums[index] &gt;= target, min(index)
    */
    public static int lowerBound(int[] nums, int target) {
        if (nums == null || nums.length == 0) return -1;
        int lb = -1, ub = nums.length;
        while (lb + 1 &lt; ub) {
            int mid = lb + (ub - lb) / 2;
            if (nums[mid] &lt; target) {
                lb = mid;
            } else {
                ub = mid;
            }
        }

        return lb + 1;
    }

    /*
    * nums[index] &lt;= target, max(index)
    */
    public static int upperBound(int[] nums, int target) {
        if (nums == null || nums.length == 0) return -1;
        int lb = -1, ub = nums.length;
        while (lb + 1 &lt; ub) {
            int mid = lb + (ub - lb) / 2;
            if (nums[mid] &gt; target) {
                ub = mid;
            } else {
                lb = mid;
            }
        }

        return ub - 1;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>以<code>lowerBound</code>的實現爲例，以上二分搜索的模板有幾個非常優雅的實現：</p>
<ol>
<li><code>while</code> 循環中 <code>lb + 1 &lt; ub</code>, 而不是等號，因爲取等號可能會引起死循環。初始化<code>lb &lt; ub</code> 時，最後循環退出時一定有<code>lb + 1 == ub</code>.</li>
<li><code>mid = lb + (ub - lb) / 2</code>, 可有效防止兩數相加後溢出。</li>
<li><code>lb</code> 和 <code>ub</code> 的初始化，初始化爲陣列的兩端以外，這種初始化方式比起<code>0</code> 和<code>nums.length - 1</code> 有不少優點，詳述如下。</li>
</ol>
<p>如果遇到有問插入索引的位置時，可以分三種典型情況：</p>
<ol>
<li>目標值在陣列範圍之內，最後返回值一定是<code>lb + 1</code></li>
<li>目標值比陣列最小值還小，此時<code>lb</code> 一直爲<code>-1</code>, 故最後返回<code>lb + 1</code> 也沒錯，也可以將<code>-1</code> 理解爲陣列前一個更小的值</li>
<li>目標值大於等於陣列最後一個值，由於循環退出條件爲<code>lb + 1 == ub</code>, 那麼循環退出時一定有<code>lb = A.length - 1</code>, 應該返回<code>lb + 1</code></li>
</ol>
<p>綜上所述，返回<code>lb + 1</code>是非常優雅的實現。其實以上三種情況都可以統一爲一種方式來理解，即索引<code>-1</code> 對應於陣列前方一個非常小的數，索引<code>ub</code> 即對應陣列後方一個非常大的數，那麼要插入的數就一定在<code>lb</code> 和<code>ub</code> 之間了。</p>
<p><strong>有時複雜的邊界條件處理可以通過『補項』這種優雅的方式巧妙處理。</strong></p>
<p>關於lb 和 ub 的初始化，由於<code>mid = lb + (ub - lb) / 2</code>, 且有<code>lb + 1 &lt; ub</code>，故 mid 還是有可能爲<code>ub - 1</code>或者<code>lb + 1</code>的，在需要訪問<code>mid + 1</code>或者<code>mid - 1</code>處索引的元素時可能會越界。這時候就需要將初始化方式改爲<code>lb = 0, ub = A.length - 1</code> 了，最後再加一個關於<code>lb, ub</code> 處索引元素的判斷即可。如 <a href="http://algorithm.yuanbin.me/zh-hans/binary_search/search_for_a_range.html">Search for a Range</a> 和 <a href="http://algorithm.yuanbin.me/zh-hans/binary_search/find_peak_element.html">Find Peak Element</a>. 尤其是 Find Peak Element 中 lb 和 ub 的初始值如果初始化爲-1和陣列長度會帶來一些麻煩。</p>
<h2>模板二 - 最優解</h2>
<p>除了在有序陣列中尋找目標值這種非常直接的二分搜索外，我們還可以利用二分搜索求最優解（最大值/最小值），通常這種題中只是隱含了『有序陣列』，需要我們自己構造。</p>
<p>用數學語言來描述就是『求滿足某條件 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">C(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span> 的最小/大的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>』，以求最小值爲例，對於任意滿足條件的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>, 如果所有的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>≤</mo><msup><mi>x</mi><mi mathvariant="normal">′</mi></msup><mo>≤</mo><mi>U</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">x \leq x^\prime \leq UB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:0.887862em;vertical-align:-0.13597em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">≤</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> 對於 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>(</mo><msup><mi>x</mi><mi mathvariant="normal">′</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">C(x^\prime)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span> 都爲真（其中 <code>UB</code> 可能爲無窮大，也可能爲滿足條件的最大的解，如果不滿足此條件就不能保證二分搜索的正確性），那麼我們就能使用二分搜索進行求解，其中初始化時下界<code>lb</code> 初始化爲不滿足條件的值<code>LB</code>, 上界初始化爲滿足條件的上界<code>UB</code>. 隨後在<code>while</code> 循環內部每次取中，滿足條件就取<code>ub = mid</code>, 否則<code>lb = mid</code>, 那麼最後<code>ub</code> 就是要求的最小值。求最大值時類似，只不過處理的是<code>lb</code>.</p>
<p>以 <a href="http://poj.org/problem?id=1064">POJ No.1064</a> 爲例。</p>
<h3>Problem Statement</h3>
<p>有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">N</span></span></span></span> 條繩子，它們的長度分別爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>. 如果從它們中切割出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span> 條長度相同的繩子的話，這 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span> 條繩子每條最長能有多長？答案保留到小數點後兩位。</p>
<h4>輸入</h4>
<pre><code>N = 4, L = {8.02, 7.43, 4.57, 5.39}, K = 11
</code></pre><h4>輸出</h4>
<p>2.00</p>
<h3>題解</h3>
<p>這道題看似是一個最優化問題，我們來嘗試下使用模板二的思想求解，<strong>令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">C(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span> 爲『可以得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span> 條長度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span> 的繩子』。</strong>根據題意，我們可以將上述條件進一步細化爲：
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msub><mo>∑</mo><mi>i</mi></msub><mo>(</mo><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo>(</mo><msub><mi>L</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><mi>x</mi><mo>)</mo><mo>)</mo><mo>≥</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">
C(x) = \sum_i(floor(L_i / x)) \geq K
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.0500050000000003em;"></span><span class="strut bottom" style="height:2.327674em;vertical-align:-1.277669em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mrel">=</span><span class="mop op-limits"><span class="vlist"><span style="top:1.1776689999999999em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span style="top:-0.000005000000000143778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span><span class="mop op-symbol large-op">∑</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathrm">/</span><span class="mord mathit">x</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">≥</span><span class="mord mathit" style="margin-right:0.07153em;">K</span></span></span></span></span></p>
<p>我們現在來分析下可行解的上下界。由於答案保留小數點後兩位，顯然繩子長度一定大於0，大於0的小數點後保留兩位的最小值爲<code>0.01</code>, 顯然如果問題最後有解，<code>0.01</code> 一定是可行解中最小的，且這個解可以分割出的繩子條數是最多的。一般在 OJ 上不同變量都是會給出範圍限制，那麼我們將上界初始化爲<code>最大範圍 + 0.01</code>, 它一定在可行解之外（也可以遍歷一遍陣列取陣列最大值，但其實二分後複雜度相差不大）。使用二分搜索後最後返回<code>lb</code> 即可。</p>
<h3>Java</h3>
<pre><code class="lang-java">import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int k = in.nextInt();
        double[] nums = new double[n];
        for (int i = 0; i &lt; n; i++) {
            nums[i] = in.nextDouble();
        }
        System.out.printf(&quot;%.2f\n&quot;, Math.floor(solve(nums, k) * 100) / 100);
    }

    public static double solve(double[] nums, int K) {
        double lb = 0.00, ub = 10e5 + 0.01;
        // while (lb + 0.001 &lt; ub) {
    for (int i = 0; i &lt; 100; i++) {
            double mid = lb + (ub - lb) / 2;
            if (C(nums, mid, K)) {
                lb = mid;
            } else {
                ub = mid;
            }
        }
        return lb;
    }

    public static boolean C(double[] nums, double seg, int k) {
        int count = 0;
        for (double num : nums) {
            count += Math.floor(num / seg);
        }
        return count &gt;= k;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>方法<code>C</code> 只做一件事，給定陣列<code>nums</code>, 判斷是否能切割出<code>K</code> 條長度均爲<code>seg</code> 的繩子。<code>while</code> 循環中使用<code>lb + 0.001 &lt; ub</code>, 不能使用<code>0.01</code>, 因爲計算<code>mid</code> 時有均值的計算，對於<code>double</code> 型數值否則會有較大誤差。</p>
<h2>模板三 - 二分搜索的 <code>while</code> 結束條件判定</h2>
<p>對於整型我們通常使用<code>lb + 1 &lt; ub</code>, 但對於<code>double</code>型數據來說會有些精度上的丟失，使得結束條件不是那麼好確定。像上題中採用的方法是題目中使用的精度除10。但有時候這種精度可能還是不夠，如果結束條件<code>lb + EPS &lt; ub</code>中使用的 EPS 過小時 double 型數據精度有可能不夠從而導致死循環的產生！這時候我們將<code>while</code>循環體替換爲<code>for (int i = 0; i &lt; 100; i++)</code>, 100 次循環後可以達到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>3</mn><mn>0</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord"><span class="mord mathrm">0</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">3</span><span class="mord mathrm mtight">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span> 精度範圍，一般都沒問題。</p>
<h2>模板四 － （九章算法）模版</h2>
<p>這個模版跟第一個模版類似， 但是相對更容易上手。這個模版的核心是， <code>將binary search 問題轉化成：尋找第一個或者最後一個，該target元素出現的位置的問題</code>，<code>Find the any/first/last position of target in nums</code>. 詳解請見下面的例題。這個模版有四個要素。</p>
<ol>
<li>start + 1 &lt; end
 表示， 當指針指到兩個元素，相鄰或者相交的時候， 循環停止。 這樣的話在最終分情況討論的時候，只用考慮<code>1～2</code>個元素。</li>
<li>start + (end - start) / 2
 寫C++ 和 Java的同學要考慮到int overflow的問題， 所以需要考慮邊界情況。 寫Python的同學就不用考慮了， 因爲python這個語言本身已經非常努力的保證了number不會overflow。</li>
<li>A[mid] ==, &gt;, &lt;
 在循環中， 分三種情況討論邊界。 要注意， 在移動<code>start</code>和<code>end</code>的時候， 只要單純的把指針指向<code>mid</code>的位置， 不要<code>+1</code>或者<code>-1</code>。 因爲只移動邊界到<code>mid</code>的位置， 不會誤刪除target。在工程中，儘量在程序最後的時候統一寫<code>return</code>, 這樣可以增強可讀性。</li>
<li>A[start], A[end]? target
 在循環結束時，因爲只有1～2個元素需要討論，所以結果非常容易解釋清楚。 只存在的2種情況爲， 1. <code>start + 1 == end</code> 邊界指向相鄰的兩個元素， 這時只需要分情況討論<code>start</code>和<code>end</code>與target的關係，就可以得出結果。 2. <code>start == end</code> 邊界指向同一元素， 其實這個情況還是可以按照1的方法，分成<code>start``end</code>討論，只不過討論結果一樣而已。</li>
</ol>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    def binary_search(self, array, target):
        if not array:
            return -1

        start, end = 0, len(array) - 1
        while start + 1 &lt; end:
            mid = (start + end) / 2
            if array[mid] == target:
                start = mid
            elif array[mid] &lt; target:
                start = mid
            else:
                end = mid

        if array[start] == target:
            return start
        if array[end] == target:
            return end
        return -1
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">class Solution {
    public int binarySearch(int[] array, int target) {
        if (array == null || array.length == 0) {
            return -1;
        }

        int start = 0, end = array.length - 1;
        while (start + 1 &lt; end) {
            int mid = start + (end - start) / 2;
            if (array[mid] == target) {
                start = mid;
            } else if (array[mid] &lt; target) {
                start = mid;
            } else {
                end = mid;
            }
        }
        if (array[start] == target) {
            return start;
        }
        if (array[end] == target) {
            return end;
        }
        return -1;
    }
}
</code></pre>
<h3>Problem Statement</h3>
<p><a href="http://www.lintcode.com/zh-hans/problem/search-for-a-range/">Search for a Range</a></p>
<h4>樣例</h4>
<p>給出[5, 7, 7, 8, 8, 10]和目標值target=8,</p>
<p>返回[3, 4]</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    def search_range(self, array, target):
        ret = [-1, -1]
        if not array:
            return ret
        # search first position of target
        st, ed = 0, len(array) - 1
        while st + 1 &lt; ed:
            mid = (st + ed) / 2
            if array[mid] == target:
                ed = mid
            elif array[mid] &lt; target:
                st = mid
            else:
                ed = mid
        if array[st] == target:
            ret[0] = st
        elif array[ed] == target:
            ret[0] = ed

        # search last position of target
        st, ed = 0, len(array) - 1
        while st + 1 &lt; ed:
            mid = (st + ed) / 2
            if array[mid] == target:
                st = mid
            elif array[mid] &lt; target:
                st = mid
            else:
                ed = mid
        if array[ed] == target:
            ret[1] = ed
        elif array[st] == target:
            ret[1] = st

        return ret
</code></pre>
<h3>源碼分析</h3>
<p>search range的問題可以理解爲， 尋找第一次target出現的位置和最後一次target出現的位置。 當尋找第一次target出現位置的循環中， <code>array[mid] == target</code>表示， target可以出現在mid或者mid更前的位置， 所以將ed移動到mid。當循環跳出時， st的位置在ed之前，所以先判斷在st位置上是否是target， 再判斷ed位置。當尋找最後一次target出現位置的循環中，<code>array[mid] == target</code>表示， target可以出現在mid或者mid之後的位置， 所以將st移動到mid。 當循環結束時，ed的位置比st的位置更靠後， 所以先判斷ed的位置是否爲target， 再判斷st位置。 最後返回ret。</p>
<h2>Reference</h2>
<ul>
<li>《挑戰程序設計競賽》</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Math]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_algorithm/math/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_algorithm/math/">
        </link>
        <updated>2019-11-03T15:42:03Z</updated>
        <summary type="html"><![CDATA[<h1>Math</h1>
<!-- toc -->
<ul>
<li><a href="#modulus---取模運算">Modulus - 取模運算</a></li>
<li><a href="#fast-power---快速冪運算">Fast Power - 快速冪運算</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>本小節總結一些與數學（尤其是數論部分）有關的基礎，主要總結了《挑戰程序設計競賽》(原文為《プログラミングコンテストチャレンジブック》)第二章。主要包含以下內容：</p>
<ol>
<li>Greatest Common Divisor(最大公因數)</li>
<li>Prime(質數基礎理論)</li>
<li>Modulus(取模運算)</li>
<li>Fast Power(快速冪運算)</li>
</ol>
<h2>Modulus - 取模運算</h2>
<p>有時計算結果可能會溢位，此時往往需要對結果取餘。如果有<code>a % m = c % m</code> 和 <code>b % m = d % m</code>, 那麼有以下模運算成立。</p>
<ul>
<li><code>(a + b) % m = (c + d) % m</code></li>
<li><code>(a - b) % m = (c - d) % m</code></li>
<li><code>(a × b) % m = (c × d) % m</code></li>
</ul>
<p>需要注意的是沒有除法運算，另外由於最終結果可能溢位，故需要使用更大範圍的類型來保存取模之前的結果。另外若<code>a</code>是負數時往往需要改寫爲 <code>a % m + m</code>, 這樣就保證結果在<code>[0, m - 1]</code>範圍內了。</p>
<h2>Fast Power - 快速冪運算</h2>
<p>快速冪運算的核心思想爲反覆平方法，將冪指數表示爲2的冪次的和，等價於二進制進行移位計算（不斷取冪的最低位），比如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mrow><mn>2</mn><mn>2</mn></mrow></msup><mo>=</mo><msup><mi>x</mi><mrow><mn>1</mn><mn>6</mn></mrow></msup><msup><mi>x</mi><mn>4</mn></msup><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x^{22} = x^{16}  x^4  x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span><span class="mord mathrm mtight">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">1</span><span class="mord mathrm mtight">6</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">4</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>.</p>
<h3>C++</h3>
<pre><code class="lang-C++">long long fastModPow(lont long x, int n, long long mod) {
    long long res = 1 % mod;
    while(n &gt; 0) {
        //if lowest bit is 1, fast judge of even number
        if((n &amp; 1) != 0)
            res = res * x % mod;
        x = x * x % mod;
        n &gt;&gt;= 1; 
    }
    return res;
}
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">import java.util.*;

public class FastPow {
    public static long fastModPow(long x, long n, long mod) {
        long res = 1 % mod;
        while (n &gt; 0) {
            // if lowest bit is 1
            if ((n &amp; 1) != 0) res = res * x % mod;
            x = x * x % mod;
            n &gt;&gt;= 1;
        }
        return res;
    }

    public static void main(String[] args) {
        if (args.length != 2 &amp;&amp; args.length != 3) return;

        long x = Long.parseLong(args[0]);
        long n = Long.parseLong(args[1]);
        long mod = Long.MAX_VALUE;
        if (args.length == 3) {
            mod = Long.parseLong(args[2]);
        }
        System.out.println(fastModPow(x, n, mod));
    }
}
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1>Math</h1>
<!-- toc -->
<ul>
<li><a href="#modulus---取模運算">Modulus - 取模運算</a></li>
<li><a href="#fast-power---快速冪運算">Fast Power - 快速冪運算</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>本小節總結一些與數學（尤其是數論部分）有關的基礎，主要總結了《挑戰程序設計競賽》(原文為《プログラミングコンテストチャレンジブック》)第二章。主要包含以下內容：</p>
<ol>
<li>Greatest Common Divisor(最大公因數)</li>
<li>Prime(質數基礎理論)</li>
<li>Modulus(取模運算)</li>
<li>Fast Power(快速冪運算)</li>
</ol>
<h2>Modulus - 取模運算</h2>
<p>有時計算結果可能會溢位，此時往往需要對結果取餘。如果有<code>a % m = c % m</code> 和 <code>b % m = d % m</code>, 那麼有以下模運算成立。</p>
<ul>
<li><code>(a + b) % m = (c + d) % m</code></li>
<li><code>(a - b) % m = (c - d) % m</code></li>
<li><code>(a × b) % m = (c × d) % m</code></li>
</ul>
<p>需要注意的是沒有除法運算，另外由於最終結果可能溢位，故需要使用更大範圍的類型來保存取模之前的結果。另外若<code>a</code>是負數時往往需要改寫爲 <code>a % m + m</code>, 這樣就保證結果在<code>[0, m - 1]</code>範圍內了。</p>
<h2>Fast Power - 快速冪運算</h2>
<p>快速冪運算的核心思想爲反覆平方法，將冪指數表示爲2的冪次的和，等價於二進制進行移位計算（不斷取冪的最低位），比如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mrow><mn>2</mn><mn>2</mn></mrow></msup><mo>=</mo><msup><mi>x</mi><mrow><mn>1</mn><mn>6</mn></mrow></msup><msup><mi>x</mi><mn>4</mn></msup><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x^{22} = x^{16}  x^4  x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span><span class="mord mathrm mtight">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">1</span><span class="mord mathrm mtight">6</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">4</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>.</p>
<h3>C++</h3>
<pre><code class="lang-C++">long long fastModPow(lont long x, int n, long long mod) {
    long long res = 1 % mod;
    while(n &gt; 0) {
        //if lowest bit is 1, fast judge of even number
        if((n &amp; 1) != 0)
            res = res * x % mod;
        x = x * x % mod;
        n &gt;&gt;= 1; 
    }
    return res;
}
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">import java.util.*;

public class FastPow {
    public static long fastModPow(long x, long n, long mod) {
        long res = 1 % mod;
        while (n &gt; 0) {
            // if lowest bit is 1
            if ((n &amp; 1) != 0) res = res * x % mod;
            x = x * x % mod;
            n &gt;&gt;= 1;
        }
        return res;
    }

    public static void main(String[] args) {
        if (args.length != 2 &amp;&amp; args.length != 3) return;

        long x = Long.parseLong(args[0]);
        long n = Long.parseLong(args[1]);
        long mod = Long.MAX_VALUE;
        if (args.length == 3) {
            mod = Long.parseLong(args[2]);
        }
        System.out.println(fastModPow(x, n, mod));
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Greatest Common Divisor]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_algorithm/math/gcd.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_algorithm/math/gcd.html">
        </link>
        <updated>2019-11-03T15:42:03Z</updated>
        <summary type="html"><![CDATA[<h1>Math</h1>
<!-- toc -->
<ul>
<li><a href="#最大公因數gcd-greatest-common-divisor">最大公因數(GCD, Greatest Common Divisor)</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#problem">Problem</a><ul>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#擴展歐幾里得算法">擴展歐幾里得算法</a><ul>
<li><a href="#java-1">Java</a></li>
<li><a href="#problem-1">Problem</a><ul>
<li><a href="#solution-1">Solution</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>本小節總結一些與數學（尤其是數論部分）有關的基礎，主要總結了《挑戰程序設計競賽》第二章。</p>
<h2>最大公因數(GCD, Greatest Common Divisor)</h2>
<p>常用的方法爲輾轉相除法，也稱爲歐幾里得算法。不妨設函數<code>gcd(a, b)</code>是自然是<code>a</code>, <code>b</code>的最大公因數，不妨設<code>a &gt; b</code>, 則有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mo>×</mo><mi>p</mi><mo>+</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">a = b \times p + q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mrel">=</span><span class="mord mathit">b</span><span class="mbin">×</span><span class="mord mathit">p</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.03588em;">q</span></span></span></span>, 那麼對於<code>gcd(b, q)</code>則是<code>b</code>和<code>q</code>的最大公因數，也就是說<code>gcd(b, q)</code>既能整除<code>b</code>, 又能整除<code>a</code>(因爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mo>×</mo><mi>p</mi><mo>+</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">a = b \times p + q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mrel">=</span><span class="mord mathit">b</span><span class="mbin">×</span><span class="mord mathit">p</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.03588em;">q</span></span></span></span>, <code>p</code>是整數)，如此反覆最後得到<code>gcd(a, b) = gcd(c, 0)</code>, 第二個數爲0時直接返回<code>c</code>. 如果最開始<code>a &lt; b</code>, 那麼<code>gcd(b, a % b) = gcd(b, a) = gcd(a, b % a)</code>.</p>
<p>關於時間複雜度的證明：可以分<code>a &gt; b/2</code>和<code>a &lt; b/2</code>證明，對數級別的時間複雜度，過程略。</p>
<p>與最大公因數相關的還有最小公倍數(LCM, Lowest Common Multiple), 它們兩者之間的關係爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>m</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>×</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>=</mo><mi mathvariant="normal">∣</mi><mi>a</mi><mi>b</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex"> lcm(a, b) \times gcd(a, b) = |ab|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">c</span><span class="mord mathit">m</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">c</span><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">∣</span><span class="mord mathit">a</span><span class="mord mathit">b</span><span class="mord mathrm">∣</span></span></span></span>.</p>
<h3>Java</h3>
<pre><code class="lang-java">public static long gcd(long a, long b) {
    return (b == 0) ? a : gcd(b, a % b);
}
</code></pre>
<h3>Problem</h3>
<p>給定平面上兩個座標 P1=(x1, y1), P2=(x2,y2), 問線段 P1P2 上除 P1, P2以外還有幾個整數座標點？</p>
<h4>Solution</h4>
<p>問的是線段 P1P2, 故除 P1,P2以外的座標需在 x1,x2,y1,y2範圍之內，且不包含端點。在兩端點不重合的前提下有：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>y</mi><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub></mrow><mrow><mi>x</mi><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><msub><mi>y</mi><mn>2</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub></mrow><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\frac{y-y_1}{x-x_1}=\frac{y_2 - y_1}{x_2 - x_1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.2603300000000002em;"></span><span class="strut bottom" style="height:2.09633em;vertical-align:-0.8360000000000001em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit">x</span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">−</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span>
那麼若得知 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">M = gcd(x_2 - x_1, y_2 - y_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">c</span><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>, 則有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x - x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span> 必爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><mi mathvariant="normal">/</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">x_2 - x_1 / M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.10903em;">M</span></span></span></span> 的整數倍大小，又因爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>&lt;</mo><mi>x</mi><mo>&lt;</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex"> x_1 &lt; x &lt; x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">&lt;</span><span class="mord mathit">x</span><span class="mrel">&lt;</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>, 故最多有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">M - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span>個整數座標點。</p>
<h2>擴展歐幾里得算法</h2>
<p>求解整係數 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span> 滿足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>=</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">d = gcd(a, b) = ax + by</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">c</span><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit">a</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathit">b</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>, 仿照歐幾里得算法，應該要尋找 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mo>)</mo><mo>=</mo><mi>b</mi><msup><mi>x</mi><mi mathvariant="normal">′</mi></msup><mo>+</mo><mo>(</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mo>)</mo><msup><mi>y</mi><mi mathvariant="normal">′</mi></msup></mrow><annotation encoding="application/x-tex">gcd(b, a \% b) = bx^\prime + (a \% b)y^\prime</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">c</span><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit">b</span><span class="mpunct">,</span><span class="mord mathit">a</span><span class="mord mathrm">%</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit">b</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mord mathrm">%</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>.</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    public static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    public static int[] gcdExt(int a, int b) {
        if (b == 0) {
            return new int[] {a, 1, 0};
        } else {
            int[] vals = gcdExt(b, a % b);
            int d = vals[0];
            int x = vals[2];
            int y = vals[1];
            y -= (a / b) * x;
            return new int[] {d, x, y};
        }
    }

    public static void main(String[] args) {
        int a = 4, b = 11;
        int[] result = gcdExt(a, b);
        System.out.printf(&quot;d = %d, x = %d, y = %d.\n&quot;, result[0], result[1], result[2]);
    }
}
</code></pre>
<h3>Problem</h3>
<p>求整數 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span> 使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ax+by=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathit">b</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mrel">=</span><span class="mord mathrm">1</span></span></span></span>.</p>
<h4>Solution</h4>
<p>不妨設<code>gcd(a, b) = M</code>, 那麼有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>(</mo><msup><mi>a</mi><mi mathvariant="normal">′</mi></msup><mi>x</mi><mo>+</mo><msup><mi>b</mi><mi mathvariant="normal">′</mi></msup><mi>y</mi><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">M(a^\prime x+b^\prime y)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">a</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">1</span></span></span></span> ==&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mi mathvariant="normal">′</mi></msup><mi>x</mi><mo>+</mo><msup><mi>b</mi><mi mathvariant="normal">′</mi></msup><mi>y</mi><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">a^\prime x+b^\prime y=1/M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">a</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.10903em;">M</span></span></span></span> 如果 M 大於1，由於等式左邊爲整數，故等式不成立，所以要想題中等式有解，必有<code>gcd(a, b) = 1</code>.</p>
<p><strong>擴展提：題中等式右邊爲1，假如爲2又會怎樣？</strong></p>
<p>提示：此時<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>=</mo><mi>k</mi><mo>⋅</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo separator="true">,</mo><msup><mi>x</mi><mi mathvariant="normal">′</mi></msup><mo>=</mo><mi>k</mi><mo>⋅</mo><mi>x</mi><mo>=</mo><mo>=</mo><mo>&gt;</mo><mi>c</mi><mtext> </mtext><mi mathvariant="normal">%</mi><mtext> </mtext><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>=</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c = k \cdot gcd(a, b), x^\prime = k\cdot x ==&gt; c\ \%\ gcd(a, b) == 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">⋅</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">c</span><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">⋅</span><span class="mord mathit">x</span><span class="mrel">=</span><span class="mrel">=</span><span class="mrel">&gt;</span><span class="mord mathit">c</span><span class="mord mathrm"><span class="mspace"> </span><span class="mord mathrm">%</span></span><span class="mord mathit"><span class="mspace"> </span><span class="mord mathit" style="margin-right:0.03588em;">g</span></span><span class="mord mathit">c</span><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mrel">=</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span>, c 爲等式右邊的正整數值。詳細推導見 <a href="http://math.stackexchange.com/questions/20717/how-to-find-solutions-of-linear-diophantine-ax-by-c">How to find solutions of linear Diophantine ax + by = c?</a></p>
]]></summary>
        <content type="html"><![CDATA[<h1>Math</h1>
<!-- toc -->
<ul>
<li><a href="#最大公因數gcd-greatest-common-divisor">最大公因數(GCD, Greatest Common Divisor)</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#problem">Problem</a><ul>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#擴展歐幾里得算法">擴展歐幾里得算法</a><ul>
<li><a href="#java-1">Java</a></li>
<li><a href="#problem-1">Problem</a><ul>
<li><a href="#solution-1">Solution</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>本小節總結一些與數學（尤其是數論部分）有關的基礎，主要總結了《挑戰程序設計競賽》第二章。</p>
<h2>最大公因數(GCD, Greatest Common Divisor)</h2>
<p>常用的方法爲輾轉相除法，也稱爲歐幾里得算法。不妨設函數<code>gcd(a, b)</code>是自然是<code>a</code>, <code>b</code>的最大公因數，不妨設<code>a &gt; b</code>, 則有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mo>×</mo><mi>p</mi><mo>+</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">a = b \times p + q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mrel">=</span><span class="mord mathit">b</span><span class="mbin">×</span><span class="mord mathit">p</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.03588em;">q</span></span></span></span>, 那麼對於<code>gcd(b, q)</code>則是<code>b</code>和<code>q</code>的最大公因數，也就是說<code>gcd(b, q)</code>既能整除<code>b</code>, 又能整除<code>a</code>(因爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mo>×</mo><mi>p</mi><mo>+</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">a = b \times p + q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mrel">=</span><span class="mord mathit">b</span><span class="mbin">×</span><span class="mord mathit">p</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.03588em;">q</span></span></span></span>, <code>p</code>是整數)，如此反覆最後得到<code>gcd(a, b) = gcd(c, 0)</code>, 第二個數爲0時直接返回<code>c</code>. 如果最開始<code>a &lt; b</code>, 那麼<code>gcd(b, a % b) = gcd(b, a) = gcd(a, b % a)</code>.</p>
<p>關於時間複雜度的證明：可以分<code>a &gt; b/2</code>和<code>a &lt; b/2</code>證明，對數級別的時間複雜度，過程略。</p>
<p>與最大公因數相關的還有最小公倍數(LCM, Lowest Common Multiple), 它們兩者之間的關係爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>m</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>×</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>=</mo><mi mathvariant="normal">∣</mi><mi>a</mi><mi>b</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex"> lcm(a, b) \times gcd(a, b) = |ab|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">c</span><span class="mord mathit">m</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">c</span><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">∣</span><span class="mord mathit">a</span><span class="mord mathit">b</span><span class="mord mathrm">∣</span></span></span></span>.</p>
<h3>Java</h3>
<pre><code class="lang-java">public static long gcd(long a, long b) {
    return (b == 0) ? a : gcd(b, a % b);
}
</code></pre>
<h3>Problem</h3>
<p>給定平面上兩個座標 P1=(x1, y1), P2=(x2,y2), 問線段 P1P2 上除 P1, P2以外還有幾個整數座標點？</p>
<h4>Solution</h4>
<p>問的是線段 P1P2, 故除 P1,P2以外的座標需在 x1,x2,y1,y2範圍之內，且不包含端點。在兩端點不重合的前提下有：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>y</mi><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub></mrow><mrow><mi>x</mi><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><msub><mi>y</mi><mn>2</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub></mrow><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\frac{y-y_1}{x-x_1}=\frac{y_2 - y_1}{x_2 - x_1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.2603300000000002em;"></span><span class="strut bottom" style="height:2.09633em;vertical-align:-0.8360000000000001em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathit">x</span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">−</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span>
那麼若得知 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">M = gcd(x_2 - x_1, y_2 - y_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">c</span><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>, 則有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x - x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span> 必爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><mi mathvariant="normal">/</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">x_2 - x_1 / M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.10903em;">M</span></span></span></span> 的整數倍大小，又因爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>&lt;</mo><mi>x</mi><mo>&lt;</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex"> x_1 &lt; x &lt; x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">&lt;</span><span class="mord mathit">x</span><span class="mrel">&lt;</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>, 故最多有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">M - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span>個整數座標點。</p>
<h2>擴展歐幾里得算法</h2>
<p>求解整係數 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span> 滿足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>=</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">d = gcd(a, b) = ax + by</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">c</span><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit">a</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathit">b</span><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span>, 仿照歐幾里得算法，應該要尋找 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mo>)</mo><mo>=</mo><mi>b</mi><msup><mi>x</mi><mi mathvariant="normal">′</mi></msup><mo>+</mo><mo>(</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mo>)</mo><msup><mi>y</mi><mi mathvariant="normal">′</mi></msup></mrow><annotation encoding="application/x-tex">gcd(b, a \% b) = bx^\prime + (a \% b)y^\prime</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">c</span><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit">b</span><span class="mpunct">,</span><span class="mord mathit">a</span><span class="mord mathrm">%</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit">b</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mord mathrm">%</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>.</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    public static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    public static int[] gcdExt(int a, int b) {
        if (b == 0) {
            return new int[] {a, 1, 0};
        } else {
            int[] vals = gcdExt(b, a % b);
            int d = vals[0];
            int x = vals[2];
            int y = vals[1];
            y -= (a / b) * x;
            return new int[] {d, x, y};
        }
    }

    public static void main(String[] args) {
        int a = 4, b = 11;
        int[] result = gcdExt(a, b);
        System.out.printf(&quot;d = %d, x = %d, y = %d.\n&quot;, result[0], result[1], result[2]);
    }
}
</code></pre>
<h3>Problem</h3>
<p>求整數 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span></span></span></span> 使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ax+by=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">a</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathit">b</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mrel">=</span><span class="mord mathrm">1</span></span></span></span>.</p>
<h4>Solution</h4>
<p>不妨設<code>gcd(a, b) = M</code>, 那麼有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>(</mo><msup><mi>a</mi><mi mathvariant="normal">′</mi></msup><mi>x</mi><mo>+</mo><msup><mi>b</mi><mi mathvariant="normal">′</mi></msup><mi>y</mi><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">M(a^\prime x+b^\prime y)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">a</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">1</span></span></span></span> ==&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mi mathvariant="normal">′</mi></msup><mi>x</mi><mo>+</mo><msup><mi>b</mi><mi mathvariant="normal">′</mi></msup><mi>y</mi><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">a^\prime x+b^\prime y=1/M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">a</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">b</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathit" style="margin-right:0.10903em;">M</span></span></span></span> 如果 M 大於1，由於等式左邊爲整數，故等式不成立，所以要想題中等式有解，必有<code>gcd(a, b) = 1</code>.</p>
<p><strong>擴展提：題中等式右邊爲1，假如爲2又會怎樣？</strong></p>
<p>提示：此時<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>=</mo><mi>k</mi><mo>⋅</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo separator="true">,</mo><msup><mi>x</mi><mi mathvariant="normal">′</mi></msup><mo>=</mo><mi>k</mi><mo>⋅</mo><mi>x</mi><mo>=</mo><mo>=</mo><mo>&gt;</mo><mi>c</mi><mtext> </mtext><mi mathvariant="normal">%</mi><mtext> </mtext><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>=</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c = k \cdot gcd(a, b), x^\prime = k\cdot x ==&gt; c\ \%\ gcd(a, b) == 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">⋅</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">c</span><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">⋅</span><span class="mord mathit">x</span><span class="mrel">=</span><span class="mrel">=</span><span class="mrel">&gt;</span><span class="mord mathit">c</span><span class="mord mathrm"><span class="mspace"> </span><span class="mord mathrm">%</span></span><span class="mord mathit"><span class="mspace"> </span><span class="mord mathit" style="margin-right:0.03588em;">g</span></span><span class="mord mathit">c</span><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mclose">)</span><span class="mrel">=</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span>, c 爲等式右邊的正整數值。詳細推導見 <a href="http://math.stackexchange.com/questions/20717/how-to-find-solutions-of-linear-diophantine-ax-by-c">How to find solutions of linear Diophantine ax + by = c?</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Prime]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_algorithm/math/prime.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_algorithm/math/prime.html">
        </link>
        <updated>2019-11-03T15:42:04Z</updated>
        <summary type="html"><![CDATA[<h1>Prime</h1>
<!-- toc -->
<ul>
<li><a href="#質數測試">質數測試</a></li>
<li><a href="#埃氏篩法-sieve-of-eratosthenes">埃氏篩法 Sieve of Eratosthenes</a></li>
<li><a href="#區間篩法">區間篩法</a></li>
<li><a href="#implementation">Implementation</a><ul>
<li><a href="#java">Java</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>質數：恰好有兩個因數的整數，一個是1，另一個則是它自己，比如整數3和5就是質數。質數的基本算法有<strong>素性測試、埃氏篩法和整數分解。</strong></p>
<h2>質數測試</h2>
<p>如果<code>d</code>是<code>n</code>的因數，則易知 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mi>d</mi><mo>⋅</mo><mfrac><mrow><mi>n</mi></mrow><mrow><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">n = d \cdot \frac{n}{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.695392em;"></span><span class="strut bottom" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mrel">=</span><span class="mord mathit">d</span><span class="mbin">⋅</span><span class="mord reset-textstyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>, 因此 <code>n/d</code>也是<code>n</code>的因數，且這兩個因數中的較小者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>(</mo><mi>d</mi><mo separator="true">,</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>)</mo><mo>&lt;</mo><mo>=</mo><msqrt><mrow><mi>n</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">\min(d, n/d) &lt;= \sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8002800000000001em;"></span><span class="strut bottom" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mop">min</span><span class="mopen">(</span><span class="mord mathit">d</span><span class="mpunct">,</span><span class="mord mathit">n</span><span class="mord mathrm">/</span><span class="mord mathit">d</span><span class="mclose">)</span><span class="mrel">&lt;</span><span class="mrel">=</span><span class="mord sqrt"><span class="sqrt-sign" style="top:0.03971999999999998em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">n</span></span></span><span style="top:-0.72028em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span></span></span></span>. 因此我們只需要對前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mrow><mi>n</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8002800000000001em;"></span><span class="strut bottom" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="base textstyle uncramped"><span class="mord sqrt"><span class="sqrt-sign" style="top:0.03971999999999998em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">n</span></span></span><span style="top:-0.72028em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span></span></span></span> 個數進行處理。</p>
<h2>埃氏篩法 Sieve of Eratosthenes</h2>
<p>質數測試針對的是單個整數，如果需要枚舉整數<code>n</code>以內的質數就需要埃氏篩法了。核心思想是枚舉從小到大的質數並將質數的整數倍依次從原整數數組中刪除，餘下的即爲全部質數。</p>
<h2>區間篩法</h2>
<p>求區間<code>[a, b)</code>內有多少質數？</p>
<p>埃氏篩法得到的是<code>[1, n)</code>內的質數，求區間質數時不太容易直接求解，我們採取以退爲進的思路先用埃氏篩法求得<code>[1, b)</code>內的質數，然後截取爲<code>[a, b)</code>即可。</p>
<h2>Implementation</h2>
<h3>Java</h3>
<pre><code class="lang-java">import java.util.*;

public class Prime {
    // test if n is prime
    public static boolean isPrime(int n) {
        for (int i = 2; i * i &lt;= n; i++) {
            if (n % i == 0) return false;
        }
        return n != 1; // 1 is not prime
    }

    // enumerate all the divisor for n
    public static List&lt;Integer&gt; getDivisor(int n) {
        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        for (int i = 1; i * i &lt;= n; i++) {
            if (n % i == 0) {
                result.add(i);
                // i * i &lt;= n ==&gt; i &lt;= n / i
                if (i != n / i) result.add(n / i);
            }
        }
        Collections.sort(result);
        return result;
    }

    // 12 = 2 * 2 * 3, the number of prime factor, small to big
    public static Map&lt;Integer, Integer&gt; getPrimeFactor(int n) {
        Map&lt;Integer, Integer&gt; result = new HashMap&lt;Integer, Integer&gt;();
        for (int i = 2; i * i &lt;= n; i++) {
            // if i is a factor of n, repeatedly divide it out
            while (n % i == 0) {
                if (result.containsKey(i)) {
                    result.put(i, result.get(i) + 1);
                } else {
                    result.put(i, 1);
                }
                n = n / i;
            }
        }
        // if n is not 1 at last
        if (n != 1) result.put(n, 1);
        return result;
    }

    // sieve all the prime factor less equal than n
    public static List&lt;Integer&gt; sieve(int n) {
        List&lt;Integer&gt; prime = new ArrayList&lt;Integer&gt;();
        // flag if i is prime
        boolean[] isPrime = new boolean[n + 1];
        Arrays.fill(isPrime, true);
        isPrime[0] = false;
        isPrime[1] = false;
        for (int i = 2; i &lt;= n; i++) {
            if (isPrime[i]) {
                prime.add(i);
                for (int j = 2 * i; j &lt;= n; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        return prime;
    }

    // sieve between [a, b)
    public static List&lt;Integer&gt; sieveSegment(int a, int b) {
        List&lt;Integer&gt; prime = new ArrayList&lt;Integer&gt;();
        boolean[] isPrime = new boolean[b];
        Arrays.fill(isPrime, true);
        isPrime[0] = false;
        isPrime[1] = false;
        for (int i = 2; i &lt; b; i++) {
            if (isPrime(i)) {
                for (int j = 2 * i; j &lt; b; j += i) isPrime[j] = false;
                if (i &gt;= a) prime.add(i);
            }
        }
        return prime;
    }

    public static void main(String[] args) {
        if (args.length == 1) {
            int n = Integer.parseInt(args[0]);
            if (isPrime(n)) {
                System.out.println(&quot;Integer &quot; + n + &quot; is prime.&quot;);
            } else {
                System.out.println(&quot;Integer &quot; + n + &quot; is not prime.&quot;);
            }
            System.out.println();

            List&lt;Integer&gt; divisor = getDivisor(n);
            System.out.print(&quot;Divisor of integer &quot; + n + &quot;:&quot;);
            for (int d : divisor) System.out.print(&quot; &quot; + d);
            System.out.println();
            System.out.println();

            Map&lt;Integer, Integer&gt; primeFactor = getPrimeFactor(n);
            System.out.println(&quot;Prime factor of integer &quot; + n + &quot;:&quot;);
            for (Map.Entry&lt;Integer, Integer&gt; entry : primeFactor.entrySet()) {
                System.out.println(&quot;prime: &quot; + entry.getKey() + &quot;, times: &quot; + entry.getValue());
            }

            System.out.print(&quot;Sieve prime of integer &quot; + n + &quot;:&quot;);
            List&lt;Integer&gt; sievePrime = sieve(n);
            for (int i : sievePrime) System.out.print(&quot; &quot; + i);
            System.out.println();
        } else if (args.length == 2) {
            int a = Integer.parseInt(args[0]);
            int b = Integer.parseInt(args[1]);
            List&lt;Integer&gt; primeSegment = sieveSegment(a, b);
            System.out.println(&quot;Prime of integer &quot; + a + &quot; to &quot; + b + &quot;:&quot;);
            for (int i : primeSegment) System.out.print(&quot; &quot; + i);
            System.out.println();
        }
    }
}
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1>Prime</h1>
<!-- toc -->
<ul>
<li><a href="#質數測試">質數測試</a></li>
<li><a href="#埃氏篩法-sieve-of-eratosthenes">埃氏篩法 Sieve of Eratosthenes</a></li>
<li><a href="#區間篩法">區間篩法</a></li>
<li><a href="#implementation">Implementation</a><ul>
<li><a href="#java">Java</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>質數：恰好有兩個因數的整數，一個是1，另一個則是它自己，比如整數3和5就是質數。質數的基本算法有<strong>素性測試、埃氏篩法和整數分解。</strong></p>
<h2>質數測試</h2>
<p>如果<code>d</code>是<code>n</code>的因數，則易知 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mi>d</mi><mo>⋅</mo><mfrac><mrow><mi>n</mi></mrow><mrow><mi>d</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">n = d \cdot \frac{n}{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.695392em;"></span><span class="strut bottom" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mrel">=</span><span class="mord mathit">d</span><span class="mbin">⋅</span><span class="mord reset-textstyle textstyle uncramped"><span class="mopen sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">d</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>, 因此 <code>n/d</code>也是<code>n</code>的因數，且這兩個因數中的較小者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>(</mo><mi>d</mi><mo separator="true">,</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>)</mo><mo>&lt;</mo><mo>=</mo><msqrt><mrow><mi>n</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">\min(d, n/d) &lt;= \sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8002800000000001em;"></span><span class="strut bottom" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mop">min</span><span class="mopen">(</span><span class="mord mathit">d</span><span class="mpunct">,</span><span class="mord mathit">n</span><span class="mord mathrm">/</span><span class="mord mathit">d</span><span class="mclose">)</span><span class="mrel">&lt;</span><span class="mrel">=</span><span class="mord sqrt"><span class="sqrt-sign" style="top:0.03971999999999998em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">n</span></span></span><span style="top:-0.72028em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span></span></span></span>. 因此我們只需要對前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mrow><mi>n</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8002800000000001em;"></span><span class="strut bottom" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="base textstyle uncramped"><span class="mord sqrt"><span class="sqrt-sign" style="top:0.03971999999999998em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">n</span></span></span><span style="top:-0.72028em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span></span></span></span> 個數進行處理。</p>
<h2>埃氏篩法 Sieve of Eratosthenes</h2>
<p>質數測試針對的是單個整數，如果需要枚舉整數<code>n</code>以內的質數就需要埃氏篩法了。核心思想是枚舉從小到大的質數並將質數的整數倍依次從原整數數組中刪除，餘下的即爲全部質數。</p>
<h2>區間篩法</h2>
<p>求區間<code>[a, b)</code>內有多少質數？</p>
<p>埃氏篩法得到的是<code>[1, n)</code>內的質數，求區間質數時不太容易直接求解，我們採取以退爲進的思路先用埃氏篩法求得<code>[1, b)</code>內的質數，然後截取爲<code>[a, b)</code>即可。</p>
<h2>Implementation</h2>
<h3>Java</h3>
<pre><code class="lang-java">import java.util.*;

public class Prime {
    // test if n is prime
    public static boolean isPrime(int n) {
        for (int i = 2; i * i &lt;= n; i++) {
            if (n % i == 0) return false;
        }
        return n != 1; // 1 is not prime
    }

    // enumerate all the divisor for n
    public static List&lt;Integer&gt; getDivisor(int n) {
        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        for (int i = 1; i * i &lt;= n; i++) {
            if (n % i == 0) {
                result.add(i);
                // i * i &lt;= n ==&gt; i &lt;= n / i
                if (i != n / i) result.add(n / i);
            }
        }
        Collections.sort(result);
        return result;
    }

    // 12 = 2 * 2 * 3, the number of prime factor, small to big
    public static Map&lt;Integer, Integer&gt; getPrimeFactor(int n) {
        Map&lt;Integer, Integer&gt; result = new HashMap&lt;Integer, Integer&gt;();
        for (int i = 2; i * i &lt;= n; i++) {
            // if i is a factor of n, repeatedly divide it out
            while (n % i == 0) {
                if (result.containsKey(i)) {
                    result.put(i, result.get(i) + 1);
                } else {
                    result.put(i, 1);
                }
                n = n / i;
            }
        }
        // if n is not 1 at last
        if (n != 1) result.put(n, 1);
        return result;
    }

    // sieve all the prime factor less equal than n
    public static List&lt;Integer&gt; sieve(int n) {
        List&lt;Integer&gt; prime = new ArrayList&lt;Integer&gt;();
        // flag if i is prime
        boolean[] isPrime = new boolean[n + 1];
        Arrays.fill(isPrime, true);
        isPrime[0] = false;
        isPrime[1] = false;
        for (int i = 2; i &lt;= n; i++) {
            if (isPrime[i]) {
                prime.add(i);
                for (int j = 2 * i; j &lt;= n; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        return prime;
    }

    // sieve between [a, b)
    public static List&lt;Integer&gt; sieveSegment(int a, int b) {
        List&lt;Integer&gt; prime = new ArrayList&lt;Integer&gt;();
        boolean[] isPrime = new boolean[b];
        Arrays.fill(isPrime, true);
        isPrime[0] = false;
        isPrime[1] = false;
        for (int i = 2; i &lt; b; i++) {
            if (isPrime(i)) {
                for (int j = 2 * i; j &lt; b; j += i) isPrime[j] = false;
                if (i &gt;= a) prime.add(i);
            }
        }
        return prime;
    }

    public static void main(String[] args) {
        if (args.length == 1) {
            int n = Integer.parseInt(args[0]);
            if (isPrime(n)) {
                System.out.println(&quot;Integer &quot; + n + &quot; is prime.&quot;);
            } else {
                System.out.println(&quot;Integer &quot; + n + &quot; is not prime.&quot;);
            }
            System.out.println();

            List&lt;Integer&gt; divisor = getDivisor(n);
            System.out.print(&quot;Divisor of integer &quot; + n + &quot;:&quot;);
            for (int d : divisor) System.out.print(&quot; &quot; + d);
            System.out.println();
            System.out.println();

            Map&lt;Integer, Integer&gt; primeFactor = getPrimeFactor(n);
            System.out.println(&quot;Prime factor of integer &quot; + n + &quot;:&quot;);
            for (Map.Entry&lt;Integer, Integer&gt; entry : primeFactor.entrySet()) {
                System.out.println(&quot;prime: &quot; + entry.getKey() + &quot;, times: &quot; + entry.getValue());
            }

            System.out.print(&quot;Sieve prime of integer &quot; + n + &quot;:&quot;);
            List&lt;Integer&gt; sievePrime = sieve(n);
            for (int i : sievePrime) System.out.print(&quot; &quot; + i);
            System.out.println();
        } else if (args.length == 2) {
            int a = Integer.parseInt(args[0]);
            int b = Integer.parseInt(args[1]);
            List&lt;Integer&gt; primeSegment = sieveSegment(a, b);
            System.out.println(&quot;Prime of integer &quot; + a + &quot; to &quot; + b + &quot;:&quot;);
            for (int i : primeSegment) System.out.print(&quot; &quot; + i);
            System.out.println();
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Probability]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_algorithm/probability/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_algorithm/probability/">
        </link>
        <updated>2019-11-03T15:42:04Z</updated>
        <summary type="html"><![CDATA[<h1>Probability</h1>
]]></summary>
        <content type="html"><![CDATA[<h1>Probability</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Shuffle]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_algorithm/probability/shuffle.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_algorithm/probability/shuffle.html">
        </link>
        <updated>2019-11-03T15:42:04Z</updated>
        <summary type="html"><![CDATA[<h1>Shuffle and Sampling - 隨機抽樣和洗牌</h1>
<!-- toc -->
<ul>
<li><a href="#洗牌算法">洗牌算法</a><ul>
<li><a href="#題解">題解</a></li>
</ul>
</li>
<li><a href="#random-sampling---隨機抽樣">Random sampling - 隨機抽樣</a><ul>
<li><a href="#題解-1">題解</a></li>
</ul>
</li>
<li><a href="#implementation-and-test-case">Implementation and Test case</a><ul>
<li><a href="#java">Java</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>洗牌算法</h2>
<ul>
<li><a href="http://www.geeksforgeeks.org/shuffle-a-given-array/">Shuffle a given array - GeeksforGeeks</a></li>
</ul>
<p>Given an array, write a program to generate a random permutation of array elements. This question is also asked as “shuffle a deck of cards” or “randomize a given array”.</p>
<h3>題解</h3>
<p>這裡以 Fisher–Yates shuffle 演算法爲例，僞代碼如下：</p>
<pre><code>To shuffle an array a of n elements (indices 0..n-1):
  for i from 0 downto i do
       j ← random integer such that 0 ≤ j ≤ i
       exchange a[j] and a[i]
</code></pre><p>轉化爲代碼爲：</p>
<pre><code class="lang-java">    /*
     * shuffle cards
     */
    public static void shuffleCard(int[] cards) {
        if (cards == null || cards.length == 0) return;

        Random rand = new Random();
        for (int i = 0; i &lt; cards.length; i++) {
            int k = rand.nextInt(i + 1); // 0~i (inclusive)
            int temp = cards[i];
            cards[i] = cards[k];
            cards[k] = temp;
        }
    }
</code></pre>
<p>看了算法和代碼後讓我們來使用歸納法簡單證明下這個洗牌算法的正確性。我們要證明的問題是：<strong>數組中每個元素在每個索引處出現的機率均相等。</strong></p>
<p>對於單個元素來講，以上算法顯然正確，因爲交換後仍然只有一個元素。接下來我們不妨假設其遍歷到數組索引爲<code>i-1</code>時滿足隨機排列特性，那麼當遍歷到數組索引爲<code>i</code>時，隨機數<code>k</code>爲<code>i</code>的機率爲<code>1/i</code>, 爲<code>0~i-1</code>的機率爲<code>(i-1)/i</code>. 接下來與索引爲<code>i</code>的值交換，可以得知<code>card[i]</code>出現在索引<code>i</code>的位置的機率爲<code>1/i</code>, 在其他索引位置的機率也爲<code>1/i</code>; 而對於<code>card[i]</code>之前的元素，以索引<code>j</code>處的元素<code>card[j]</code>爲例進行分析可知其在位置<code>j</code>的機率爲<code>1/(i-1) * (i-1)/i = 1/i</code>, 具體含義爲遍歷到索引<code>i-1</code>時<code>card[j]</code>位於索引<code>j</code>的機率(<code>1/(i-1)</code>)乘以遍歷到索引<code>i</code>時隨機數未選擇與索引<code>j</code>的數進行交換的機率(<code>(i-1)/i</code>).</p>
<p>需要注意的是前面的<code>j &lt;= i-1</code>, 那麼<code>card[j]</code>位於索引<code>i</code>的機率又是多少呢？要位於索引<code>i</code>，則隨機數<code>k</code>須爲<code>i</code>, 這種機率爲<code>1/i</code>.</p>
<p>綜上，以上算法可以實現完美洗牌（等機率）。</p>
<h2>Random sampling - 隨機抽樣</h2>
<p>隨機抽樣也稱爲水池抽樣，Randomly choosing a sample of k items from a list S containing n items. 大意是從大小爲 n 的數組中隨機選出 m 個整數，要求每個元素被選中的機率相同。</p>
<h3>題解</h3>
<p>比較簡潔的有算法 Algorithm R, 僞代碼如下：</p>
<pre><code>/*
  S has items to sample, R will contain the result
*/
ReservoirSample(S[1..n], R[1..k])
  // fill the reservoir array
  for i = 1 to k
      R[i] := S[i]

  // replace elements with gradually decreasing probability
  for i = k+1 to n
    j := random(1, i)   // important: inclusive range
    if j &lt;= k
        R[j] := S[i]
</code></pre><p>轉化爲代碼爲：</p>
<pre><code class="lang-java">    /*
     * random sample
     */
    public static int[] randomSample(int[] nums, int m) {
        if (nums == null || nums.length == 0 || m &lt;= 0) return new int[]{};

        int[] sample = new int[m];
        for (int i = 0; i &lt; m; i++) {
            sample[i] = nums[i];
        }

        Random random = new Random();
        for (int i = m; i &lt; nums.length; i++) {
            int k = random.nextInt(i + 1); // 0~i(inclusive)
            if (k &lt; m) {
                sample[k] = nums[i];
            }
        }

        return sample;
    }
</code></pre>
<p>和洗牌算法類似，我們要證明的問題是：<strong>數組中每個元素在最終採樣的數組中出現的機率均相等且爲<code>m/n</code>.</strong> 洗牌算法中是排列，而對於隨機抽樣則爲組合。</p>
<p>維基百科上的證明相對容易懂一些，這裏我稍微複述下。首先將數組前 m 個元素填充進新數組<code>sample</code>, 然後從<code>m</code>開始遍歷直至數組最後一個索引。隨機數<code>k</code>的範圍爲<code>0~i</code>, 如果<code>k &lt; m</code>，新數組的索引爲 k 的元素則和原數組索引爲<code>i</code>的元素交換；如果<code>k &gt;= m</code>, 則不進行交換。<code>i == m</code>時，以原數組中第<code>j</code>個元素爲例，它被<code>nums[m]</code>替換的機率爲<code>1/(m+1)</code>, 也就是說保留在<code>sample</code>數組中的機率爲<code>m/(m+1)</code>. 對與第<code>m+1</code>個元素<code>nums[m]</code>來說，其位於<code>sample</code>數組中的機率則爲<code>m*1/(m+1)</code>(可替換 m 個不同的元素).</p>
<p>接下來仍然使用數學歸納法證明，若<code>i</code>遍歷到<code>r</code>時，其之前的元素出現的機率爲<code>m/(r-1)</code>, 那麼其之前的元素中任一元素<code>nums[j]</code>被替換的機率爲<code>m/r * 1/m = 1/r</code>, 不被替換的機率則爲<code>(r-1)/r</code>. 故元素<code>nums[j]</code>在<code>i</code>遍歷完<code>r</code>後仍然保留的機率爲<code>m/(r-1) * (r-1)/r = m/r</code>. 而對於元素<code>nums[r]</code>來說，其要被替換至<code>sample</code>數組中的機率則爲<code>m/r</code>(隨機數小於m 的個數爲 m).</p>
<p>綜上，以上算法在遍歷完長度爲 n 的數組後每個數出現在最終<code>sample</code>數組中的機率都爲<code>m/n</code>.</p>
<h2>Implementation and Test case</h2>
<p><strong>Talk is cheap, show me the code!</strong></p>
<h3>Java</h3>
<pre><code class="lang-java">import java.util.*;
import java.util.Random;

public class Probability {
    public static void main(String[] args) {
        int[] cards = new int[10];
        for (int i = 0; i &lt; 10; i++) {
            cards[i] = i;
        }
        // 100000 times test
        final int times = 100000;
        final int m = 5;
        int[][] count = new int[cards.length][cards.length];
        int[][] count2 = new int[cards.length][m];
        for (int i = 0; i &lt; times; i++) {
            shuffleCard(cards);
            shuffleTest(cards, count);
            int[] sample = randomSample(cards, m);
            shuffleTest(sample, count2);
        }
        System.out.println(&quot;Shuffle cards&quot;);
        shufflePrint(count);
        System.out.println();
        System.out.println(&quot;Random sample&quot;);
        shufflePrint(count2);
    }

    /*
     * shuffle cards
     */
    public static void shuffleCard(int[] cards) {
        if (cards == null || cards.length == 0) return;

        Random rand = new Random();
        for (int i = 0; i &lt; cards.length; i++) {
            int k = rand.nextInt(i + 1);
            int temp = cards[i];
            cards[i] = cards[k];
            cards[k] = temp;
        }
    }

    /*
     * random sample
     */
    public static int[] randomSample(int[] nums, int m) {
        if (nums == null || nums.length == 0 || m &lt;= 0) return new int[]{};

        m = Math.min(m, nums.length);
        int[] sample = new int[m];
        for (int i = 0; i &lt; m; i++) {
            sample[i] = nums[i];
        }

        Random random = new Random();
        for (int i = m; i &lt; nums.length; i++) {
            int k = random.nextInt(i + 1);
            if (k &lt; m) {
                sample[k] = nums[i];
            }
        }

        return sample;
    }

    /*
     * nums[i] = j, num j appear in index i ==&gt; count[j][i]
     */
    public static void shuffleTest(int[] nums, int[][] count) {
        if (nums == null || nums.length == 0) return;

        for (int i = 0; i &lt; nums.length; i++) {
            count[nums[i]][i]++;
        }
    }

    /*
     * print shuffle test
     */
    public static void shufflePrint(int[][] count) {
        if (count == null || count.length == 0) return;

        // print index
        System.out.print(&quot;   &quot;);
        for (int i = 0; i &lt; count[0].length; i++) {
            System.out.printf(&quot;%-7d&quot;, i);
        }
        System.out.println();
        // print num appear in index i in total
        for (int i = 0; i &lt; count.length; i++) {
            System.out.print(i + &quot;: &quot;);
            for (int j = 0; j &lt; count[i].length; j++) {
                System.out.printf(&quot;%-7d&quot;, count[i][j]);
            }
            System.out.println();
        }
    }
}
</code></pre>
<p>以十萬次試驗爲例，左側是元素<code>i</code>, 列代表在相應索引位置出現的次數。可以看出分佈還是比較隨機的。</p>
<pre><code>Shuffle cards
   0      1      2      3      4      5      6      7      8      9
0: 10033  9963   10043  9845   9932   10020  9964   10114  10043  10043
1: 9907   9951   9989   10071  10059  9966   10054  10023  10015  9965
2: 10042  10046  9893   10080  10050  9994   10024  9852   10098  9921
3: 10039  10023  10039  10024  9919   10057  10188  9916   9907   9888
4: 9944   9913   10196  10059  9838   10205  9899   9945   9850   10151
5: 10094  9971   10054  9958   10022  9922   10047  9978   9965   9989
6: 9995   10147  9824   10015  10023  9804   10050  10192  9939   10011
7: 9941   10131  9902   9920   10040  10121  10010  9928   9984   10023
8: 10010  9926   9883   10098  10083  10028  9801   9936   10200  10035
9: 9995   9929   10177  9930   10034  9883   9963   10116  9999   9974

Random sample
   0      1      2      3      4
0: 9966   10026  10078  9966   9891
1: 9958   9806   10066  10022  10039
2: 9923   9936   9964   10051  10083
3: 10165  10088  10184  9928   9916
4: 9998   9990   9973   9931   9832
5: 10026  9932   9873   10085  10035
6: 9942   9972   9990   10030  10026
7: 9903   10153  9997   10051  10044
8: 10082  10066  9804   9899   10147
9: 10037  10031  10071  10037  9987
</code></pre><h2>Reference</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm">Fisher–Yates shuffle</a> - 洗牌算法的詳述，比較簡潔的演算法</li>
<li><a href="https://en.wikipedia.org/wiki/Reservoir_sampling">Reservoir sampling </a> - 水池抽樣算法</li>
<li><a href="http://coolshell.cn/articles/8593.html">如何測試洗牌程序 | 酷 殼 - CoolShell.cn</a> - 借鑑了其中的一些測試方法</li>
<li>《計算機程序設計藝術》第二卷（半數值算法） - 3.4.2 隨機抽樣和洗牌</li>
<li>《編程珠璣》第十二章 - 抽樣問題</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Shuffle and Sampling - 隨機抽樣和洗牌</h1>
<!-- toc -->
<ul>
<li><a href="#洗牌算法">洗牌算法</a><ul>
<li><a href="#題解">題解</a></li>
</ul>
</li>
<li><a href="#random-sampling---隨機抽樣">Random sampling - 隨機抽樣</a><ul>
<li><a href="#題解-1">題解</a></li>
</ul>
</li>
<li><a href="#implementation-and-test-case">Implementation and Test case</a><ul>
<li><a href="#java">Java</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>洗牌算法</h2>
<ul>
<li><a href="http://www.geeksforgeeks.org/shuffle-a-given-array/">Shuffle a given array - GeeksforGeeks</a></li>
</ul>
<p>Given an array, write a program to generate a random permutation of array elements. This question is also asked as “shuffle a deck of cards” or “randomize a given array”.</p>
<h3>題解</h3>
<p>這裡以 Fisher–Yates shuffle 演算法爲例，僞代碼如下：</p>
<pre><code>To shuffle an array a of n elements (indices 0..n-1):
  for i from 0 downto i do
       j ← random integer such that 0 ≤ j ≤ i
       exchange a[j] and a[i]
</code></pre><p>轉化爲代碼爲：</p>
<pre><code class="lang-java">    /*
     * shuffle cards
     */
    public static void shuffleCard(int[] cards) {
        if (cards == null || cards.length == 0) return;

        Random rand = new Random();
        for (int i = 0; i &lt; cards.length; i++) {
            int k = rand.nextInt(i + 1); // 0~i (inclusive)
            int temp = cards[i];
            cards[i] = cards[k];
            cards[k] = temp;
        }
    }
</code></pre>
<p>看了算法和代碼後讓我們來使用歸納法簡單證明下這個洗牌算法的正確性。我們要證明的問題是：<strong>數組中每個元素在每個索引處出現的機率均相等。</strong></p>
<p>對於單個元素來講，以上算法顯然正確，因爲交換後仍然只有一個元素。接下來我們不妨假設其遍歷到數組索引爲<code>i-1</code>時滿足隨機排列特性，那麼當遍歷到數組索引爲<code>i</code>時，隨機數<code>k</code>爲<code>i</code>的機率爲<code>1/i</code>, 爲<code>0~i-1</code>的機率爲<code>(i-1)/i</code>. 接下來與索引爲<code>i</code>的值交換，可以得知<code>card[i]</code>出現在索引<code>i</code>的位置的機率爲<code>1/i</code>, 在其他索引位置的機率也爲<code>1/i</code>; 而對於<code>card[i]</code>之前的元素，以索引<code>j</code>處的元素<code>card[j]</code>爲例進行分析可知其在位置<code>j</code>的機率爲<code>1/(i-1) * (i-1)/i = 1/i</code>, 具體含義爲遍歷到索引<code>i-1</code>時<code>card[j]</code>位於索引<code>j</code>的機率(<code>1/(i-1)</code>)乘以遍歷到索引<code>i</code>時隨機數未選擇與索引<code>j</code>的數進行交換的機率(<code>(i-1)/i</code>).</p>
<p>需要注意的是前面的<code>j &lt;= i-1</code>, 那麼<code>card[j]</code>位於索引<code>i</code>的機率又是多少呢？要位於索引<code>i</code>，則隨機數<code>k</code>須爲<code>i</code>, 這種機率爲<code>1/i</code>.</p>
<p>綜上，以上算法可以實現完美洗牌（等機率）。</p>
<h2>Random sampling - 隨機抽樣</h2>
<p>隨機抽樣也稱爲水池抽樣，Randomly choosing a sample of k items from a list S containing n items. 大意是從大小爲 n 的數組中隨機選出 m 個整數，要求每個元素被選中的機率相同。</p>
<h3>題解</h3>
<p>比較簡潔的有算法 Algorithm R, 僞代碼如下：</p>
<pre><code>/*
  S has items to sample, R will contain the result
*/
ReservoirSample(S[1..n], R[1..k])
  // fill the reservoir array
  for i = 1 to k
      R[i] := S[i]

  // replace elements with gradually decreasing probability
  for i = k+1 to n
    j := random(1, i)   // important: inclusive range
    if j &lt;= k
        R[j] := S[i]
</code></pre><p>轉化爲代碼爲：</p>
<pre><code class="lang-java">    /*
     * random sample
     */
    public static int[] randomSample(int[] nums, int m) {
        if (nums == null || nums.length == 0 || m &lt;= 0) return new int[]{};

        int[] sample = new int[m];
        for (int i = 0; i &lt; m; i++) {
            sample[i] = nums[i];
        }

        Random random = new Random();
        for (int i = m; i &lt; nums.length; i++) {
            int k = random.nextInt(i + 1); // 0~i(inclusive)
            if (k &lt; m) {
                sample[k] = nums[i];
            }
        }

        return sample;
    }
</code></pre>
<p>和洗牌算法類似，我們要證明的問題是：<strong>數組中每個元素在最終採樣的數組中出現的機率均相等且爲<code>m/n</code>.</strong> 洗牌算法中是排列，而對於隨機抽樣則爲組合。</p>
<p>維基百科上的證明相對容易懂一些，這裏我稍微複述下。首先將數組前 m 個元素填充進新數組<code>sample</code>, 然後從<code>m</code>開始遍歷直至數組最後一個索引。隨機數<code>k</code>的範圍爲<code>0~i</code>, 如果<code>k &lt; m</code>，新數組的索引爲 k 的元素則和原數組索引爲<code>i</code>的元素交換；如果<code>k &gt;= m</code>, 則不進行交換。<code>i == m</code>時，以原數組中第<code>j</code>個元素爲例，它被<code>nums[m]</code>替換的機率爲<code>1/(m+1)</code>, 也就是說保留在<code>sample</code>數組中的機率爲<code>m/(m+1)</code>. 對與第<code>m+1</code>個元素<code>nums[m]</code>來說，其位於<code>sample</code>數組中的機率則爲<code>m*1/(m+1)</code>(可替換 m 個不同的元素).</p>
<p>接下來仍然使用數學歸納法證明，若<code>i</code>遍歷到<code>r</code>時，其之前的元素出現的機率爲<code>m/(r-1)</code>, 那麼其之前的元素中任一元素<code>nums[j]</code>被替換的機率爲<code>m/r * 1/m = 1/r</code>, 不被替換的機率則爲<code>(r-1)/r</code>. 故元素<code>nums[j]</code>在<code>i</code>遍歷完<code>r</code>後仍然保留的機率爲<code>m/(r-1) * (r-1)/r = m/r</code>. 而對於元素<code>nums[r]</code>來說，其要被替換至<code>sample</code>數組中的機率則爲<code>m/r</code>(隨機數小於m 的個數爲 m).</p>
<p>綜上，以上算法在遍歷完長度爲 n 的數組後每個數出現在最終<code>sample</code>數組中的機率都爲<code>m/n</code>.</p>
<h2>Implementation and Test case</h2>
<p><strong>Talk is cheap, show me the code!</strong></p>
<h3>Java</h3>
<pre><code class="lang-java">import java.util.*;
import java.util.Random;

public class Probability {
    public static void main(String[] args) {
        int[] cards = new int[10];
        for (int i = 0; i &lt; 10; i++) {
            cards[i] = i;
        }
        // 100000 times test
        final int times = 100000;
        final int m = 5;
        int[][] count = new int[cards.length][cards.length];
        int[][] count2 = new int[cards.length][m];
        for (int i = 0; i &lt; times; i++) {
            shuffleCard(cards);
            shuffleTest(cards, count);
            int[] sample = randomSample(cards, m);
            shuffleTest(sample, count2);
        }
        System.out.println(&quot;Shuffle cards&quot;);
        shufflePrint(count);
        System.out.println();
        System.out.println(&quot;Random sample&quot;);
        shufflePrint(count2);
    }

    /*
     * shuffle cards
     */
    public static void shuffleCard(int[] cards) {
        if (cards == null || cards.length == 0) return;

        Random rand = new Random();
        for (int i = 0; i &lt; cards.length; i++) {
            int k = rand.nextInt(i + 1);
            int temp = cards[i];
            cards[i] = cards[k];
            cards[k] = temp;
        }
    }

    /*
     * random sample
     */
    public static int[] randomSample(int[] nums, int m) {
        if (nums == null || nums.length == 0 || m &lt;= 0) return new int[]{};

        m = Math.min(m, nums.length);
        int[] sample = new int[m];
        for (int i = 0; i &lt; m; i++) {
            sample[i] = nums[i];
        }

        Random random = new Random();
        for (int i = m; i &lt; nums.length; i++) {
            int k = random.nextInt(i + 1);
            if (k &lt; m) {
                sample[k] = nums[i];
            }
        }

        return sample;
    }

    /*
     * nums[i] = j, num j appear in index i ==&gt; count[j][i]
     */
    public static void shuffleTest(int[] nums, int[][] count) {
        if (nums == null || nums.length == 0) return;

        for (int i = 0; i &lt; nums.length; i++) {
            count[nums[i]][i]++;
        }
    }

    /*
     * print shuffle test
     */
    public static void shufflePrint(int[][] count) {
        if (count == null || count.length == 0) return;

        // print index
        System.out.print(&quot;   &quot;);
        for (int i = 0; i &lt; count[0].length; i++) {
            System.out.printf(&quot;%-7d&quot;, i);
        }
        System.out.println();
        // print num appear in index i in total
        for (int i = 0; i &lt; count.length; i++) {
            System.out.print(i + &quot;: &quot;);
            for (int j = 0; j &lt; count[i].length; j++) {
                System.out.printf(&quot;%-7d&quot;, count[i][j]);
            }
            System.out.println();
        }
    }
}
</code></pre>
<p>以十萬次試驗爲例，左側是元素<code>i</code>, 列代表在相應索引位置出現的次數。可以看出分佈還是比較隨機的。</p>
<pre><code>Shuffle cards
   0      1      2      3      4      5      6      7      8      9
0: 10033  9963   10043  9845   9932   10020  9964   10114  10043  10043
1: 9907   9951   9989   10071  10059  9966   10054  10023  10015  9965
2: 10042  10046  9893   10080  10050  9994   10024  9852   10098  9921
3: 10039  10023  10039  10024  9919   10057  10188  9916   9907   9888
4: 9944   9913   10196  10059  9838   10205  9899   9945   9850   10151
5: 10094  9971   10054  9958   10022  9922   10047  9978   9965   9989
6: 9995   10147  9824   10015  10023  9804   10050  10192  9939   10011
7: 9941   10131  9902   9920   10040  10121  10010  9928   9984   10023
8: 10010  9926   9883   10098  10083  10028  9801   9936   10200  10035
9: 9995   9929   10177  9930   10034  9883   9963   10116  9999   9974

Random sample
   0      1      2      3      4
0: 9966   10026  10078  9966   9891
1: 9958   9806   10066  10022  10039
2: 9923   9936   9964   10051  10083
3: 10165  10088  10184  9928   9916
4: 9998   9990   9973   9931   9832
5: 10026  9932   9873   10085  10035
6: 9942   9972   9990   10030  10026
7: 9903   10153  9997   10051  10044
8: 10082  10066  9804   9899   10147
9: 10037  10031  10071  10037  9987
</code></pre><h2>Reference</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm">Fisher–Yates shuffle</a> - 洗牌算法的詳述，比較簡潔的演算法</li>
<li><a href="https://en.wikipedia.org/wiki/Reservoir_sampling">Reservoir sampling </a> - 水池抽樣算法</li>
<li><a href="http://coolshell.cn/articles/8593.html">如何測試洗牌程序 | 酷 殼 - CoolShell.cn</a> - 借鑑了其中的一些測試方法</li>
<li>《計算機程序設計藝術》第二卷（半數值算法） - 3.4.2 隨機抽樣和洗牌</li>
<li>《編程珠璣》第十二章 - 抽樣問題</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bitmap]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_algorithm/bitmap.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_algorithm/bitmap.html">
        </link>
        <updated>2019-11-03T15:42:04Z</updated>
        <summary type="html"><![CDATA[<h1>Bitmap</h1>
<!-- toc -->
<ul>
<li><a href="#implementation">Implementation</a><ul>
<li><a href="#c">C</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>最開始接觸 bitmap 是在 Jon Bentley 所著《Programming Pearls》 (無繁體中文版，簡體中文版書名為《編程珠璣》) 這本書上，書中所述的方法有點簡單粗暴，不過思想倒是不錯——從 Information Theory 的角度來解釋就是信息壓縮了。即將原來32位表示一個 int 變爲一位表示一個 int. 從空間的角度來說就是巨大的節省了(1/32)。可能的應用有<strong>大數據排序/查找（非負整數）</strong>。</p>
<p>C++ 中有<code>bitset</code>容器，其他語言可用類似方法實現。</p>
<h2>Implementation</h2>
<h3>C</h3>
<pre><code class="lang-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/*
 * @param bits: uint array, i: num i of original array
 */
void setbit(unsigned int *bits, unsigned int i, int BIT_LEN)
{
        bits[i / BIT_LEN] |= 1 &lt;&lt; (i % BIT_LEN);
}

/*
 * @param bits: uint array, i: num i of original array
 */
int testbit(unsigned int *bits, unsigned int i, int BIT_LEN)
{
        return bits[i / BIT_LEN] &amp; (1 &lt;&lt; (i % BIT_LEN));
}

int main(int argc, char *argv[])
{
        const int BIT_LEN = sizeof(int) * 8;
        const unsigned int N = 1 &lt;&lt; (BIT_LEN - 1);
        unsigned int *bits = (unsigned int *)calloc(N, sizeof(int));
        for (unsigned int i = 0; i &lt; N; i++) {
                if (i % 10000001 == 0) setbit(bits, i, BIT_LEN);
        }

        for (unsigned int i = 0; i &lt; N; i++) {
                if (testbit(bits, i, BIT_LEN) != 0) printf(&quot;i = %u exists.\n&quot;, i);
        }
        free(bits);
        bits = NULL;

        return 0;
}
</code></pre>
<h3>源碼分析</h3>
<p>核心爲兩個函數方法的使用，<code>setbit</code>用於將非負整數<code>i</code>置於指定的位。可用分區分位的方式來理解位圖排序的思想，即將非負整數<code>i</code>放到它應該在的位置。比如16，其可以位於第一個 int 型的第17位，具體實現即將第17位置一，細節見上面代碼。測試某個數是否存在於位圖中也可以採用類似方法。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Bitmap</h1>
<!-- toc -->
<ul>
<li><a href="#implementation">Implementation</a><ul>
<li><a href="#c">C</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>最開始接觸 bitmap 是在 Jon Bentley 所著《Programming Pearls》 (無繁體中文版，簡體中文版書名為《編程珠璣》) 這本書上，書中所述的方法有點簡單粗暴，不過思想倒是不錯——從 Information Theory 的角度來解釋就是信息壓縮了。即將原來32位表示一個 int 變爲一位表示一個 int. 從空間的角度來說就是巨大的節省了(1/32)。可能的應用有<strong>大數據排序/查找（非負整數）</strong>。</p>
<p>C++ 中有<code>bitset</code>容器，其他語言可用類似方法實現。</p>
<h2>Implementation</h2>
<h3>C</h3>
<pre><code class="lang-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/*
 * @param bits: uint array, i: num i of original array
 */
void setbit(unsigned int *bits, unsigned int i, int BIT_LEN)
{
        bits[i / BIT_LEN] |= 1 &lt;&lt; (i % BIT_LEN);
}

/*
 * @param bits: uint array, i: num i of original array
 */
int testbit(unsigned int *bits, unsigned int i, int BIT_LEN)
{
        return bits[i / BIT_LEN] &amp; (1 &lt;&lt; (i % BIT_LEN));
}

int main(int argc, char *argv[])
{
        const int BIT_LEN = sizeof(int) * 8;
        const unsigned int N = 1 &lt;&lt; (BIT_LEN - 1);
        unsigned int *bits = (unsigned int *)calloc(N, sizeof(int));
        for (unsigned int i = 0; i &lt; N; i++) {
                if (i % 10000001 == 0) setbit(bits, i, BIT_LEN);
        }

        for (unsigned int i = 0; i &lt; N; i++) {
                if (testbit(bits, i, BIT_LEN) != 0) printf(&quot;i = %u exists.\n&quot;, i);
        }
        free(bits);
        bits = NULL;

        return 0;
}
</code></pre>
<h3>源碼分析</h3>
<p>核心爲兩個函數方法的使用，<code>setbit</code>用於將非負整數<code>i</code>置於指定的位。可用分區分位的方式來理解位圖排序的思想，即將非負整數<code>i</code>放到它應該在的位置。比如16，其可以位於第一個 int 型的第17位，具體實現即將第17位置一，細節見上面代碼。測試某個數是否存在於位圖中也可以採用類似方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Basics Misc]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_misc/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_misc/">
        </link>
        <updated>2019-11-03T15:42:05Z</updated>
        <summary type="html"><![CDATA[<h1>Basics Miscellaneous</h1>
<p>雜項，涉及「位操作」等。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Basics Miscellaneous</h1>
<p>雜項，涉及「位操作」等。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bit Manipulation]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/basics_misc/bit_manipulation.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/basics_misc/bit_manipulation.html">
        </link>
        <updated>2019-11-03T15:42:05Z</updated>
        <summary type="html"><![CDATA[<h1>Bit Manipulation</h1>
<!-- toc -->
<ul>
<li><a href="#xor---異或exclusive-or">XOR - 異或(exclusive or)</a></li>
<li><a href="#移位操作shift-operation">移位操作(shift operation)</a><ul>
<li><a href="#reference">Reference</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>位操作有按位與(bitwise and)、或(bitwise or)、非(bitwise not)、左移n位和右移n位等操作。</p>
<h3>XOR - 異或(exclusive or)</h3>
<blockquote>
<p>異或：相同為0，不同為1。也可用「不進位加法」來理解。</p>
</blockquote>
<p>異或操作的一些特點：</p>
<pre><code>x ^ 0 = x
x ^ 1s = ~x // 1s = ~0
x ^ (~x) = 1s
x ^ x = 0 // interesting and important!
a ^ b = c =&gt; a ^ c = b, b ^ c = a // swap
a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c // associative
</code></pre><h3>移位操作(shift operation)</h3>
<p>移位操作可近似為乘以/除以2的冪。<code>0b0010 * 0b0110</code>等價於<code>0b0110 &lt;&lt; 2</code>. 下面是一些常見的移位組合操作。</p>
<ol>
<li>將<code>x</code>最右邊的<code>n</code>位清零 - <code>x &amp; (~0 &lt;&lt; n)</code></li>
<li>獲取<code>x</code>的第<code>n</code>位值(0或者1) - <code>x &amp; (1 &lt;&lt; n)</code></li>
<li>獲取<code>x</code>的第<code>n</code>位的冪值 - <code>(x &gt;&gt; n) &amp; 1</code></li>
<li>僅將第<code>n</code>位置為<code>1</code> - <code>x | (1 &lt;&lt; n)</code></li>
<li>僅將第<code>n</code>位置為<code>0</code> - <code>x &amp; (~(1 &lt;&lt; n))</code></li>
<li>將<code>x</code>最高位至第<code>n</code>位(含)清零 - <code>x &amp; ((1 &lt;&lt; n) - 1)</code></li>
<li>將第<code>n</code>位至第0位(含)清零 - <code>x &amp; (~((1 &lt;&lt; (n + 1)) - 1))</code></li>
<li>僅更新第<code>n</code>位，寫入值為<code>v</code>; <code>v</code>為1則更新為1，否則為0 - <code>mask = ~(1 &lt;&lt; n); x = (x &amp; mask) | (v &lt;&lt; i)</code></li>
</ol>
<h3>實際應用</h3>
<h4>位圖(Bitmap)</h4>
<p>位圖一般用於替代flag array，節約空間。<br>
一個int型的陣列用位圖替換後，占用的空間可以縮小到原來的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn><mn>2</mn></mrow><annotation encoding="application/x-tex">1/32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathrm">3</span><span class="mord mathrm">2</span></span></span></span>.(若int類型是32位元)<br>
下面代碼定義了一個100萬大小的類圖，setbit和testbit函數</p>
<pre><code class="lang-c++">#define N 1000000 // 1 million
#define WORD_LENGTH sizeof(int) * 8 //sizeof返回字節數，乘以8，為int類型總位數

//bits為陣列，i控制具體哪位，即i為0~1000000
void setbit(unsigned int* bits, unsigned int i){
    bits[i / WORD_LENGTH] |= 1&lt;&lt;(i % WORD_LENGTH);  
}

int testbit(unsigned int* bits, unsigned int i){
    return bits[i/WORD_LENGTH] &amp; (1&lt;&lt;(i % WORD_LENGTH));
}

unsigned int bits[N/WORD_LENGTH + 1];
</code></pre>
<h2>Reference</h2>
<ul>
<li><a href="http://noalgo.info/344.html">位運算應用技巧（1） » NoAlGo博客</a></li>
<li><a href="http://noalgo.info/353.html">位運算應用技巧（2） » NoAlGo博客</a></li>
<li><a href="http://www.matrix67.com/blog/archives/263">位運算簡介及實用技巧（一）：基礎篇 | Matrix67: The Aha Moments</a></li>
<li><em>cc150</em> chapter 8.5 and chapter 9.5</li>
<li>《編程珠璣2》</li>
<li>《Elementary Algorithms》 Larry LIU Xinyu</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Bit Manipulation</h1>
<!-- toc -->
<ul>
<li><a href="#xor---異或exclusive-or">XOR - 異或(exclusive or)</a></li>
<li><a href="#移位操作shift-operation">移位操作(shift operation)</a><ul>
<li><a href="#reference">Reference</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>位操作有按位與(bitwise and)、或(bitwise or)、非(bitwise not)、左移n位和右移n位等操作。</p>
<h3>XOR - 異或(exclusive or)</h3>
<blockquote>
<p>異或：相同為0，不同為1。也可用「不進位加法」來理解。</p>
</blockquote>
<p>異或操作的一些特點：</p>
<pre><code>x ^ 0 = x
x ^ 1s = ~x // 1s = ~0
x ^ (~x) = 1s
x ^ x = 0 // interesting and important!
a ^ b = c =&gt; a ^ c = b, b ^ c = a // swap
a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c // associative
</code></pre><h3>移位操作(shift operation)</h3>
<p>移位操作可近似為乘以/除以2的冪。<code>0b0010 * 0b0110</code>等價於<code>0b0110 &lt;&lt; 2</code>. 下面是一些常見的移位組合操作。</p>
<ol>
<li>將<code>x</code>最右邊的<code>n</code>位清零 - <code>x &amp; (~0 &lt;&lt; n)</code></li>
<li>獲取<code>x</code>的第<code>n</code>位值(0或者1) - <code>x &amp; (1 &lt;&lt; n)</code></li>
<li>獲取<code>x</code>的第<code>n</code>位的冪值 - <code>(x &gt;&gt; n) &amp; 1</code></li>
<li>僅將第<code>n</code>位置為<code>1</code> - <code>x | (1 &lt;&lt; n)</code></li>
<li>僅將第<code>n</code>位置為<code>0</code> - <code>x &amp; (~(1 &lt;&lt; n))</code></li>
<li>將<code>x</code>最高位至第<code>n</code>位(含)清零 - <code>x &amp; ((1 &lt;&lt; n) - 1)</code></li>
<li>將第<code>n</code>位至第0位(含)清零 - <code>x &amp; (~((1 &lt;&lt; (n + 1)) - 1))</code></li>
<li>僅更新第<code>n</code>位，寫入值為<code>v</code>; <code>v</code>為1則更新為1，否則為0 - <code>mask = ~(1 &lt;&lt; n); x = (x &amp; mask) | (v &lt;&lt; i)</code></li>
</ol>
<h3>實際應用</h3>
<h4>位圖(Bitmap)</h4>
<p>位圖一般用於替代flag array，節約空間。<br>
一個int型的陣列用位圖替換後，占用的空間可以縮小到原來的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn><mn>2</mn></mrow><annotation encoding="application/x-tex">1/32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="mord mathrm">3</span><span class="mord mathrm">2</span></span></span></span>.(若int類型是32位元)<br>
下面代碼定義了一個100萬大小的類圖，setbit和testbit函數</p>
<pre><code class="lang-c++">#define N 1000000 // 1 million
#define WORD_LENGTH sizeof(int) * 8 //sizeof返回字節數，乘以8，為int類型總位數

//bits為陣列，i控制具體哪位，即i為0~1000000
void setbit(unsigned int* bits, unsigned int i){
    bits[i / WORD_LENGTH] |= 1&lt;&lt;(i % WORD_LENGTH);  
}

int testbit(unsigned int* bits, unsigned int i){
    return bits[i/WORD_LENGTH] &amp; (1&lt;&lt;(i % WORD_LENGTH));
}

unsigned int bits[N/WORD_LENGTH + 1];
</code></pre>
<h2>Reference</h2>
<ul>
<li><a href="http://noalgo.info/344.html">位運算應用技巧（1） » NoAlGo博客</a></li>
<li><a href="http://noalgo.info/353.html">位運算應用技巧（2） » NoAlGo博客</a></li>
<li><a href="http://www.matrix67.com/blog/archives/263">位運算簡介及實用技巧（一）：基礎篇 | Matrix67: The Aha Moments</a></li>
<li><em>cc150</em> chapter 8.5 and chapter 9.5</li>
<li>《編程珠璣2》</li>
<li>《Elementary Algorithms》 Larry LIU Xinyu</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Part II - Coding]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/part_ii_coding/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/part_ii_coding/">
        </link>
        <updated>2019-11-03T15:42:05Z</updated>
        <summary type="html"><![CDATA[<h1>Part II - Coding</h1>
<p>本節主要總結一些leetcode等題目的實戰經驗。</p>
<p>主要有以下章節構成。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Part II - Coding</h1>
<p>本節主要總結一些leetcode等題目的實戰經驗。</p>
<p>主要有以下章節構成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[String]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/string/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/string/">
        </link>
        <updated>2019-11-03T15:42:05Z</updated>
        <summary type="html"><![CDATA[<h1>String - 字串</h1>
<p>本章主要介紹字串相關題目。</p>
<blockquote>
<p>處理字串操作相關問題時，常見的做法是從字串尾部開始編輯，從後往前逆向操作。這麼做的原因是因為字串的尾部往往有足夠空間，可以直接修改而不用擔心覆蓋字串前面的數據。</p>
</blockquote>
<p>摘自《程序員面試金典》</p>
]]></summary>
        <content type="html"><![CDATA[<h1>String - 字串</h1>
<p>本章主要介紹字串相關題目。</p>
<blockquote>
<p>處理字串操作相關問題時，常見的做法是從字串尾部開始編輯，從後往前逆向操作。這麼做的原因是因為字串的尾部往往有足夠空間，可以直接修改而不用擔心覆蓋字串前面的數據。</p>
</blockquote>
<p>摘自《程序員面試金典》</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[strStr]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/string/strstr.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/string/strstr.html">
        </link>
        <updated>2019-11-03T15:42:05Z</updated>
        <summary type="html"><![CDATA[<h1>strStr</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
</ul>
</li>
<li><a href="#another-similar-question">Another Similar Question</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/implement-strstr/">Implement strStr() | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.en/problem/strstr/">lintcode - (13) strstr</a></li>
</ul>
<pre><code>strstr (a.k.a find sub string), is a useful function in string operation.
You task is to implement this function.

For a given source string and a target string,
you should output the &quot;first&quot; index(from 0) of target string in source string.

If target is not exist in source, just return -1.

Example
If source=&quot;source&quot; and target=&quot;target&quot;, return -1.

If source=&quot;abcdabcdefg&quot; and target=&quot;bcd&quot;, return 1.

Challenge
O(n) time.

Clarification
Do I need to implement KMP Algorithm in an interview?

    - Not necessary. When this problem occurs in an interview,
    the interviewer just want to test your basic implementation ability.
</code></pre><h2>題解</h2>
<p>對於字串查找問題，可使用雙重for迴圈解決，效率更高的則為KMP算法。</p>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * http://www.jiuzhang.com//solutions/implement-strstr
 */
class Solution {
    /**
     * Returns a index to the first occurrence of target in source,
     * or -1  if target is not part of source.
     * @param source string to be scanned.
     * @param target string containing the sequence of characters to match.
     */
    public int strStr(String source, String target) {
        if (source == null || target == null) {
            return -1;
        }

        int i, j;
        for (i = 0; i &lt; source.length() - target.length() + 1; i++) {
            for (j = 0; j &lt; target.length(); j++) {
                if (source.charAt(i + j) != target.charAt(j)) {
                    break;
                } //if
            } //for j
            if (j == target.length()) {
                return i;
            }
        } //for i

        // did not find the target
        return -1;
    }
}
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>邊界檢查：<code>source</code>和<code>target</code>有可能是空串。</li>
<li>邊界檢查之下標溢出：注意變量<code>i</code>的循環判斷條件，如果是單純的<code>i &lt; source.length()</code>則在後面的<code>source.charAt(i + j)</code>時有可能溢出。</li>
<li>代碼風格：（1）運算符<code>==</code>兩邊應加空格；（2）變量名不要起<code>s1``s2</code>這類，要有意義，如<code>target``source</code>；（3）即使if語句中只有一句話也要加大括號，即<code>{return -1;}</code>；（4）Java 代碼的大括號一般在同一行右邊，C++ 代碼的大括號一般另起一行；（5）<code>int i, j;</code>聲明前有一行空格，是好的代碼風格。</li>
<li>不要在for的條件中聲明<code>i</code>,<code>j</code>，容易在循環外再使用時造成編譯錯誤，錯誤代碼示例：</li>
</ol>
<h2>Another Similar Question</h2>
<pre><code class="lang-java">/**
 * http://www.jiuzhang.com//solutions/implement-strstr
 */
public class Solution {
    public String strStr(String haystack, String needle) {
        if(haystack == null || needle == null) {
            return null;
        }
        int i, j;
        for(i = 0; i &lt; haystack.length() - needle.length() + 1; i++) {
            for(j = 0; j &lt; needle.length(); j++) {
                if(haystack.charAt(i + j) != needle.charAt(j)) {
                    break;
                }
            }
            if(j == needle.length()) {
                return haystack.substring(i);
            }
        }
        return null;
    }
}
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1>strStr</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
</ul>
</li>
<li><a href="#another-similar-question">Another Similar Question</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/implement-strstr/">Implement strStr() | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.en/problem/strstr/">lintcode - (13) strstr</a></li>
</ul>
<pre><code>strstr (a.k.a find sub string), is a useful function in string operation.
You task is to implement this function.

For a given source string and a target string,
you should output the &quot;first&quot; index(from 0) of target string in source string.

If target is not exist in source, just return -1.

Example
If source=&quot;source&quot; and target=&quot;target&quot;, return -1.

If source=&quot;abcdabcdefg&quot; and target=&quot;bcd&quot;, return 1.

Challenge
O(n) time.

Clarification
Do I need to implement KMP Algorithm in an interview?

    - Not necessary. When this problem occurs in an interview,
    the interviewer just want to test your basic implementation ability.
</code></pre><h2>題解</h2>
<p>對於字串查找問題，可使用雙重for迴圈解決，效率更高的則為KMP算法。</p>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * http://www.jiuzhang.com//solutions/implement-strstr
 */
class Solution {
    /**
     * Returns a index to the first occurrence of target in source,
     * or -1  if target is not part of source.
     * @param source string to be scanned.
     * @param target string containing the sequence of characters to match.
     */
    public int strStr(String source, String target) {
        if (source == null || target == null) {
            return -1;
        }

        int i, j;
        for (i = 0; i &lt; source.length() - target.length() + 1; i++) {
            for (j = 0; j &lt; target.length(); j++) {
                if (source.charAt(i + j) != target.charAt(j)) {
                    break;
                } //if
            } //for j
            if (j == target.length()) {
                return i;
            }
        } //for i

        // did not find the target
        return -1;
    }
}
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>邊界檢查：<code>source</code>和<code>target</code>有可能是空串。</li>
<li>邊界檢查之下標溢出：注意變量<code>i</code>的循環判斷條件，如果是單純的<code>i &lt; source.length()</code>則在後面的<code>source.charAt(i + j)</code>時有可能溢出。</li>
<li>代碼風格：（1）運算符<code>==</code>兩邊應加空格；（2）變量名不要起<code>s1``s2</code>這類，要有意義，如<code>target``source</code>；（3）即使if語句中只有一句話也要加大括號，即<code>{return -1;}</code>；（4）Java 代碼的大括號一般在同一行右邊，C++ 代碼的大括號一般另起一行；（5）<code>int i, j;</code>聲明前有一行空格，是好的代碼風格。</li>
<li>不要在for的條件中聲明<code>i</code>,<code>j</code>，容易在循環外再使用時造成編譯錯誤，錯誤代碼示例：</li>
</ol>
<h2>Another Similar Question</h2>
<pre><code class="lang-java">/**
 * http://www.jiuzhang.com//solutions/implement-strstr
 */
public class Solution {
    public String strStr(String haystack, String needle) {
        if(haystack == null || needle == null) {
            return null;
        }
        int i, j;
        for(i = 0; i &lt; haystack.length() - needle.length() + 1; i++) {
            for(j = 0; j &lt; needle.length(); j++) {
                if(haystack.charAt(i + j) != needle.charAt(j)) {
                    break;
                }
            }
            if(j == needle.length()) {
                return haystack.substring(i);
            }
        }
        return null;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Two Strings Are Anagrams]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/string/two_strings_are_anagrams.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/string/two_strings_are_anagrams.html">
        </link>
        <updated>2019-11-03T15:42:06Z</updated>
        <summary type="html"><![CDATA[<h1>Two Strings Are Anagrams</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解1---hashmap-統計字頻">題解1 - hashmap 統計字頻</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#題解2---排序字串">題解2 - 排序字串</a><ul>
<li><a href="#c-1">C++</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>CC150: <a href="http://www.lintcode.com/en/problem/two-strings-are-anagrams/">(158) Two Strings Are Anagrams</a></li>
<li>leetcode: <a href="https://leetcode.com/problems/valid-anagram/">Valid Anagram | LeetCode OJ</a></li>
</ul>
<pre><code>Write a method anagram(s,t) to decide if two strings are anagrams or not.

Example
Given s=&quot;abcd&quot;, t=&quot;dcab&quot;, return true.

Challenge
O(n) time, O(1) extra space
</code></pre><h2>題解1 - hashmap 統計字頻</h2>
<p>判斷兩個字串是否互為變位詞，若區分大小寫，考慮空白字符時，直接來理解可以認為兩個字串的擁有各不同字符的數量相同。對於比較字符數量的問題常用的方法為遍歷兩個字串，統計其中各字符出現的頻次，若不等則返回<code>false</code>. 有很多簡單字串類面試題都是此題的變形題。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param s: The first string
     * @param t: The second string
     * @return true or false
     */
    bool anagram(string s, string t) {
        if (s.empty() || t.empty()) {
            return false;
        }
        if (s.size() != t.size()) {
            return false;
        }

        int letterCount[256] = {0};

        for (int i = 0; i != s.size(); ++i) {
            ++letterCount[s[i]];
            --letterCount[t[i]];
        }
        for (int i = 0; i != t.size(); ++i) {
            if (letterCount[t[i]] != 0) {
                return false;
            }
        }

        return true;
    }
};
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>兩個字串長度不等時必不可能為變位詞(需要注意題目條件靈活處理)。</li>
<li>初始化含有256個字符的計數器陣列。</li>
<li>對字串 s 自增，字串 t 遞減，再次遍歷判斷<code>letterCount</code>陣列的值，小於0時返回<code>false</code>.</li>
</ol>
<p>在字串長度較長(大於所有可能的字符數)時，還可對第二個<code>for</code>循環做進一步優化，即<code>t.size() &gt; 256</code>時，使用256替代<code>t.size()</code>, 使用<code>i</code>替代<code>t[i]</code>.</p>
<h3>複雜度分析</h3>
<p>兩次遍歷字串，時間複雜度最壞情況下為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>2</mn><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 使用了額外的陣列，空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>2</mn><mn>5</mn><mn>6</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(256)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mord mathrm">5</span><span class="mord mathrm">6</span><span class="mclose">)</span></span></span></span>.</p>
<h2>題解2 - 排序字串</h2>
<p>另一直接的解法是對字串先排序，若排序後的字串內容相同，則其互為變位詞。題解1中使用 hashmap 的方法對於比較兩個字串是否互為變位詞十分有效，但是在比較多個字串時，使用 hashmap 的方法複雜度則較高。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param s: The first string
     * @param b: The second string
     * @return true or false
     */
    bool anagram(string s, string t) {
        if (s.empty() || t.empty()) {
            return false;
        }
        if (s.size() != t.size()) {
            return false;
        }

        sort(s.begin(), s.end());
        sort(t.begin(), t.end());

        if (s == t) {
            return true;
        } else {
            return false;
        }
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>對字串 s 和 t 分別排序，而後比較是否含相同內容。對字串排序時可以採用先統計字頻再組裝成排序後的字串，效率更高一點。</p>
<h3>複雜度分析</h3>
<p>C++的 STL 中 sort 的時間複雜度介於 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>之間，判斷<code>s == t</code>時間複雜度最壞為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><em>CC150 Chapter 9.1</em> 中文版 p109</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Two Strings Are Anagrams</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解1---hashmap-統計字頻">題解1 - hashmap 統計字頻</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#題解2---排序字串">題解2 - 排序字串</a><ul>
<li><a href="#c-1">C++</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>CC150: <a href="http://www.lintcode.com/en/problem/two-strings-are-anagrams/">(158) Two Strings Are Anagrams</a></li>
<li>leetcode: <a href="https://leetcode.com/problems/valid-anagram/">Valid Anagram | LeetCode OJ</a></li>
</ul>
<pre><code>Write a method anagram(s,t) to decide if two strings are anagrams or not.

Example
Given s=&quot;abcd&quot;, t=&quot;dcab&quot;, return true.

Challenge
O(n) time, O(1) extra space
</code></pre><h2>題解1 - hashmap 統計字頻</h2>
<p>判斷兩個字串是否互為變位詞，若區分大小寫，考慮空白字符時，直接來理解可以認為兩個字串的擁有各不同字符的數量相同。對於比較字符數量的問題常用的方法為遍歷兩個字串，統計其中各字符出現的頻次，若不等則返回<code>false</code>. 有很多簡單字串類面試題都是此題的變形題。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param s: The first string
     * @param t: The second string
     * @return true or false
     */
    bool anagram(string s, string t) {
        if (s.empty() || t.empty()) {
            return false;
        }
        if (s.size() != t.size()) {
            return false;
        }

        int letterCount[256] = {0};

        for (int i = 0; i != s.size(); ++i) {
            ++letterCount[s[i]];
            --letterCount[t[i]];
        }
        for (int i = 0; i != t.size(); ++i) {
            if (letterCount[t[i]] != 0) {
                return false;
            }
        }

        return true;
    }
};
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>兩個字串長度不等時必不可能為變位詞(需要注意題目條件靈活處理)。</li>
<li>初始化含有256個字符的計數器陣列。</li>
<li>對字串 s 自增，字串 t 遞減，再次遍歷判斷<code>letterCount</code>陣列的值，小於0時返回<code>false</code>.</li>
</ol>
<p>在字串長度較長(大於所有可能的字符數)時，還可對第二個<code>for</code>循環做進一步優化，即<code>t.size() &gt; 256</code>時，使用256替代<code>t.size()</code>, 使用<code>i</code>替代<code>t[i]</code>.</p>
<h3>複雜度分析</h3>
<p>兩次遍歷字串，時間複雜度最壞情況下為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>2</mn><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 使用了額外的陣列，空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>2</mn><mn>5</mn><mn>6</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(256)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mord mathrm">5</span><span class="mord mathrm">6</span><span class="mclose">)</span></span></span></span>.</p>
<h2>題解2 - 排序字串</h2>
<p>另一直接的解法是對字串先排序，若排序後的字串內容相同，則其互為變位詞。題解1中使用 hashmap 的方法對於比較兩個字串是否互為變位詞十分有效，但是在比較多個字串時，使用 hashmap 的方法複雜度則較高。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param s: The first string
     * @param b: The second string
     * @return true or false
     */
    bool anagram(string s, string t) {
        if (s.empty() || t.empty()) {
            return false;
        }
        if (s.size() != t.size()) {
            return false;
        }

        sort(s.begin(), s.end());
        sort(t.begin(), t.end());

        if (s == t) {
            return true;
        } else {
            return false;
        }
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>對字串 s 和 t 分別排序，而後比較是否含相同內容。對字串排序時可以採用先統計字頻再組裝成排序後的字串，效率更高一點。</p>
<h3>複雜度分析</h3>
<p>C++的 STL 中 sort 的時間複雜度介於 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>之間，判斷<code>s == t</code>時間複雜度最壞為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><em>CC150 Chapter 9.1</em> 中文版 p109</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Compare Strings]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/string/compare_strings.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/string/compare_strings.html">
        </link>
        <updated>2019-11-03T15:42:06Z</updated>
        <summary type="html"><![CDATA[<h1>Compare Strings</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#源碼解析">源碼解析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/compare-strings/">(55) Compare Strings</a></li>
</ul>
<pre><code>Compare two strings A and B, determine whether A contains all of the characters in B.

The characters in string A and B are all Upper Case letters.

Example
For A = &quot;ABCD&quot;, B = &quot;ABC&quot;, return true.

For A = &quot;ABCD&quot; B = &quot;AABC&quot;, return false.
</code></pre><h2>題解</h2>
<p>題 <a href="http://algorithm.yuanbin.zh-hans/string/two_strings_are_anagrams.html">Two Strings Are Anagrams | Data Structure and Algorithm</a> 的變形題。題目意思是問B中的所有字元是否都在A中，而不是單個字元。比如B=&quot;AABC&quot;包含兩個「A」，而A=&quot;ABCD&quot;只包含一個「A」，故返回false. 做題時注意題意，必要時可向面試官確認。</p>
<p>既然不是類似 strstr 那樣的匹配，直接使用二重循環就不太合適了。題目中另外給的條件則是A和B都是全大寫單字，理解題意後容易想到的方案就是先遍歷 A 和 B 統計各字元出現的次數，然後比較次數大小即可。嗯，祭出萬能的哈希表。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param A: A string includes Upper Case letters
     * @param B: A string includes Upper Case letter
     * @return:  if string A contains all of the characters in B return true
     *           else return false
     */
    bool compareStrings(string A, string B) {
        if (A.size() &lt; B.size()) {
            return false;
        }

        const int AlphabetNum = 26;
        int letterCount[AlphabetNum] = {0};
        for (int i = 0; i != A.size(); ++i) {
            ++letterCount[A[i] - &#39;A&#39;];
        }
        for (int i = 0; i != B.size(); ++i) {
            --letterCount[B[i] - &#39;A&#39;];
            if (letterCount[B[i] - &#39;A&#39;] &lt; 0) {
                return false;
            }
        }

        return true;
    }
};
</code></pre>
<h3>源碼解析</h3>
<ol>
<li>異常處理，B 的長度大於 A 時必定返回<code>false</code>, 包含了空串的特殊情況。</li>
<li>使用額外的輔助空間，統計各字元的頻次。</li>
</ol>
<h3>複雜度分析</h3>
<p>遍歷一次 A 字串，遍歷一次 B 字串，時間複雜度最壞 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>2</mn><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>2</mn><mn>6</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(26)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mord mathrm">6</span><span class="mclose">)</span></span></span></span>.</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Compare Strings</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#源碼解析">源碼解析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/compare-strings/">(55) Compare Strings</a></li>
</ul>
<pre><code>Compare two strings A and B, determine whether A contains all of the characters in B.

The characters in string A and B are all Upper Case letters.

Example
For A = &quot;ABCD&quot;, B = &quot;ABC&quot;, return true.

For A = &quot;ABCD&quot; B = &quot;AABC&quot;, return false.
</code></pre><h2>題解</h2>
<p>題 <a href="http://algorithm.yuanbin.zh-hans/string/two_strings_are_anagrams.html">Two Strings Are Anagrams | Data Structure and Algorithm</a> 的變形題。題目意思是問B中的所有字元是否都在A中，而不是單個字元。比如B=&quot;AABC&quot;包含兩個「A」，而A=&quot;ABCD&quot;只包含一個「A」，故返回false. 做題時注意題意，必要時可向面試官確認。</p>
<p>既然不是類似 strstr 那樣的匹配，直接使用二重循環就不太合適了。題目中另外給的條件則是A和B都是全大寫單字，理解題意後容易想到的方案就是先遍歷 A 和 B 統計各字元出現的次數，然後比較次數大小即可。嗯，祭出萬能的哈希表。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param A: A string includes Upper Case letters
     * @param B: A string includes Upper Case letter
     * @return:  if string A contains all of the characters in B return true
     *           else return false
     */
    bool compareStrings(string A, string B) {
        if (A.size() &lt; B.size()) {
            return false;
        }

        const int AlphabetNum = 26;
        int letterCount[AlphabetNum] = {0};
        for (int i = 0; i != A.size(); ++i) {
            ++letterCount[A[i] - &#39;A&#39;];
        }
        for (int i = 0; i != B.size(); ++i) {
            --letterCount[B[i] - &#39;A&#39;];
            if (letterCount[B[i] - &#39;A&#39;] &lt; 0) {
                return false;
            }
        }

        return true;
    }
};
</code></pre>
<h3>源碼解析</h3>
<ol>
<li>異常處理，B 的長度大於 A 時必定返回<code>false</code>, 包含了空串的特殊情況。</li>
<li>使用額外的輔助空間，統計各字元的頻次。</li>
</ol>
<h3>複雜度分析</h3>
<p>遍歷一次 A 字串，遍歷一次 B 字串，時間複雜度最壞 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>2</mn><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>2</mn><mn>6</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(26)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mord mathrm">6</span><span class="mclose">)</span></span></span></span>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rotate String]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/string/rotate_string.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/string/rotate_string.html">
        </link>
        <updated>2019-11-03T15:42:06Z</updated>
        <summary type="html"><![CDATA[<h1>Rotate String</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/rotate-string/">(8) Rotate String</a></li>
</ul>
<pre><code>Given a string and an offset, rotate string by offset. (rotate from left to right)

Example
Given &quot;abcdefg&quot;

for offset=0, return &quot;abcdefg&quot;

for offset=1, return &quot;gabcdef&quot;

for offset=2, return &quot;fgabcde&quot;

for offset=3, return &quot;efgabcd&quot;

...
</code></pre><h2>題解</h2>
<p>常見的翻轉法應用題，仔細觀察規律可知翻轉的分割點在從數組末尾數起的offset位置。先翻轉前半部分，隨後翻轉後半部分，最後整體翻轉。</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    &quot;&quot;&quot;
    param A: A string
    param offset: Rotate string with offset.
    return: Rotated string.
    &quot;&quot;&quot;
    def rotateString(self, A, offset):
        if A is None or len(A) == 0:
            return A

        offset %= len(A)
        before = A[:len(A) - offset]
        after = A[len(A) - offset:]
        # [::-1] means reverse in Python
        A = before[::-1] + after[::-1]
        A = A[::-1]

        return A
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
  /**
     * param A: A string
     * param offset: Rotate string with offset.
     * return: Rotated string.
     */
    string rotateString(string A, int offset) {
        if (A.empty() || A.size() == 0) {
            return A;
        }

        int len = A.size();
        offset %= len;
        reverse(A, 0, len - offset - 1);
        reverse(A, len - offset, len - 1);
        reverse(A, 0, len - 1);
        return A;
    }

private:
    void reverse(string &amp;str, int start, int end) {
        while (start &lt; end) {
            char temp = str[start];
            str[start] = str[end];
            str[end] = temp;
            start++;
            end--;
        }
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /*
     * param A: A string
     * param offset: Rotate string with offset.
     * return: Rotated string.
     */
    public char[] rotateString(char[] A, int offset) {
        if (A == null || A.length == 0) {
            return A;
        }

        int len = A.length;
        offset %= len;
        reverse(A, 0, len - offset - 1);
        reverse(A, len - offset, len - 1);
        reverse(A, 0, len - 1);

        return A;
    }

    private void reverse(char[] str, int start, int end) {
        while (start &lt; end) {
            char temp = str[start];
            str[start] = str[end];
            str[end] = temp;
            start++;
            end--;
        }
    }
};
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>異常處理，A為空或者其長度為0</li>
<li><code>offset</code>可能超出A的大小，應對<code>len</code>取餘數後再用</li>
<li>三步翻轉法</li>
</ol>
<p>Python 雖沒有提供字符串的翻轉，但用 slice 非常容易實現，非常 Pythonic!</p>
<h3>複雜度分析</h3>
<p>翻轉一次時間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 原地交換，空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>. 總共翻轉3次，總的時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><a href="http://stackoverflow.com/questions/931092/reverse-a-string-in-python">Reverse a string in Python - Stack Overflow</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Rotate String</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/rotate-string/">(8) Rotate String</a></li>
</ul>
<pre><code>Given a string and an offset, rotate string by offset. (rotate from left to right)

Example
Given &quot;abcdefg&quot;

for offset=0, return &quot;abcdefg&quot;

for offset=1, return &quot;gabcdef&quot;

for offset=2, return &quot;fgabcde&quot;

for offset=3, return &quot;efgabcd&quot;

...
</code></pre><h2>題解</h2>
<p>常見的翻轉法應用題，仔細觀察規律可知翻轉的分割點在從數組末尾數起的offset位置。先翻轉前半部分，隨後翻轉後半部分，最後整體翻轉。</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    &quot;&quot;&quot;
    param A: A string
    param offset: Rotate string with offset.
    return: Rotated string.
    &quot;&quot;&quot;
    def rotateString(self, A, offset):
        if A is None or len(A) == 0:
            return A

        offset %= len(A)
        before = A[:len(A) - offset]
        after = A[len(A) - offset:]
        # [::-1] means reverse in Python
        A = before[::-1] + after[::-1]
        A = A[::-1]

        return A
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
  /**
     * param A: A string
     * param offset: Rotate string with offset.
     * return: Rotated string.
     */
    string rotateString(string A, int offset) {
        if (A.empty() || A.size() == 0) {
            return A;
        }

        int len = A.size();
        offset %= len;
        reverse(A, 0, len - offset - 1);
        reverse(A, len - offset, len - 1);
        reverse(A, 0, len - 1);
        return A;
    }

private:
    void reverse(string &amp;str, int start, int end) {
        while (start &lt; end) {
            char temp = str[start];
            str[start] = str[end];
            str[end] = temp;
            start++;
            end--;
        }
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /*
     * param A: A string
     * param offset: Rotate string with offset.
     * return: Rotated string.
     */
    public char[] rotateString(char[] A, int offset) {
        if (A == null || A.length == 0) {
            return A;
        }

        int len = A.length;
        offset %= len;
        reverse(A, 0, len - offset - 1);
        reverse(A, len - offset, len - 1);
        reverse(A, 0, len - 1);

        return A;
    }

    private void reverse(char[] str, int start, int end) {
        while (start &lt; end) {
            char temp = str[start];
            str[start] = str[end];
            str[end] = temp;
            start++;
            end--;
        }
    }
};
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>異常處理，A為空或者其長度為0</li>
<li><code>offset</code>可能超出A的大小，應對<code>len</code>取餘數後再用</li>
<li>三步翻轉法</li>
</ol>
<p>Python 雖沒有提供字符串的翻轉，但用 slice 非常容易實現，非常 Pythonic!</p>
<h3>複雜度分析</h3>
<p>翻轉一次時間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 原地交換，空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>. 總共翻轉3次，總的時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><a href="http://stackoverflow.com/questions/931092/reverse-a-string-in-python">Reverse a string in Python - Stack Overflow</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Valid Palindrome]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/string/valid_palindrome.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/string/valid_palindrome.html">
        </link>
        <updated>2019-11-03T15:42:06Z</updated>
        <summary type="html"><![CDATA[<h1>Valid Palindrome</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<ul>
<li>tags: [palindrome]</li>
</ul>
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/valid-palindrome/">Valid Palindrome | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/valid-palindrome/">(415) Valid Palindrome</a></li>
</ul>
<pre><code>Given a string, determine if it is a palindrome,
considering only alphanumeric characters and ignoring cases.

Example
&quot;A man, a plan, a canal: Panama&quot; is a palindrome.

&quot;race a car&quot; is not a palindrome.
Note
Have you consider that the string might be empty?
This is a good question to ask during an interview.
For the purpose of this problem,
we define empty string as valid palindrome.

Challenge
O(n) time without extra memory.
</code></pre><h2>題解</h2>
<p>字符串的回文判斷問題，由於字符串可隨機訪問，故逐個比較首尾字符是否相等最為便利，即常見的『兩根指針』技法。此題忽略大小寫，並只考慮字母和數字字符。鏈表的回文判斷總結見 <a href="http://algorithm.yuanbin.zh-hans/linked_list/check_if_a_singly_linked_list_is_palindrome.html">Check if a singly linked list is palindrome</a>.</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    # @param {string} s A string
    # @return {boolean} Whether the string is a valid palindrome
    def isPalindrome(self, s):
        if not s:
            return True

        l, r = 0, len(s) - 1

        while l &lt; r:
            # find left alphanumeric character
            if not s[l].isalnum():
                l += 1
                continue
            # find right alphanumeric character
            if not s[r].isalnum():
                r -= 1
                continue
            # case insensitive compare
            if s[l].lower() == s[r].lower():
                l += 1
                r -= 1
            else:
                return False
        #
        return True
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param s A string
     * @return Whether the string is a valid palindrome
     */
    bool isPalindrome(string&amp; s) {
        if (s.empty()) return true;

        int l = 0, r = s.size() - 1;
        while (l &lt; r) {
            // find left alphanumeric character
            if (!isalnum(s[l])) {
                ++l;
                continue;
            }
            // find right alphanumeric character
            if (!isalnum(s[r])) {
                --r;
                continue;
            }
            // case insensitive compare
            if (tolower(s[l]) == tolower(s[r])) {
                ++l;
                --r;
            } else {
                return false;
            }
        }

        return true;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param s A string
     * @return Whether the string is a valid palindrome
     */
    public boolean isPalindrome(String s) {
        if (s == null || s.isEmpty()) return true;

        int l = 0, r = s.length() - 1;
        while (l &lt; r) {
            // find left alphanumeric character
            if (!Character.isLetterOrDigit(s.charAt(l))) {
                l++;
                continue;
            }
            // find right alphanumeric character
            if (!Character.isLetterOrDigit(s.charAt(r))) {
                r--;
                continue;
            }
            // case insensitive compare
            if (Character.toLowerCase(s.charAt(l)) == Character.toLowerCase(s.charAt(r))) {
                l++;
                r--;
            } else {
                return false;
            }
        }

        return true;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>兩步走：</p>
<ol>
<li>找到最左邊和最右邊的第一個合法字元(字母或者字元)</li>
<li>一致轉換為小寫進行比較</li>
</ol>
<p>字元的判斷盡量使用語言提供的 API</p>
<h3>複雜度分析</h3>
<p>兩根指標遍歷一次，時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Valid Palindrome</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<ul>
<li>tags: [palindrome]</li>
</ul>
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/valid-palindrome/">Valid Palindrome | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/valid-palindrome/">(415) Valid Palindrome</a></li>
</ul>
<pre><code>Given a string, determine if it is a palindrome,
considering only alphanumeric characters and ignoring cases.

Example
&quot;A man, a plan, a canal: Panama&quot; is a palindrome.

&quot;race a car&quot; is not a palindrome.
Note
Have you consider that the string might be empty?
This is a good question to ask during an interview.
For the purpose of this problem,
we define empty string as valid palindrome.

Challenge
O(n) time without extra memory.
</code></pre><h2>題解</h2>
<p>字符串的回文判斷問題，由於字符串可隨機訪問，故逐個比較首尾字符是否相等最為便利，即常見的『兩根指針』技法。此題忽略大小寫，並只考慮字母和數字字符。鏈表的回文判斷總結見 <a href="http://algorithm.yuanbin.zh-hans/linked_list/check_if_a_singly_linked_list_is_palindrome.html">Check if a singly linked list is palindrome</a>.</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    # @param {string} s A string
    # @return {boolean} Whether the string is a valid palindrome
    def isPalindrome(self, s):
        if not s:
            return True

        l, r = 0, len(s) - 1

        while l &lt; r:
            # find left alphanumeric character
            if not s[l].isalnum():
                l += 1
                continue
            # find right alphanumeric character
            if not s[r].isalnum():
                r -= 1
                continue
            # case insensitive compare
            if s[l].lower() == s[r].lower():
                l += 1
                r -= 1
            else:
                return False
        #
        return True
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param s A string
     * @return Whether the string is a valid palindrome
     */
    bool isPalindrome(string&amp; s) {
        if (s.empty()) return true;

        int l = 0, r = s.size() - 1;
        while (l &lt; r) {
            // find left alphanumeric character
            if (!isalnum(s[l])) {
                ++l;
                continue;
            }
            // find right alphanumeric character
            if (!isalnum(s[r])) {
                --r;
                continue;
            }
            // case insensitive compare
            if (tolower(s[l]) == tolower(s[r])) {
                ++l;
                --r;
            } else {
                return false;
            }
        }

        return true;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param s A string
     * @return Whether the string is a valid palindrome
     */
    public boolean isPalindrome(String s) {
        if (s == null || s.isEmpty()) return true;

        int l = 0, r = s.length() - 1;
        while (l &lt; r) {
            // find left alphanumeric character
            if (!Character.isLetterOrDigit(s.charAt(l))) {
                l++;
                continue;
            }
            // find right alphanumeric character
            if (!Character.isLetterOrDigit(s.charAt(r))) {
                r--;
                continue;
            }
            // case insensitive compare
            if (Character.toLowerCase(s.charAt(l)) == Character.toLowerCase(s.charAt(r))) {
                l++;
                r--;
            } else {
                return false;
            }
        }

        return true;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>兩步走：</p>
<ol>
<li>找到最左邊和最右邊的第一個合法字元(字母或者字元)</li>
<li>一致轉換為小寫進行比較</li>
</ol>
<p>字元的判斷盡量使用語言提供的 API</p>
<h3>複雜度分析</h3>
<p>兩根指標遍歷一次，時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Longest Palindromic Substring]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/string/longest_palindromic_substring.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/string/longest_palindromic_substring.html">
        </link>
        <updated>2019-11-03T15:42:07Z</updated>
        <summary type="html"><![CDATA[<h1>Longest Palindromic Substring</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解1---窮舉搜索brute-force">題解1 - 窮舉搜索(brute force)</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#題解2---動態規劃dynamic-programming">題解2 - 動態規劃(dynamic programming)</a></li>
<li><a href="#題解-3---manachers-algorithm">題解 3 - Manacher&#39;s Algorithm</a></li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<ul>
<li>tags: [palindrome]</li>
</ul>
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/longest-palindromic-substring/">Longest Palindromic Substring | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/longest-palindromic-substring/">(200) Longest Palindromic Substring</a></li>
</ul>
<pre><code>Given a string S, find the longest palindromic substring in S.
You may assume that the maximum length of S is 1000,
and there exists one unique longest palindromic substring.

Example
Given the string = &quot;abcdzdcab&quot;, return &quot;cdzdc&quot;.
Challenge
O(n2) time is acceptable. Can you do it in O(n) time.
</code></pre><h2>題解1 - 窮舉搜索(brute force)</h2>
<p>最簡單的方案，窮舉所有可能的子串，判斷子串是否為回文，使用一變數記錄最大回文長度，若新的回文超過之前的最大回文長度則更新標記變數並記錄當前回文的起止索引，最後返回最長回文子串。</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    # @param {string} s input string
    # @return {string} the longest palindromic substring
    def longestPalindrome(self, s):
        if not s:
            return &quot;&quot;

        n = len(s)
        longest, left, right = 0, 0, 0
        for i in xrange(0, n):
            for j in xrange(i + 1, n + 1):
                substr = s[i:j]
                if self.isPalindrome(substr) and len(substr) &gt; longest:
                    longest = len(substr)
                    left, right = i, j
        # construct longest substr
        result = s[left:right]
        return result

    def isPalindrome(self, s):
        if not s:
            return False
        # reverse compare
        return s == s[::-1]
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param s input string
     * @return the longest palindromic substring
     */
    string longestPalindrome(string&amp; s) {
        string result;
        if (s.empty()) return s;

        int n = s.size();
        int longest = 0, left = 0, right = 0;
        for (int i = 0; i &lt; n; ++i) {
            for (int j = i + 1; j &lt;= n; ++j) {
                string substr = s.substr(i, j - i);
                if (isPalindrome(substr) &amp;&amp; substr.size() &gt; longest) {
                    longest = j - i;
                    left = i;
                    right = j;
                }
            }
        }

        result = s.substr(left, right - left);
        return result;
    }

private:
    bool isPalindrome(string &amp;s) {
        int n = s.size();
        for (int i = 0; i &lt; n; ++i) {
            if (s[i] != s[n - i - 1]) return false;
        }
        return true;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param s input string
     * @return the longest palindromic substring
     */
    public String longestPalindrome(String s) {
        String result = new String();
        if (s == null || s.isEmpty()) return result;

        int n = s.length();
        int longest = 0, left = 0, right = 0;
        for (int i = 0; i &lt; n; i++) {
            for (int j = i + 1; j &lt;= n; j++) {
                String substr = s.substring(i, j);
                if (isPalindrome(substr) &amp;&amp; substr.length() &gt; longest) {
                    longest = substr.length();
                    left = i;
                    right = j;
                }
            }
        }

        result = s.substring(left, right);
        return result;
    }

    private boolean isPalindrome(String s) {
        if (s == null || s.isEmpty()) return false;

        int n = s.length();
        for (int i = 0; i &lt; n; i++) {
            if (s.charAt(i) != s.charAt(n - i - 1)) return false;
        }

        return true;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>使用<code>left</code>, <code>right</code>作為子串的起止索引，用於最後構造返回結果，避免中間構造字串以減少開銷。</p>
<h3>複雜度分析</h3>
<p>窮舉所有的子串，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msubsup><mi>C</mi><mi>n</mi><mn>2</mn></msubsup><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(C_n^2) = O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist"><span style="top:0.247em;margin-left:-0.07153em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>, 每次判斷字符串是否為回文，複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 故總的時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>. 故大數據集下可能 TLE. 使用了<code>substr</code>作為臨時子串，空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h2>題解2 - 動態規劃(dynamic programming)</h2>
<p>要改善效率，可以觀察哪邊有重複而冗餘的計算，例如已知&quot;bab&quot;為回文的情況下，若前後各加一個相同的字元，&quot;cbabc&quot;，當然也是回文。
因此可以使用動態規劃，將先前的結果儲存起來，假設字串<code>s</code>的長度為<code>n</code>，我們創建一個<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>×</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(n\times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">×</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>的bool值矩陣<code>P</code>，<code>P[i, j], i&lt;= j</code>表示由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><msub><mi>s</mi><mi>i</mi></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>s</mi><mi>j</mi></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">[s_i, ..., s_j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord"><span class="mord mathit">s</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">s</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">]</span></span></span></span>構成的子串是否為回文。就可以得到一個與子結構關係<br>
<code>P[i, j] = P[i+1, j-1] AND s[i] == s[j]</code></p>
<p>而基本狀態為<br>
<code>P[i, i] = true</code>
<br>與<br>
<code>P[i, i+1] = (s[i] == s[i+1])</code></p>
<p>因此可以整理成程式碼如下</p>
<pre><code class="lang-c++">string longestPalindrome(string s) {
    int n = s.length();
    int maxBegin = 0;
    int maxLen = 1;
    bool table[1000][1000] = {false};

    for (int i = 0; i &lt; n; i++) {
        table[i][i] = true;
    }

    for (int i = 0; i &lt; n-1; i++) {
            if (s[i] == s[i+1]) {
            table[i][i+1] = true;
            maxBegin = i;
            maxLen = 2;
        }
    }
    for (int len = 3; len &lt;= n; len++) {
        for (int i = 0; i &lt; n-len+1; i++) {
            int j = i+len-1;
            if (s[i] == s[j] &amp;&amp; table[i+1][j-1]) {
                table[i][j] = true;
                maxBegin = i;
                maxLen = len;
            }
        }
    }
    return s.substr(maxBegin, maxLen);
}
</code></pre>
<h3>複雜度分析</h3>
<p>仍然是兩層迴圈，但每次迴圈內部只有常數次操作，因此時間複雜度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>，另外空間複雜度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span></p>
<h2>題解 3 - Manacher&#39;s Algorithm</h2>
<h2>Reference</h2>
<ul>
<li><a href="http://articles.leetcode.com/2011/11/longest-palindromic-substring-part-i.html">Longest Palindromic Substring Part I | LeetCode</a></li>
<li><a href="http://articles.leetcode.com/2011/11/longest-palindromic-substring-part-ii.html">Longest Palindromic Substring Part II | LeetCode</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Longest Palindromic Substring</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解1---窮舉搜索brute-force">題解1 - 窮舉搜索(brute force)</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#題解2---動態規劃dynamic-programming">題解2 - 動態規劃(dynamic programming)</a></li>
<li><a href="#題解-3---manachers-algorithm">題解 3 - Manacher&#39;s Algorithm</a></li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<ul>
<li>tags: [palindrome]</li>
</ul>
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/longest-palindromic-substring/">Longest Palindromic Substring | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/longest-palindromic-substring/">(200) Longest Palindromic Substring</a></li>
</ul>
<pre><code>Given a string S, find the longest palindromic substring in S.
You may assume that the maximum length of S is 1000,
and there exists one unique longest palindromic substring.

Example
Given the string = &quot;abcdzdcab&quot;, return &quot;cdzdc&quot;.
Challenge
O(n2) time is acceptable. Can you do it in O(n) time.
</code></pre><h2>題解1 - 窮舉搜索(brute force)</h2>
<p>最簡單的方案，窮舉所有可能的子串，判斷子串是否為回文，使用一變數記錄最大回文長度，若新的回文超過之前的最大回文長度則更新標記變數並記錄當前回文的起止索引，最後返回最長回文子串。</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    # @param {string} s input string
    # @return {string} the longest palindromic substring
    def longestPalindrome(self, s):
        if not s:
            return &quot;&quot;

        n = len(s)
        longest, left, right = 0, 0, 0
        for i in xrange(0, n):
            for j in xrange(i + 1, n + 1):
                substr = s[i:j]
                if self.isPalindrome(substr) and len(substr) &gt; longest:
                    longest = len(substr)
                    left, right = i, j
        # construct longest substr
        result = s[left:right]
        return result

    def isPalindrome(self, s):
        if not s:
            return False
        # reverse compare
        return s == s[::-1]
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param s input string
     * @return the longest palindromic substring
     */
    string longestPalindrome(string&amp; s) {
        string result;
        if (s.empty()) return s;

        int n = s.size();
        int longest = 0, left = 0, right = 0;
        for (int i = 0; i &lt; n; ++i) {
            for (int j = i + 1; j &lt;= n; ++j) {
                string substr = s.substr(i, j - i);
                if (isPalindrome(substr) &amp;&amp; substr.size() &gt; longest) {
                    longest = j - i;
                    left = i;
                    right = j;
                }
            }
        }

        result = s.substr(left, right - left);
        return result;
    }

private:
    bool isPalindrome(string &amp;s) {
        int n = s.size();
        for (int i = 0; i &lt; n; ++i) {
            if (s[i] != s[n - i - 1]) return false;
        }
        return true;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param s input string
     * @return the longest palindromic substring
     */
    public String longestPalindrome(String s) {
        String result = new String();
        if (s == null || s.isEmpty()) return result;

        int n = s.length();
        int longest = 0, left = 0, right = 0;
        for (int i = 0; i &lt; n; i++) {
            for (int j = i + 1; j &lt;= n; j++) {
                String substr = s.substring(i, j);
                if (isPalindrome(substr) &amp;&amp; substr.length() &gt; longest) {
                    longest = substr.length();
                    left = i;
                    right = j;
                }
            }
        }

        result = s.substring(left, right);
        return result;
    }

    private boolean isPalindrome(String s) {
        if (s == null || s.isEmpty()) return false;

        int n = s.length();
        for (int i = 0; i &lt; n; i++) {
            if (s.charAt(i) != s.charAt(n - i - 1)) return false;
        }

        return true;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>使用<code>left</code>, <code>right</code>作為子串的起止索引，用於最後構造返回結果，避免中間構造字串以減少開銷。</p>
<h3>複雜度分析</h3>
<p>窮舉所有的子串，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msubsup><mi>C</mi><mi>n</mi><mn>2</mn></msubsup><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(C_n^2) = O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist"><span style="top:0.247em;margin-left:-0.07153em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>, 每次判斷字符串是否為回文，複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 故總的時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>. 故大數據集下可能 TLE. 使用了<code>substr</code>作為臨時子串，空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h2>題解2 - 動態規劃(dynamic programming)</h2>
<p>要改善效率，可以觀察哪邊有重複而冗餘的計算，例如已知&quot;bab&quot;為回文的情況下，若前後各加一個相同的字元，&quot;cbabc&quot;，當然也是回文。
因此可以使用動態規劃，將先前的結果儲存起來，假設字串<code>s</code>的長度為<code>n</code>，我們創建一個<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>×</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(n\times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">×</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>的bool值矩陣<code>P</code>，<code>P[i, j], i&lt;= j</code>表示由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><msub><mi>s</mi><mi>i</mi></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>s</mi><mi>j</mi></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">[s_i, ..., s_j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord"><span class="mord mathit">s</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mpunct">,</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">s</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">]</span></span></span></span>構成的子串是否為回文。就可以得到一個與子結構關係<br>
<code>P[i, j] = P[i+1, j-1] AND s[i] == s[j]</code></p>
<p>而基本狀態為<br>
<code>P[i, i] = true</code>
<br>與<br>
<code>P[i, i+1] = (s[i] == s[i+1])</code></p>
<p>因此可以整理成程式碼如下</p>
<pre><code class="lang-c++">string longestPalindrome(string s) {
    int n = s.length();
    int maxBegin = 0;
    int maxLen = 1;
    bool table[1000][1000] = {false};

    for (int i = 0; i &lt; n; i++) {
        table[i][i] = true;
    }

    for (int i = 0; i &lt; n-1; i++) {
            if (s[i] == s[i+1]) {
            table[i][i+1] = true;
            maxBegin = i;
            maxLen = 2;
        }
    }
    for (int len = 3; len &lt;= n; len++) {
        for (int i = 0; i &lt; n-len+1; i++) {
            int j = i+len-1;
            if (s[i] == s[j] &amp;&amp; table[i+1][j-1]) {
                table[i][j] = true;
                maxBegin = i;
                maxLen = len;
            }
        }
    }
    return s.substr(maxBegin, maxLen);
}
</code></pre>
<h3>複雜度分析</h3>
<p>仍然是兩層迴圈，但每次迴圈內部只有常數次操作，因此時間複雜度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>，另外空間複雜度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span></p>
<h2>題解 3 - Manacher&#39;s Algorithm</h2>
<h2>Reference</h2>
<ul>
<li><a href="http://articles.leetcode.com/2011/11/longest-palindromic-substring-part-i.html">Longest Palindromic Substring Part I | LeetCode</a></li>
<li><a href="http://articles.leetcode.com/2011/11/longest-palindromic-substring-part-ii.html">Longest Palindromic Substring Part II | LeetCode</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Space Replacement]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/string/space_replacement.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/string/space_replacement.html">
        </link>
        <updated>2019-11-03T15:42:07Z</updated>
        <summary type="html"><![CDATA[<h1>Space Replacement</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/space-replacement/">(212) Space Replacement</a></li>
</ul>
<pre><code>Write a method to replace all spaces in a string with %20. 
The string is given in a characters array, you can assume it has enough space 
for replacement and you are given the true length of the string.

Example
Given &quot;Mr John Smith&quot;, length = 13.

The string after replacement should be &quot;Mr%20John%20Smith&quot;.

Note
If you are using Java or Python，please use characters array instead of string.

Challenge
Do it in-place.
</code></pre><h2>題解</h2>
<p>根據題意，給定的輸入陣列長度足夠長，將空格替換為<code>%20</code> 後也不會overflow。通常的思維為從前向後遍歷，遇到空格即將<code>%20</code> 插入到新陣列中，這種方法在生成新陣列時很直觀，但要求原地替換時就不方便了，這時可聯想到插入排序的做法——從後往前遍歷，空格處標記下就好了。由於不知道新陣列的長度，故首先需要遍歷一次原陣列，字符串類題中常用方法。</p>
<p>需要注意的是這個題並未說明多個空格如何處理，如果多個連續空格也當做一個空格時稍有不同。</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param string: An array of Char
     * @param length: The true length of the string
     * @return: The true length of new string
     */
    public int replaceBlank(char[] string, int length) {
        if (string == null) return 0;

        int space = 0;
        for (char c : string) {
            if (c == &#39; &#39;) space++;
        }

        int r = length + 2 * space - 1;
        for (int i = length - 1; i &gt;= 0; i--) {
            if (string[i] != &#39; &#39;) {
                string[r] = string[i];
                r--;
            } else {
                string[r--] = &#39;0&#39;;
                string[r--] = &#39;2&#39;;
                string[r--] = &#39;%&#39;;
            }
        }

        return length + 2 * space;
    }
}
</code></pre>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param string: An array of Char
     * @param length: The true length of the string
     * @return: The true length of new string
     */
    int replaceBlank(char string[], int length) {
        int space = 0;
        for (int i = 0; i &lt; length; i++) {
            if (string[i] == &#39; &#39;) space++;
        }

        int r = length + 2 * space - 1;
        for (int i = length - 1; i &gt;= 0; i--) {
            if (string[i] != &#39; &#39;) {
                string[r] = string[i];
                r--;
            } else {
                string[r--] = &#39;0&#39;;
                string[r--] = &#39;2&#39;;
                string[r--] = &#39;%&#39;;
            }
        }

        return length + 2 * space;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>先遍歷一遍求得空格數，得到『新陣列』的實際長度，從後往前遍歷。</p>
<h3>複雜度分析</h3>
<p>遍歷兩次原陣列，時間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 使用了<code>r</code> 作為標記，空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Space Replacement</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/space-replacement/">(212) Space Replacement</a></li>
</ul>
<pre><code>Write a method to replace all spaces in a string with %20. 
The string is given in a characters array, you can assume it has enough space 
for replacement and you are given the true length of the string.

Example
Given &quot;Mr John Smith&quot;, length = 13.

The string after replacement should be &quot;Mr%20John%20Smith&quot;.

Note
If you are using Java or Python，please use characters array instead of string.

Challenge
Do it in-place.
</code></pre><h2>題解</h2>
<p>根據題意，給定的輸入陣列長度足夠長，將空格替換為<code>%20</code> 後也不會overflow。通常的思維為從前向後遍歷，遇到空格即將<code>%20</code> 插入到新陣列中，這種方法在生成新陣列時很直觀，但要求原地替換時就不方便了，這時可聯想到插入排序的做法——從後往前遍歷，空格處標記下就好了。由於不知道新陣列的長度，故首先需要遍歷一次原陣列，字符串類題中常用方法。</p>
<p>需要注意的是這個題並未說明多個空格如何處理，如果多個連續空格也當做一個空格時稍有不同。</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param string: An array of Char
     * @param length: The true length of the string
     * @return: The true length of new string
     */
    public int replaceBlank(char[] string, int length) {
        if (string == null) return 0;

        int space = 0;
        for (char c : string) {
            if (c == &#39; &#39;) space++;
        }

        int r = length + 2 * space - 1;
        for (int i = length - 1; i &gt;= 0; i--) {
            if (string[i] != &#39; &#39;) {
                string[r] = string[i];
                r--;
            } else {
                string[r--] = &#39;0&#39;;
                string[r--] = &#39;2&#39;;
                string[r--] = &#39;%&#39;;
            }
        }

        return length + 2 * space;
    }
}
</code></pre>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param string: An array of Char
     * @param length: The true length of the string
     * @return: The true length of new string
     */
    int replaceBlank(char string[], int length) {
        int space = 0;
        for (int i = 0; i &lt; length; i++) {
            if (string[i] == &#39; &#39;) space++;
        }

        int r = length + 2 * space - 1;
        for (int i = length - 1; i &gt;= 0; i--) {
            if (string[i] != &#39; &#39;) {
                string[r] = string[i];
                r--;
            } else {
                string[r--] = &#39;0&#39;;
                string[r--] = &#39;2&#39;;
                string[r--] = &#39;%&#39;;
            }
        }

        return length + 2 * space;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>先遍歷一遍求得空格數，得到『新陣列』的實際長度，從後往前遍歷。</p>
<h3>複雜度分析</h3>
<p>遍歷兩次原陣列，時間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 使用了<code>r</code> 作為標記，空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Count and Say]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/string/count_and_say.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/string/count_and_say.html">
        </link>
        <updated>2019-11-03T15:42:07Z</updated>
        <summary type="html"><![CDATA[<h1>Count and Say</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/count-and-say/">Count and Say | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/count-and-say/">(420) Count and Say</a></li>
</ul>
<pre><code>The count-and-say sequence is the sequence of integers beginning as follows:

1, 11, 21, 1211, 111221, ...

1 is read off as &quot;one 1&quot; or 11.

11 is read off as &quot;two 1s&quot; or 21.

21 is read off as &quot;one 2, then one 1&quot; or 1211.

Given an integer n, generate the nth sequence.

Example
Given n = 5, return &quot;111221&quot;.

Note
The sequence of integers will be represented as a string.
</code></pre><h2>題解</h2>
<p>題目大意是找第 n 個數(字符串表示)，規則則是對於連續字符串，表示為重複次數+數本身。純粹是implementation的題目，小心處理實現細節就可以。</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param n the nth
     * @return the nth sequence
     */
    public String countAndSay(int n) {
        if (n &lt;= 0) return null;

        String s = &quot;1&quot;;
        for (int i = 1; i &lt; n; i++) {
            int count = 1;
            StringBuilder sb = new StringBuilder();
            int sLen = s.length();
            for (int j = 0; j &lt; sLen; j++) {
                if (j &lt; sLen - 1 &amp;&amp; s.charAt(j) == s.charAt(j + 1)) {
                    count++;
                } else {
                    sb.append(count + &quot;&quot; + s.charAt(j));
                    // reset
                    count = 1;
                }
            }
            s = sb.toString();
        }

        return s;
    }
}
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    string countAndSay(int n) {
        string s = &quot;1&quot;;
        if(n &lt;= 1) return s;
        stringstream ss;
        while(n-- &gt; 1){
            int count = 1;
            for(int j = 0; j &lt; s.size(); j++){
                if(j &lt; s.size()-1 and s[j] == s[j+1]){
                    count++;
                }
                else{
                    ss &lt;&lt; count &lt;&lt; s[j];
                    count = 1;
                }
            }
            s = ss.str();
            ss.str(&quot;&quot;);
        }
        return s;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>字符串是動態生成的，故使用 StringBuilder 更為合適。注意s 初始化為&quot;1&quot;, 第一重 for循環中注意循環的次數為 n-1.</p>
<h3>複雜度分析</h3>
<p>略</p>
<h2>Reference</h2>
<ul>
<li><a href="http://huntfor.iteye.com/blog/2059877">[leetcode]Count and Say - 喵星人與汪星人</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Count and Say</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/count-and-say/">Count and Say | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/count-and-say/">(420) Count and Say</a></li>
</ul>
<pre><code>The count-and-say sequence is the sequence of integers beginning as follows:

1, 11, 21, 1211, 111221, ...

1 is read off as &quot;one 1&quot; or 11.

11 is read off as &quot;two 1s&quot; or 21.

21 is read off as &quot;one 2, then one 1&quot; or 1211.

Given an integer n, generate the nth sequence.

Example
Given n = 5, return &quot;111221&quot;.

Note
The sequence of integers will be represented as a string.
</code></pre><h2>題解</h2>
<p>題目大意是找第 n 個數(字符串表示)，規則則是對於連續字符串，表示為重複次數+數本身。純粹是implementation的題目，小心處理實現細節就可以。</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param n the nth
     * @return the nth sequence
     */
    public String countAndSay(int n) {
        if (n &lt;= 0) return null;

        String s = &quot;1&quot;;
        for (int i = 1; i &lt; n; i++) {
            int count = 1;
            StringBuilder sb = new StringBuilder();
            int sLen = s.length();
            for (int j = 0; j &lt; sLen; j++) {
                if (j &lt; sLen - 1 &amp;&amp; s.charAt(j) == s.charAt(j + 1)) {
                    count++;
                } else {
                    sb.append(count + &quot;&quot; + s.charAt(j));
                    // reset
                    count = 1;
                }
            }
            s = sb.toString();
        }

        return s;
    }
}
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    string countAndSay(int n) {
        string s = &quot;1&quot;;
        if(n &lt;= 1) return s;
        stringstream ss;
        while(n-- &gt; 1){
            int count = 1;
            for(int j = 0; j &lt; s.size(); j++){
                if(j &lt; s.size()-1 and s[j] == s[j+1]){
                    count++;
                }
                else{
                    ss &lt;&lt; count &lt;&lt; s[j];
                    count = 1;
                }
            }
            s = ss.str();
            ss.str(&quot;&quot;);
        }
        return s;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>字符串是動態生成的，故使用 StringBuilder 更為合適。注意s 初始化為&quot;1&quot;, 第一重 for循環中注意循環的次數為 n-1.</p>
<h3>複雜度分析</h3>
<p>略</p>
<h2>Reference</h2>
<ul>
<li><a href="http://huntfor.iteye.com/blog/2059877">[leetcode]Count and Say - 喵星人與汪星人</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Integer Array]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/integer_array/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/integer_array/">
        </link>
        <updated>2019-11-03T15:42:07Z</updated>
        <summary type="html"><![CDATA[<h1>Integer Array - 整數型陣列</h1>
<p>本章主要總結與整數型陣列相關的題目。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Integer Array - 整數型陣列</h1>
<p>本章主要總結與整數型陣列相關的題目。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Remove Element]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/integer_array/remove_element.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/integer_array/remove_element.html">
        </link>
        <updated>2019-11-03T15:42:08Z</updated>
        <summary type="html"><![CDATA[<h1>Remove Element</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解1---使用容器">題解1 - 使用容器</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
<li><a href="#題解2---兩根指針">題解2 - 兩根指針</a></li>
<li><a href="#c-1">C++</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/remove-element/">Remove Element | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/remove-element/">(172) Remove Element</a></li>
</ul>
<pre><code>Given an array and a value, remove all occurrences of that value in place and return the new length.

The order of elements can be changed, and the elements after the new length don&#39;t matter.

Example
Given an array [0,4,4,0,0,2,4,4], value=4

return 4 and front four elements of the array is [0,0,0,2]
</code></pre><h2>題解1 - 使用容器</h2>
<p>入門題，返回刪除指定元素後的陣列長度，使用容器操作非常簡單。以 lintcode 上給出的參數為例，遍歷容器內元素，若元素值與給定刪除值相等，刪除當前元素並往後繼續遍歷。
C++的vector已經支援了刪除操作，因此可以直接拿來使用。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     *@param A: A list of integers
     *@param elem: An integer
     *@return: The new length after remove
     */
    int removeElement(vector&lt;int&gt; &amp;A, int elem) {
        for (vector&lt;int&gt;::iterator iter = A.begin(); iter &lt; A.end(); ++iter) {
            if (*iter == elem) {
                iter = A.erase(iter);
                --iter;
            }
        }

        return A.size();
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>注意在遍歷容器內元素和指定欲刪除值相等時，需要先自減<code>--iter</code>, 因為<code>for</code>循環會對<code>iter</code>自增，<code>A.erase()</code>刪除當前元素值並返回指向下一個元素的指針，一增一減正好平衡。如果改用<code>while</code>循環，則需注意訪問陣列時是否越界。</p>
<h3>複雜度分析</h3>
<!--- 沒啥好分析的，遍歷一次陣列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. -->
<p>由於vector每次erase的複雜度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>，我們遍歷整個向量，最壞情況下，每個元素都與要刪除的目標元素相等，每次都要刪除元素的複雜度高達<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>
觀察此方法會如此低效的原因，是因為我們一次只刪除一個元素，導致很多沒必要的元素交換移動，如果能夠將要刪除的元素集中處理，則可以大幅增加效率，見題解2。</p>
<h3>題解2 - 兩根指針</h3>
<p>由於題中明確暗示元素的順序可變，且新長度後的元素不用理會。我們可以使用兩根指針分別往前往後遍歷，頭指針用於指示當前遍歷的元素位置，尾指針則用於在當前元素與欲刪除值相等時替換當前元素，兩根指針相遇時返回尾指針索引——即刪除元素後「新陣列」的長度。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    int removeElement(int A[], int n, int elem) {
        for (int i = 0; i &lt; n; ++i) {
            if (A[i] == elem) {
                A[i] = A[n - 1];
                --i;
                --n;
            }
        }

        return n;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>遍歷當前陣列，<code>A[i] == elem</code>時將陣列「尾部(以 n 為長度時的尾部)」元素賦給當前遍歷的元素。同時自減<code>i</code>和<code>n</code>，原因見題解1的分析。需要注意的是<code>n</code>在遍歷過程中可能會變化。</p>
<h3>複雜度分析</h3>
<p>此方法只遍歷一次陣列，且每個循環的操作至多也不過僅是常數次，因此時間複雜度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>。</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.jiuzhang.com/solutions/remove-element/">Remove Element | 九章算法</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Remove Element</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解1---使用容器">題解1 - 使用容器</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
<li><a href="#題解2---兩根指針">題解2 - 兩根指針</a></li>
<li><a href="#c-1">C++</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/remove-element/">Remove Element | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/remove-element/">(172) Remove Element</a></li>
</ul>
<pre><code>Given an array and a value, remove all occurrences of that value in place and return the new length.

The order of elements can be changed, and the elements after the new length don&#39;t matter.

Example
Given an array [0,4,4,0,0,2,4,4], value=4

return 4 and front four elements of the array is [0,0,0,2]
</code></pre><h2>題解1 - 使用容器</h2>
<p>入門題，返回刪除指定元素後的陣列長度，使用容器操作非常簡單。以 lintcode 上給出的參數為例，遍歷容器內元素，若元素值與給定刪除值相等，刪除當前元素並往後繼續遍歷。
C++的vector已經支援了刪除操作，因此可以直接拿來使用。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     *@param A: A list of integers
     *@param elem: An integer
     *@return: The new length after remove
     */
    int removeElement(vector&lt;int&gt; &amp;A, int elem) {
        for (vector&lt;int&gt;::iterator iter = A.begin(); iter &lt; A.end(); ++iter) {
            if (*iter == elem) {
                iter = A.erase(iter);
                --iter;
            }
        }

        return A.size();
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>注意在遍歷容器內元素和指定欲刪除值相等時，需要先自減<code>--iter</code>, 因為<code>for</code>循環會對<code>iter</code>自增，<code>A.erase()</code>刪除當前元素值並返回指向下一個元素的指針，一增一減正好平衡。如果改用<code>while</code>循環，則需注意訪問陣列時是否越界。</p>
<h3>複雜度分析</h3>
<!--- 沒啥好分析的，遍歷一次陣列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. -->
<p>由於vector每次erase的複雜度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>，我們遍歷整個向量，最壞情況下，每個元素都與要刪除的目標元素相等，每次都要刪除元素的複雜度高達<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>
觀察此方法會如此低效的原因，是因為我們一次只刪除一個元素，導致很多沒必要的元素交換移動，如果能夠將要刪除的元素集中處理，則可以大幅增加效率，見題解2。</p>
<h3>題解2 - 兩根指針</h3>
<p>由於題中明確暗示元素的順序可變，且新長度後的元素不用理會。我們可以使用兩根指針分別往前往後遍歷，頭指針用於指示當前遍歷的元素位置，尾指針則用於在當前元素與欲刪除值相等時替換當前元素，兩根指針相遇時返回尾指針索引——即刪除元素後「新陣列」的長度。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    int removeElement(int A[], int n, int elem) {
        for (int i = 0; i &lt; n; ++i) {
            if (A[i] == elem) {
                A[i] = A[n - 1];
                --i;
                --n;
            }
        }

        return n;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>遍歷當前陣列，<code>A[i] == elem</code>時將陣列「尾部(以 n 為長度時的尾部)」元素賦給當前遍歷的元素。同時自減<code>i</code>和<code>n</code>，原因見題解1的分析。需要注意的是<code>n</code>在遍歷過程中可能會變化。</p>
<h3>複雜度分析</h3>
<p>此方法只遍歷一次陣列，且每個循環的操作至多也不過僅是常數次，因此時間複雜度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>。</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.jiuzhang.com/solutions/remove-element/">Remove Element | 九章算法</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[First Missing Positive]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/integer_array/first_missing_positive.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/integer_array/first_missing_positive.html">
        </link>
        <updated>2019-11-03T15:42:08Z</updated>
        <summary type="html"><![CDATA[<h1>First Missing Positive</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/first-missing-positive/">First Missing Positive | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/first-missing-positive/">(189) First Missing Positive</a></li>
</ul>
<pre><code>Given an unsorted integer array, find the first missing positive integer.

Example
Given [1,2,0] return 3, and [3,4,-1,1] return 2.

Challenge
Your algorithm should run in O(n) time and uses constant space.
</code></pre><h2>題解</h2>
<p>容易想到的方案是先排序，然後遍歷求得缺的最小整數。排序算法中常用的基於比較的方法時間複雜度的理論下界為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 不符題目要求。常見的能達到線性時間複雜度的排序算法有 <a href="http://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基數排序</a>，<a href="http://algorithm.yuanbin.zh-hans/basics_sorting/counting_sort.html">計數排序</a> 和 <a href="http://algorithm.yuanbin.zh-hans/basics_sorting/bucket_sort.html">桶排序</a>。</p>
<p>基數排序顯然不太適合這道題，計數排序對元素落在一定區間且重複值較多的情況十分有效，且需要額外的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 空間，對這道題不太合適。最後就只剩下桶排序了，桶排序通常需要按照一定規則將值放入桶中，一般需要額外的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 空間，乍看之下似乎不太適合在這道題中使用，但是若能設定一定的規則原地交換原數組的值呢？這道題的難點就在於這種規則的設定。</p>
<p>設想我們對給定數組使用桶排序的思想排序，第一個桶放1，第二個桶放2，如果找不到相應的數，則相應的桶的值不變(可能為負值，也可能為其他值)。</p>
<p>那麼怎麼才能做到原地排序呢？即若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">A[i] = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit">x</span></span></span></span>, 則將 x 放到它該去的地方 - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">A[x - 1] = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit">x</span></span></span></span>, 同時將原來 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">A[x - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> 地方的值交換給 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">A[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span></span></span></span>.</p>
<p>排好序後遍歷桶，如果不滿足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f[i] = i + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit">i</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span>, 那麼警察叔叔就是它了！如果都滿足條件怎麼辦？那就返回給定數組大小再加1唄。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param A: a vector of integers
     * @return: an integer
     */
    int firstMissingPositive(vector&lt;int&gt; A) {
        const int size = A.size();

        for (int i = 0; i &lt; size; ++i) {
            while (0 &lt; A[i]  &amp;&amp; A[i] &lt;= size &amp;&amp;
                  (A[i] != i + 1) &amp;&amp; (A[i] != A[A[i] - 1])) {
                int temp = A[A[i] - 1];
                A[A[i] - 1] = A[i];
                A[i] = temp;
            }
        }

        for (int i = 0; i &lt; size; ++i) {
            if (A[i] != i + 1) {
                return i + 1;
            }
        }

        return size + 1;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>核心程式為那幾行交換，但是要正確處理各種邊界條件則要下一番功夫了，要能正常的交換，需滿足以下幾個條件：</p>
<ol>
<li><code>A[i]</code> 為正數，負數和零都無法在桶中找到生存空間...</li>
<li><code>A[i] \leq size</code> 當前索引處的值不能比原陣列容量大，大了的話也沒用啊，一定不是缺的第一個正數。</li>
<li><code>A[i] != i + 1</code>, 都滿足條件了就不用交換了。</li>
<li><code>A[i] != A[A[i] - 1]</code>, 避免欲交換的值和自身相同，否則有重複值時會產生死循環。</li>
</ol>
<p>如果滿足以上四個條件就可以愉快地交換彼此了，使用<code>while</code>循環處理，此時<code>i</code>並不自增，直到將所有滿足條件的索引處理完。</p>
<p>注意交換的寫法，若寫成</p>
<pre><code class="lang-c">int temp = A[i];
A[i] = A[A[i] - 1];
A[A[i] - 1] = temp;
</code></pre>
<p>這又是滿滿的 bug :( 因為在第三行中<code>A[i]</code>已不再是之前的值，第二行賦值時已經改變，故源碼中的寫法比較安全。</p>
<p>最後遍歷桶排序後的數組，若在數組大小範圍內找到不滿足條件的解，直接返回，否則就意味著原數組給的元素都是從1開始的連續正整數，返回數組大小加1即可。</p>
<h3>複雜度分析</h3>
<p>「桶排序」需要遍歷一次原數組，考慮到<code>while</code>循環也需要一定次數的遍歷，故時間複雜度至少為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 最後求索引值最多遍歷一次排序後數組，時間複雜度最高為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 用到了<code>temp</code>作為中間交換，空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><a href="http://n00tc0d3r.blogspot.com/2013/03/find-first-missing-positive.html">Find First Missing Positive | N00tc0d3r</a></li>
<li><a href="http://www.cnblogs.com/yuzhangcmu/p/4200096.html">LeetCode: First Missing Positive 解題報告 - Yu&#39;s Garden - 博客園</a></li>
<li><a href="http://www.jiuzhang.com/solutions/first-missing-positive/">First Missing Positive | 九章算法</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>First Missing Positive</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/first-missing-positive/">First Missing Positive | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/first-missing-positive/">(189) First Missing Positive</a></li>
</ul>
<pre><code>Given an unsorted integer array, find the first missing positive integer.

Example
Given [1,2,0] return 3, and [3,4,-1,1] return 2.

Challenge
Your algorithm should run in O(n) time and uses constant space.
</code></pre><h2>題解</h2>
<p>容易想到的方案是先排序，然後遍歷求得缺的最小整數。排序算法中常用的基於比較的方法時間複雜度的理論下界為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 不符題目要求。常見的能達到線性時間複雜度的排序算法有 <a href="http://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基數排序</a>，<a href="http://algorithm.yuanbin.zh-hans/basics_sorting/counting_sort.html">計數排序</a> 和 <a href="http://algorithm.yuanbin.zh-hans/basics_sorting/bucket_sort.html">桶排序</a>。</p>
<p>基數排序顯然不太適合這道題，計數排序對元素落在一定區間且重複值較多的情況十分有效，且需要額外的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 空間，對這道題不太合適。最後就只剩下桶排序了，桶排序通常需要按照一定規則將值放入桶中，一般需要額外的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 空間，乍看之下似乎不太適合在這道題中使用，但是若能設定一定的規則原地交換原數組的值呢？這道題的難點就在於這種規則的設定。</p>
<p>設想我們對給定數組使用桶排序的思想排序，第一個桶放1，第二個桶放2，如果找不到相應的數，則相應的桶的值不變(可能為負值，也可能為其他值)。</p>
<p>那麼怎麼才能做到原地排序呢？即若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">A[i] = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit">x</span></span></span></span>, 則將 x 放到它該去的地方 - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">A[x - 1] = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit">x</span></span></span></span>, 同時將原來 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">A[x - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span> 地方的值交換給 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">A[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span></span></span></span>.</p>
<p>排好序後遍歷桶，如果不滿足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f[i] = i + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit">i</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span>, 那麼警察叔叔就是它了！如果都滿足條件怎麼辦？那就返回給定數組大小再加1唄。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param A: a vector of integers
     * @return: an integer
     */
    int firstMissingPositive(vector&lt;int&gt; A) {
        const int size = A.size();

        for (int i = 0; i &lt; size; ++i) {
            while (0 &lt; A[i]  &amp;&amp; A[i] &lt;= size &amp;&amp;
                  (A[i] != i + 1) &amp;&amp; (A[i] != A[A[i] - 1])) {
                int temp = A[A[i] - 1];
                A[A[i] - 1] = A[i];
                A[i] = temp;
            }
        }

        for (int i = 0; i &lt; size; ++i) {
            if (A[i] != i + 1) {
                return i + 1;
            }
        }

        return size + 1;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>核心程式為那幾行交換，但是要正確處理各種邊界條件則要下一番功夫了，要能正常的交換，需滿足以下幾個條件：</p>
<ol>
<li><code>A[i]</code> 為正數，負數和零都無法在桶中找到生存空間...</li>
<li><code>A[i] \leq size</code> 當前索引處的值不能比原陣列容量大，大了的話也沒用啊，一定不是缺的第一個正數。</li>
<li><code>A[i] != i + 1</code>, 都滿足條件了就不用交換了。</li>
<li><code>A[i] != A[A[i] - 1]</code>, 避免欲交換的值和自身相同，否則有重複值時會產生死循環。</li>
</ol>
<p>如果滿足以上四個條件就可以愉快地交換彼此了，使用<code>while</code>循環處理，此時<code>i</code>並不自增，直到將所有滿足條件的索引處理完。</p>
<p>注意交換的寫法，若寫成</p>
<pre><code class="lang-c">int temp = A[i];
A[i] = A[A[i] - 1];
A[A[i] - 1] = temp;
</code></pre>
<p>這又是滿滿的 bug :( 因為在第三行中<code>A[i]</code>已不再是之前的值，第二行賦值時已經改變，故源碼中的寫法比較安全。</p>
<p>最後遍歷桶排序後的數組，若在數組大小範圍內找到不滿足條件的解，直接返回，否則就意味著原數組給的元素都是從1開始的連續正整數，返回數組大小加1即可。</p>
<h3>複雜度分析</h3>
<p>「桶排序」需要遍歷一次原數組，考慮到<code>while</code>循環也需要一定次數的遍歷，故時間複雜度至少為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 最後求索引值最多遍歷一次排序後數組，時間複雜度最高為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 用到了<code>temp</code>作為中間交換，空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><a href="http://n00tc0d3r.blogspot.com/2013/03/find-first-missing-positive.html">Find First Missing Positive | N00tc0d3r</a></li>
<li><a href="http://www.cnblogs.com/yuzhangcmu/p/4200096.html">LeetCode: First Missing Positive 解題報告 - Yu&#39;s Garden - 博客園</a></li>
<li><a href="http://www.jiuzhang.com/solutions/first-missing-positive/">First Missing Positive | 九章算法</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2 Sum]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/integer_array/2_sum.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/integer_array/2_sum.html">
        </link>
        <updated>2019-11-03T15:42:08Z</updated>
        <summary type="html"><![CDATA[<h1>2 Sum</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解1---哈希表">題解1 - 哈希表</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
</ul>
</li>
<li><a href="#題解2---排序後使用兩根指針">題解2 - 排序後使用兩根指針</a><ul>
<li><a href="#c-1">C++</a></li>
<li><a href="#源碼分析-2">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/two-sum/">Two Sum | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/2-sum/">(56) 2 Sum</a></li>
</ul>
<pre><code>Given an array of integers, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers
such that they add up to the target, where index1 must be less than index2.
Please note that your returned answers (both index1 and index2) are not zero-based.

You may assume that each input would have exactly one solution.

Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2
</code></pre><h2>題解1 - 哈希表</h2>
<p>找兩數之和是否為<code>target</code>, 如果是找數組中一個值為<code>target</code>該多好啊！遍歷一次就知道了，我只想說，too naive... 難道要將數組中所有元素的兩兩組合都求出來與<code>target</code>比較嗎？時間複雜度顯然為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>, 顯然不符題目要求。找一個數時直接遍歷即可，那麼可不可以將兩個數之和轉換為找一個數呢？我們先來看看兩數之和為<code>target</code>所對應的判斷條件—— <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>+</mo><msub><mi>x</mi><mi>j</mi></msub><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">x_i + x_j = target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">=</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">e</span><span class="mord mathit">t</span></span></span></span>, 可進一步轉化為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>−</mo><msub><mi>x</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_i = target - x_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">=</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">e</span><span class="mord mathit">t</span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>, 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span></span> 為數組中的下標。一段神奇的數學推理就將找兩數之和轉化為了找一個數是否在數組中了！可見數學是多麼的重要...</p>
<p>基本思路有了，現在就來看看怎麼實現，顯然我們需要額外的空間(也就是哈希表)來保存已經處理過的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>, 如果不滿足等式條件，那麼我們就往後遍歷，並把之前的元素加入到哈希表中，如果<code>target</code>減去當前索引後的值在哈希表中找到了，那麼就將哈希表中相應的索引返回，大功告成！</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /*
     * @param numbers : An array of Integer
     * @param target : target = numbers[index1] + numbers[index2]
     * @return : [index1+1, index2+1] (index1 &lt; index2)
     */
    vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target) {
        vector&lt;int&gt; result;
        const int length = nums.size();
        if (0 == length) {
            return result;
        }

        // first value, second index
        unordered_map&lt;int, int&gt; hash(length);
        for (int i = 0; i != length; ++i) {
            if (hash.find(target - nums[i]) != hash.end()) {
                result.push_back(hash[target - nums[i]]);
                result.push_back(i + 1);
                return result;
            } else {
                hash[nums[i]] = i + 1;
            }
        }

        return result;
    }
};
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>異常處理。</li>
<li>使用 C++ 11 中的哈希表實現<code>unordered_map</code>映射值和索引。</li>
<li>找到滿足條件的解就返回，找不到就加入哈希表中。注意題中要求返回索引值的含義。</li>
</ol>
<h3>複雜度分析</h3>
<p>哈希表用了和數組等長的空間，空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 遍歷一次數組，時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    &quot;&quot;&quot;
    @param numbers : An array of Integer
    @param target : target = numbers[index1] + numbers[index2]
    @return : [index1 + 1, index2 + 1] (index1 &lt; index2)
    &quot;&quot;&quot;
    def twoSum(self, numbers, target):
        hashdict = {}
        for i, item in enumerate(numbers):
            if (target - item) in hashdict:
                return (hashdict[target - item] + 1, i + 1)
            hashdict[item] = i

        return (-1, -1)
</code></pre>
<h3>源碼分析</h3>
<p>Python 中的<code>dict</code>就是天然的哈希表，使用 enumerate 可以同時返回索引和值，甚為方便。按題意似乎是要返回 list, 但個人感覺返回 tuple 更為合理。最後如果未找到符合題意的索引，返回<code>(-1, -1)</code>.</p>
<h2>題解2 - 排序後使用兩根指針</h2>
<p>但凡可以用空間換時間的做法，往往也可以使用時間換空間。另外一個容易想到的思路就是先對數組排序，然後使用兩根指針分別指向首尾元素，逐步向中間靠攏，直至找到滿足條件的索引為止。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /*
     * @param numbers : An array of Integer
     * @param target : target = numbers[index1] + numbers[index2]
     * @return : [index1+1, index2+1] (index1 &lt; index2)
     */
    vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target) {
        vector&lt;int&gt; result;
        const int length = nums.size();
        if (0 == length) {
            return result;
        }

        // first num, second is index
        vector&lt;pair&lt;int, int&gt; &gt; num_index(length);
        // map num value and index
        for (int i = 0; i != length; ++i) {
            num_index[i].first = nums[i];
            num_index[i].second = i + 1;
        }

        sort(num_index.begin(), num_index.end());
        int start = 0, end = length - 1;
        while (start &lt; end) {
            if (num_index[start].first + num_index[end].first &gt; target) {
                --end;
            } else if(num_index[start].first + num_index[end].first == target) {
                int min_index = min(num_index[start].second, num_index[end].second);
                int max_index = max(num_index[start].second, num_index[end].second);
                result.push_back(min_index);
                result.push_back(max_index);
                return result;
            } else {
                ++start;
            }
        }

        return result;
    }
};
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>異常處理。</li>
<li>使用<code>length</code>保存數組的長度，避免反複調用<code>nums.size()</code>造成性能損失。</li>
<li>使用<code>pair</code>組合排序前的值和索引，避免排序後找不到原有索引信息。</li>
<li>使用標準庫函數排序。</li>
<li>兩根指針指頭尾，逐步靠攏。</li>
</ol>
<h3>複雜度分析</h3>
<p>遍歷一次原數組得到<code>pair</code>類型的新數組，時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 空間複雜度也為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 標准庫中的排序方法時間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 兩根指針遍歷數組時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<blockquote>
<p><strong>Note</strong> lintcode 上的題要求時間複雜度在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 時，空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>, 但問題是排序後索引會亂掉，如果要保存之前的索引，空間複雜度一定是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>，所以個人認為不存在較為簡潔的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span> 實現。如果一定要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 的空間複雜度，那麼只能用暴搜了，此時的時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h1>2 Sum</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解1---哈希表">題解1 - 哈希表</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
</ul>
</li>
<li><a href="#題解2---排序後使用兩根指針">題解2 - 排序後使用兩根指針</a><ul>
<li><a href="#c-1">C++</a></li>
<li><a href="#源碼分析-2">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/two-sum/">Two Sum | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/2-sum/">(56) 2 Sum</a></li>
</ul>
<pre><code>Given an array of integers, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers
such that they add up to the target, where index1 must be less than index2.
Please note that your returned answers (both index1 and index2) are not zero-based.

You may assume that each input would have exactly one solution.

Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2
</code></pre><h2>題解1 - 哈希表</h2>
<p>找兩數之和是否為<code>target</code>, 如果是找數組中一個值為<code>target</code>該多好啊！遍歷一次就知道了，我只想說，too naive... 難道要將數組中所有元素的兩兩組合都求出來與<code>target</code>比較嗎？時間複雜度顯然為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>, 顯然不符題目要求。找一個數時直接遍歷即可，那麼可不可以將兩個數之和轉換為找一個數呢？我們先來看看兩數之和為<code>target</code>所對應的判斷條件—— <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>+</mo><msub><mi>x</mi><mi>j</mi></msub><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">x_i + x_j = target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">=</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">e</span><span class="mord mathit">t</span></span></span></span>, 可進一步轉化為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>−</mo><msub><mi>x</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_i = target - x_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">=</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">e</span><span class="mord mathit">t</span><span class="mbin">−</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>, 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span></span></span></span> 為數組中的下標。一段神奇的數學推理就將找兩數之和轉化為了找一個數是否在數組中了！可見數學是多麼的重要...</p>
<p>基本思路有了，現在就來看看怎麼實現，顯然我們需要額外的空間(也就是哈希表)來保存已經處理過的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>, 如果不滿足等式條件，那麼我們就往後遍歷，並把之前的元素加入到哈希表中，如果<code>target</code>減去當前索引後的值在哈希表中找到了，那麼就將哈希表中相應的索引返回，大功告成！</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /*
     * @param numbers : An array of Integer
     * @param target : target = numbers[index1] + numbers[index2]
     * @return : [index1+1, index2+1] (index1 &lt; index2)
     */
    vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target) {
        vector&lt;int&gt; result;
        const int length = nums.size();
        if (0 == length) {
            return result;
        }

        // first value, second index
        unordered_map&lt;int, int&gt; hash(length);
        for (int i = 0; i != length; ++i) {
            if (hash.find(target - nums[i]) != hash.end()) {
                result.push_back(hash[target - nums[i]]);
                result.push_back(i + 1);
                return result;
            } else {
                hash[nums[i]] = i + 1;
            }
        }

        return result;
    }
};
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>異常處理。</li>
<li>使用 C++ 11 中的哈希表實現<code>unordered_map</code>映射值和索引。</li>
<li>找到滿足條件的解就返回，找不到就加入哈希表中。注意題中要求返回索引值的含義。</li>
</ol>
<h3>複雜度分析</h3>
<p>哈希表用了和數組等長的空間，空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 遍歷一次數組，時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    &quot;&quot;&quot;
    @param numbers : An array of Integer
    @param target : target = numbers[index1] + numbers[index2]
    @return : [index1 + 1, index2 + 1] (index1 &lt; index2)
    &quot;&quot;&quot;
    def twoSum(self, numbers, target):
        hashdict = {}
        for i, item in enumerate(numbers):
            if (target - item) in hashdict:
                return (hashdict[target - item] + 1, i + 1)
            hashdict[item] = i

        return (-1, -1)
</code></pre>
<h3>源碼分析</h3>
<p>Python 中的<code>dict</code>就是天然的哈希表，使用 enumerate 可以同時返回索引和值，甚為方便。按題意似乎是要返回 list, 但個人感覺返回 tuple 更為合理。最後如果未找到符合題意的索引，返回<code>(-1, -1)</code>.</p>
<h2>題解2 - 排序後使用兩根指針</h2>
<p>但凡可以用空間換時間的做法，往往也可以使用時間換空間。另外一個容易想到的思路就是先對數組排序，然後使用兩根指針分別指向首尾元素，逐步向中間靠攏，直至找到滿足條件的索引為止。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /*
     * @param numbers : An array of Integer
     * @param target : target = numbers[index1] + numbers[index2]
     * @return : [index1+1, index2+1] (index1 &lt; index2)
     */
    vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target) {
        vector&lt;int&gt; result;
        const int length = nums.size();
        if (0 == length) {
            return result;
        }

        // first num, second is index
        vector&lt;pair&lt;int, int&gt; &gt; num_index(length);
        // map num value and index
        for (int i = 0; i != length; ++i) {
            num_index[i].first = nums[i];
            num_index[i].second = i + 1;
        }

        sort(num_index.begin(), num_index.end());
        int start = 0, end = length - 1;
        while (start &lt; end) {
            if (num_index[start].first + num_index[end].first &gt; target) {
                --end;
            } else if(num_index[start].first + num_index[end].first == target) {
                int min_index = min(num_index[start].second, num_index[end].second);
                int max_index = max(num_index[start].second, num_index[end].second);
                result.push_back(min_index);
                result.push_back(max_index);
                return result;
            } else {
                ++start;
            }
        }

        return result;
    }
};
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>異常處理。</li>
<li>使用<code>length</code>保存數組的長度，避免反複調用<code>nums.size()</code>造成性能損失。</li>
<li>使用<code>pair</code>組合排序前的值和索引，避免排序後找不到原有索引信息。</li>
<li>使用標準庫函數排序。</li>
<li>兩根指針指頭尾，逐步靠攏。</li>
</ol>
<h3>複雜度分析</h3>
<p>遍歷一次原數組得到<code>pair</code>類型的新數組，時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 空間複雜度也為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 標准庫中的排序方法時間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 兩根指針遍歷數組時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<blockquote>
<p><strong>Note</strong> lintcode 上的題要求時間複雜度在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 時，空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>, 但問題是排序後索引會亂掉，如果要保存之前的索引，空間複雜度一定是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>，所以個人認為不存在較為簡潔的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span> 實現。如果一定要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 的空間複雜度，那麼只能用暴搜了，此時的時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[3 Sum]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/integer_array/3_sum.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/integer_array/3_sum.html">
        </link>
        <updated>2019-11-03T15:42:08Z</updated>
        <summary type="html"><![CDATA[<h1>3 Sum</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解1---排序--哈希表--2-sum">題解1 - 排序 + 哈希表 + 2 Sum</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/3sum/">3Sum | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/3-sum/">(57) 3 Sum</a></li>
</ul>
<pre><code>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0?
Find all unique triplets in the array which gives the sum of zero.

Example
For example, given array S = {-1 0 1 2 -1 -4}, A solution set is:

(-1, 0, 1)
(-1, -1, 2)
Note
Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)

The solution set must not contain duplicate triplets.
</code></pre><h2>題解1 - 排序 + 哈希表 + 2 Sum</h2>
<p>相比之前的 <a href="http://algorithm.yuanbin.zh-hans/integer_array/2_sum.html">2 Sum</a>, 3 Sum 又多加了一個數，按照之前 2 Sum 的分解為『1 Sum + 1 Sum』的思路，我們同樣可以將 3 Sum 分解為『1 Sum + 2 Sum』的問題，具體就是首先對原陣列排序，排序後選出第一個元素，隨後在剩下的元素中使用 2 Sum 的解法。</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    &quot;&quot;&quot;
    @param numbersbers : Give an array numbersbers of n integer
    @return : Find all unique triplets in the array which gives the sum of zero.
    &quot;&quot;&quot;
    def threeSum(self, numbers):
        triplets = []
        length = len(numbers)
        if length &lt; 3:
            return triplets

        numbers.sort()
        for i in xrange(length):
            target = 0 - numbers[i]
            # 2 Sum
            hashmap = {}
            for j in xrange(i + 1, length):
                item_j = numbers[j]
                if (target - item_j) in hashmap:
                    triplet = [numbers[i], target - item_j, item_j]
                    if triplet not in triplets:
                        triplets.append(triplet)
                else:
                    hashmap[item_j] = j

        return triplets
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>異常處理，對長度小於3的直接返回。</li>
<li>排序輸入陣列，有助於提高效率和返回有序列表。</li>
<li>循環遍歷排序後陣列，先取出一個元素，隨後求得 2 Sum 中需要的目標數。</li>
<li>由於本題中最後返回結果不能重複，在加入到最終返回值之前查重。</li>
</ol>
<p>由於排序後的元素已經按照大小順序排列，且在2 Sum 中先遍歷的元素較小，所以無需對列表內元素再排序。</p>
<h3>複雜度分析</h3>
<p>排序時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 兩重<code>for</code>循環，時間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>，使用哈希表(字典)實現，空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<p>目前這段源碼為比較簡易的實現，leetcode 上的運行時間為500 + ms, 還有較大的優化空間，嗯，後續再進行優化。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num) 
    {
        vector&lt;vector&lt;int&gt; &gt; result;
        if (num.size() &lt; 3) return result;

        int ans = 0;

        sort(num.begin(), num.end());

        for (int i = 0;i &lt; num.size() - 2; ++i)
        {
            if (i &gt; 0 &amp;&amp; num[i] == num[i - 1])  
                continue;
            int j = i + 1;
            int k = num.size() - 1;

            while (j &lt; k)
            {
                ans = num[i] + num[j] + num[k];

                if (ans == 0)
                {
                    result.push_back({num[i], num[j], num[k]});
                    ++j;
                    while (j &lt; num.size() &amp;&amp; num[j] == num[j - 1])
                        ++j;
                    --k;
                    while (k &gt;= 0 &amp;&amp; num[k] == num[k + 1])
                        --k;
                }
                else if (ans &gt; 0) 
                    --k;
                else 
                    ++j;
            }
        }

        return result;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        // Assumptions: array is not null, array.length &gt;= 3
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        Arrays.sort(nums);
        for (int i = 0; i &lt; nums.length - 2; i++) {
            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = nums.length - 1;
            while (left &lt; right) {
                int tmp = nums[left] + nums[right];
                if (tmp + nums[i] == 0) {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    left++;
                    while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) {
                        left++;
                    }
                } else if (tmp + nums[i] &lt; 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>同python解法不同，沒有使用hash map</p>
<pre><code>S = {-1 0 1 2 -1 -4}
排序後：
S = {-4 -1 -1 0 1 2}
      ↑  ↑        ↑
      i  j        k
         →        ←
i每輪只走一步，j和k根據S[i]+S[j]+S[k]=ans和0的關係進行移動，且j只向後走（即S[j]只增大），k只向前走（即S[k]只減小）
如果ans&gt;0說明S[k]過大，k向前移；如果ans&lt;0說明S[j]過小，j向後移；ans==0即為所求。
至於如何取到所有解，看程式碼即可理解，不再贅述。
</code></pre><h3>複雜度分析</h3>
<p>外循環i走了n輪,每輪j和k一共走n-i步，所以時間複雜度為<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>。
最終運行時間為52ms</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.jiuzhang.com/solutions/3sum/">3Sum | 九章算法</a></li>
<li><a href="https://leetcode.com/discuss/32455/a-simply-python-version-based-on-2sum-o-n-2">A simply Python version based on 2sum - O(n^2) - Leetcode Discuss</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>3 Sum</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解1---排序--哈希表--2-sum">題解1 - 排序 + 哈希表 + 2 Sum</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/3sum/">3Sum | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/3-sum/">(57) 3 Sum</a></li>
</ul>
<pre><code>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0?
Find all unique triplets in the array which gives the sum of zero.

Example
For example, given array S = {-1 0 1 2 -1 -4}, A solution set is:

(-1, 0, 1)
(-1, -1, 2)
Note
Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)

The solution set must not contain duplicate triplets.
</code></pre><h2>題解1 - 排序 + 哈希表 + 2 Sum</h2>
<p>相比之前的 <a href="http://algorithm.yuanbin.zh-hans/integer_array/2_sum.html">2 Sum</a>, 3 Sum 又多加了一個數，按照之前 2 Sum 的分解為『1 Sum + 1 Sum』的思路，我們同樣可以將 3 Sum 分解為『1 Sum + 2 Sum』的問題，具體就是首先對原陣列排序，排序後選出第一個元素，隨後在剩下的元素中使用 2 Sum 的解法。</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    &quot;&quot;&quot;
    @param numbersbers : Give an array numbersbers of n integer
    @return : Find all unique triplets in the array which gives the sum of zero.
    &quot;&quot;&quot;
    def threeSum(self, numbers):
        triplets = []
        length = len(numbers)
        if length &lt; 3:
            return triplets

        numbers.sort()
        for i in xrange(length):
            target = 0 - numbers[i]
            # 2 Sum
            hashmap = {}
            for j in xrange(i + 1, length):
                item_j = numbers[j]
                if (target - item_j) in hashmap:
                    triplet = [numbers[i], target - item_j, item_j]
                    if triplet not in triplets:
                        triplets.append(triplet)
                else:
                    hashmap[item_j] = j

        return triplets
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>異常處理，對長度小於3的直接返回。</li>
<li>排序輸入陣列，有助於提高效率和返回有序列表。</li>
<li>循環遍歷排序後陣列，先取出一個元素，隨後求得 2 Sum 中需要的目標數。</li>
<li>由於本題中最後返回結果不能重複，在加入到最終返回值之前查重。</li>
</ol>
<p>由於排序後的元素已經按照大小順序排列，且在2 Sum 中先遍歷的元素較小，所以無需對列表內元素再排序。</p>
<h3>複雜度分析</h3>
<p>排序時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 兩重<code>for</code>循環，時間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>，使用哈希表(字典)實現，空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<p>目前這段源碼為比較簡易的實現，leetcode 上的運行時間為500 + ms, 還有較大的優化空間，嗯，後續再進行優化。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num) 
    {
        vector&lt;vector&lt;int&gt; &gt; result;
        if (num.size() &lt; 3) return result;

        int ans = 0;

        sort(num.begin(), num.end());

        for (int i = 0;i &lt; num.size() - 2; ++i)
        {
            if (i &gt; 0 &amp;&amp; num[i] == num[i - 1])  
                continue;
            int j = i + 1;
            int k = num.size() - 1;

            while (j &lt; k)
            {
                ans = num[i] + num[j] + num[k];

                if (ans == 0)
                {
                    result.push_back({num[i], num[j], num[k]});
                    ++j;
                    while (j &lt; num.size() &amp;&amp; num[j] == num[j - 1])
                        ++j;
                    --k;
                    while (k &gt;= 0 &amp;&amp; num[k] == num[k + 1])
                        --k;
                }
                else if (ans &gt; 0) 
                    --k;
                else 
                    ++j;
            }
        }

        return result;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        // Assumptions: array is not null, array.length &gt;= 3
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        Arrays.sort(nums);
        for (int i = 0; i &lt; nums.length - 2; i++) {
            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = nums.length - 1;
            while (left &lt; right) {
                int tmp = nums[left] + nums[right];
                if (tmp + nums[i] == 0) {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    left++;
                    while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) {
                        left++;
                    }
                } else if (tmp + nums[i] &lt; 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>同python解法不同，沒有使用hash map</p>
<pre><code>S = {-1 0 1 2 -1 -4}
排序後：
S = {-4 -1 -1 0 1 2}
      ↑  ↑        ↑
      i  j        k
         →        ←
i每輪只走一步，j和k根據S[i]+S[j]+S[k]=ans和0的關係進行移動，且j只向後走（即S[j]只增大），k只向前走（即S[k]只減小）
如果ans&gt;0說明S[k]過大，k向前移；如果ans&lt;0說明S[j]過小，j向後移；ans==0即為所求。
至於如何取到所有解，看程式碼即可理解，不再贅述。
</code></pre><h3>複雜度分析</h3>
<p>外循環i走了n輪,每輪j和k一共走n-i步，所以時間複雜度為<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>。
最終運行時間為52ms</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.jiuzhang.com/solutions/3sum/">3Sum | 九章算法</a></li>
<li><a href="https://leetcode.com/discuss/32455/a-simply-python-version-based-on-2sum-o-n-2">A simply Python version based on 2sum - O(n^2) - Leetcode Discuss</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[3 Sum Closest]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/integer_array/3_sum_closest.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/integer_array/3_sum_closest.html">
        </link>
        <updated>2019-11-03T15:42:09Z</updated>
        <summary type="html"><![CDATA[<h1>3 Sum Closest</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解1---排序--2-sum--兩根指標--優化過濾">題解1 - 排序 + 2 Sum + 兩根指標 + 優化過濾</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/3sum-closest/">3Sum Closest | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/3-sum-closest/">(59) 3 Sum Closest</a></li>
</ul>
<pre><code>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. 
Return the sum of the three integers. You may assume that each input would have exactly one solution.

For example, given array S = {-1 2 1 -4}, and target = 1.
The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
</code></pre><h2>題解1 - 排序 + 2 Sum + 兩根指標 + 優化過濾</h2>
<p>和 3 Sum 的思路接近，首先對原陣列排序，隨後將3 Sum 的題拆解為『1 Sum + 2 Sum』的題，對於 Closest 的題使用兩根指標而不是哈希表的方法較為方便。對於有序陣列來說，在查找 Cloest 的值時其實是有較大的優化空間的。</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    &quot;&quot;&quot;
    @param numbers: Give an array numbers of n integer
    @param target : An integer
    @return : return the sum of the three integers, the sum closest target.
    &quot;&quot;&quot;
    def threeSumClosest(self, numbers, target):
        result = 2**31 - 1
        length = len(numbers)
        if length &lt; 3:
            return result

        numbers.sort()
        larger_count = 0
        for i, item_i in enumerate(numbers):
            start = i + 1
            end = length - 1
            # optimization 1 - filter the smallest sum greater then target
            if start &lt; end:
                sum3_smallest = numbers[start] + numbers[start + 1] + item_i
                if sum3_smallest &gt; target:
                    larger_count += 1
                    if larger_count &gt; 1:
                        return result

            while (start &lt; end):
                sum3 = numbers[start] + numbers[end] + item_i
                if abs(sum3 - target) &lt; abs(result - target):
                    result = sum3

                # optimization 2 - filter the sum3 closest to target
                sum_flag = 0
                if sum3 &gt; target:
                    end -= 1
                    if sum_flag == -1:
                        break
                    sum_flag = 1
                elif sum3 &lt; target:
                    start += 1
                    if sum_flag == 1:
                        break
                    sum_flag = -1
                else:
                    return result

        return result
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>leetcode 上不能自己導入<code>sys</code>包，保險起見就初始化了<code>result</code>為還算較大的數，作為異常的返回值。</li>
<li>對陣列進行排序。</li>
<li>依次遍歷排序後的陣列，取出一個元素<code>item_i</code>後即轉化為『2 Sum Cloest』問題。『2 Sum Cloest』的起始元素索引為<code>i + 1</code>，之前的元素不能參與其中。</li>
<li>優化一——由於已經對原陣列排序，故遍歷原陣列時比較最小的三個元素和<code>target</code>值，若第二次大於<code>target</code>果斷就此罷休，後面的值肯定越來越大。</li>
<li>兩根指標求『2 Sum Cloest』，比較<code>sum3</code>和<code>result</code>與<code>target</code>的差值的絕對值，更新<code>result</code>為較小的絕對值。</li>
<li>再度對『2 Sum Cloest』進行優化，仍然利用有序陣列的特點，若處於『一大一小』的臨界值時就可以馬上退出了，後面的元素與<code>target</code>之差的絕對值只會越來越大。</li>
</ol>
<h3>複雜度分析</h3>
<p>對原陣列排序，平均時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 兩重<code>for</code>循環，由於有兩處優化，故最壞的時間複雜度才是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>, 使用了<code>result</code>作為臨時值保存最接近<code>target</code>的值，兩處優化各使用了一個輔助變量，空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    int threeSumClosest(vector&lt;int&gt; &amp;num, int target) 
    {
        if (num.size() &lt;= 3) return accumulate(num.begin(), num.end(), 0);
        sort (num.begin(), num.end());

        int result = 0, n = num.size(), temp;
        result = num[0] + num[1] + num[2];
        for (int i = 0; i &lt; n - 2; ++i)
        {
            int j = i + 1, k = n - 1;
            while (j &lt; k)
            {
                temp = num[i] + num[j] + num[k];

                if (abs(target - result) &gt; abs(target - temp))
                    result = temp;
                if (result == target)
                    return result;
                ( temp &gt; target ) ? --k : ++j;
            }
        }
        return result;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>和前面3Sum解法相似，同理使用i,j,k三個指標進行循環。<br>
區別在於3sum中的target為0，這裡新增一個變數用於比較哪組數據與target更為相近，並讓相對應的指標調整使之更近。</p>
<h3>複雜度分析</h3>
<p>時間複雜度同理為<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>
運行時間 16ms</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.jiuzhang.com/solutions/3sum-closest/">3Sum Closest | 九章算法</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>3 Sum Closest</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解1---排序--2-sum--兩根指標--優化過濾">題解1 - 排序 + 2 Sum + 兩根指標 + 優化過濾</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/3sum-closest/">3Sum Closest | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/3-sum-closest/">(59) 3 Sum Closest</a></li>
</ul>
<pre><code>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. 
Return the sum of the three integers. You may assume that each input would have exactly one solution.

For example, given array S = {-1 2 1 -4}, and target = 1.
The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
</code></pre><h2>題解1 - 排序 + 2 Sum + 兩根指標 + 優化過濾</h2>
<p>和 3 Sum 的思路接近，首先對原陣列排序，隨後將3 Sum 的題拆解為『1 Sum + 2 Sum』的題，對於 Closest 的題使用兩根指標而不是哈希表的方法較為方便。對於有序陣列來說，在查找 Cloest 的值時其實是有較大的優化空間的。</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    &quot;&quot;&quot;
    @param numbers: Give an array numbers of n integer
    @param target : An integer
    @return : return the sum of the three integers, the sum closest target.
    &quot;&quot;&quot;
    def threeSumClosest(self, numbers, target):
        result = 2**31 - 1
        length = len(numbers)
        if length &lt; 3:
            return result

        numbers.sort()
        larger_count = 0
        for i, item_i in enumerate(numbers):
            start = i + 1
            end = length - 1
            # optimization 1 - filter the smallest sum greater then target
            if start &lt; end:
                sum3_smallest = numbers[start] + numbers[start + 1] + item_i
                if sum3_smallest &gt; target:
                    larger_count += 1
                    if larger_count &gt; 1:
                        return result

            while (start &lt; end):
                sum3 = numbers[start] + numbers[end] + item_i
                if abs(sum3 - target) &lt; abs(result - target):
                    result = sum3

                # optimization 2 - filter the sum3 closest to target
                sum_flag = 0
                if sum3 &gt; target:
                    end -= 1
                    if sum_flag == -1:
                        break
                    sum_flag = 1
                elif sum3 &lt; target:
                    start += 1
                    if sum_flag == 1:
                        break
                    sum_flag = -1
                else:
                    return result

        return result
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>leetcode 上不能自己導入<code>sys</code>包，保險起見就初始化了<code>result</code>為還算較大的數，作為異常的返回值。</li>
<li>對陣列進行排序。</li>
<li>依次遍歷排序後的陣列，取出一個元素<code>item_i</code>後即轉化為『2 Sum Cloest』問題。『2 Sum Cloest』的起始元素索引為<code>i + 1</code>，之前的元素不能參與其中。</li>
<li>優化一——由於已經對原陣列排序，故遍歷原陣列時比較最小的三個元素和<code>target</code>值，若第二次大於<code>target</code>果斷就此罷休，後面的值肯定越來越大。</li>
<li>兩根指標求『2 Sum Cloest』，比較<code>sum3</code>和<code>result</code>與<code>target</code>的差值的絕對值，更新<code>result</code>為較小的絕對值。</li>
<li>再度對『2 Sum Cloest』進行優化，仍然利用有序陣列的特點，若處於『一大一小』的臨界值時就可以馬上退出了，後面的元素與<code>target</code>之差的絕對值只會越來越大。</li>
</ol>
<h3>複雜度分析</h3>
<p>對原陣列排序，平均時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 兩重<code>for</code>循環，由於有兩處優化，故最壞的時間複雜度才是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>, 使用了<code>result</code>作為臨時值保存最接近<code>target</code>的值，兩處優化各使用了一個輔助變量，空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    int threeSumClosest(vector&lt;int&gt; &amp;num, int target) 
    {
        if (num.size() &lt;= 3) return accumulate(num.begin(), num.end(), 0);
        sort (num.begin(), num.end());

        int result = 0, n = num.size(), temp;
        result = num[0] + num[1] + num[2];
        for (int i = 0; i &lt; n - 2; ++i)
        {
            int j = i + 1, k = n - 1;
            while (j &lt; k)
            {
                temp = num[i] + num[j] + num[k];

                if (abs(target - result) &gt; abs(target - temp))
                    result = temp;
                if (result == target)
                    return result;
                ( temp &gt; target ) ? --k : ++j;
            }
        }
        return result;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>和前面3Sum解法相似，同理使用i,j,k三個指標進行循環。<br>
區別在於3sum中的target為0，這裡新增一個變數用於比較哪組數據與target更為相近，並讓相對應的指標調整使之更近。</p>
<h3>複雜度分析</h3>
<p>時間複雜度同理為<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>
運行時間 16ms</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.jiuzhang.com/solutions/3sum-closest/">3Sum Closest | 九章算法</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Remove Duplicates from Sorted Array]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/integer_array/remove_duplicates_from_sorted_array.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/integer_array/remove_duplicates_from_sorted_array.html">
        </link>
        <updated>2019-11-03T15:42:09Z</updated>
        <summary type="html"><![CDATA[<h1>Remove Duplicates from Sorted Array</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#源碼分析">源碼分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/remove-duplicates-from-sorted-array/">(100) Remove Duplicates from Sorted Array</a></li>
</ul>
<pre><code>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this in place with constant memory.

For example,
Given input array A = [1,1,2],

Your function should return length = 2, and A is now [1,2].

Example
</code></pre><h2>題解</h2>
<p>使用雙指標(下標)，一個指標(下標)遍歷vector數組，另一個指標(下標)只取不重複的數置於原vector中。</p>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param A: a list of integers
     * @return : return an integer
     */
    int removeDuplicates(vector&lt;int&gt; &amp;nums) {
        if (nums.empty()) {
            return 0;
        }

        int size = 0;
        for (vector&lt;int&gt;::size_type i = 0; i != nums.size(); ++i) {
            if (nums[i] != nums[size]) {
                nums[++size] = nums[i];
            }
        }
        return ++size;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>注意最後需要返回的是<code>++size</code>或者<code>size + 1</code></p>
]]></summary>
        <content type="html"><![CDATA[<h1>Remove Duplicates from Sorted Array</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#源碼分析">源碼分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/remove-duplicates-from-sorted-array/">(100) Remove Duplicates from Sorted Array</a></li>
</ul>
<pre><code>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this in place with constant memory.

For example,
Given input array A = [1,1,2],

Your function should return length = 2, and A is now [1,2].

Example
</code></pre><h2>題解</h2>
<p>使用雙指標(下標)，一個指標(下標)遍歷vector數組，另一個指標(下標)只取不重複的數置於原vector中。</p>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param A: a list of integers
     * @return : return an integer
     */
    int removeDuplicates(vector&lt;int&gt; &amp;nums) {
        if (nums.empty()) {
            return 0;
        }

        int size = 0;
        for (vector&lt;int&gt;::size_type i = 0; i != nums.size(); ++i) {
            if (nums[i] != nums[size]) {
                nums[++size] = nums[i];
            }
        }
        return ++size;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>注意最後需要返回的是<code>++size</code>或者<code>size + 1</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Remove Duplicates from Sorted Array II]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/integer_array/remove_duplicates_from_sorted_array_ii.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/integer_array/remove_duplicates_from_sorted_array_ii.html">
        </link>
        <updated>2019-11-03T15:42:09Z</updated>
        <summary type="html"><![CDATA[<h1>Remove Duplicates from Sorted Array II</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/remove-duplicates-from-sorted-array-ii/">(101) Remove Duplicates from Sorted Array II</a></li>
</ul>
<pre><code>Follow up for &quot;Remove Duplicates&quot;:
What if duplicates are allowed at most twice?

For example,
Given sorted array A = [1,1,1,2,2,3],

Your function should return length = 5, and A is now [1,1,2,2,3].
Example
</code></pre><h2>題解</h2>
<p>在上題基礎上加了限制條件元素最多可重複出現兩次。因此可以在原題的基礎上添加一變量跟蹤元素重複出現的次數，小於指定值時執行賦值操作。但是需要注意的是重複出現次數<code>occurence</code>的初始值(從1開始，而不是0)和reset的時機。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param A: a list of integers
     * @return : return an integer
     */
    int removeDuplicates(vector&lt;int&gt; &amp;nums) {
        if (nums.size() &lt; 3) {
            return nums.size();
        }

        int size = 0;
        int occurence = 1;
        for (vector&lt;int&gt;::size_type i = 1; i != nums.size(); ++i) {
            if (nums[size] != nums[i]) {
                nums[++size] = nums[i];
                occurence = 1;
            } else if (nums[size] == nums[i]) {
                if (occurence++ &lt; 2) {
                    nums[++size] = nums[i];
                }
            }
        }

        return ++size;
    }
};
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>在數組元素小於3(即為2)時可直接返回vector數組大小。</li>
<li>初始化<code>occurence</code>的值為1，而不是0. 理解起來也方便些。</li>
<li>初始化下標值<code>i</code>從1開始<ul>
<li><code>nums[size] != nums[i]</code>時遞增<code>size</code>並賦值，同時重置<code>occurence</code>的值為1</li>
<li><code>(nums[size] == nums[i])</code>時，首先判斷<code>occurence</code>的值是否小於2，小於2則先遞增<code>size</code>，隨後將<code>nums[i]</code>的值賦給<code>nums[size]</code>。這裡由於小標<code>i</code>從1開始，免去了對<code>i</code>為0的特殊情況考慮。</li>
</ul>
</li>
<li>最後返回<code>size + 1</code>，即為<code>++size</code></li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h1>Remove Duplicates from Sorted Array II</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/remove-duplicates-from-sorted-array-ii/">(101) Remove Duplicates from Sorted Array II</a></li>
</ul>
<pre><code>Follow up for &quot;Remove Duplicates&quot;:
What if duplicates are allowed at most twice?

For example,
Given sorted array A = [1,1,1,2,2,3],

Your function should return length = 5, and A is now [1,1,2,2,3].
Example
</code></pre><h2>題解</h2>
<p>在上題基礎上加了限制條件元素最多可重複出現兩次。因此可以在原題的基礎上添加一變量跟蹤元素重複出現的次數，小於指定值時執行賦值操作。但是需要注意的是重複出現次數<code>occurence</code>的初始值(從1開始，而不是0)和reset的時機。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param A: a list of integers
     * @return : return an integer
     */
    int removeDuplicates(vector&lt;int&gt; &amp;nums) {
        if (nums.size() &lt; 3) {
            return nums.size();
        }

        int size = 0;
        int occurence = 1;
        for (vector&lt;int&gt;::size_type i = 1; i != nums.size(); ++i) {
            if (nums[size] != nums[i]) {
                nums[++size] = nums[i];
                occurence = 1;
            } else if (nums[size] == nums[i]) {
                if (occurence++ &lt; 2) {
                    nums[++size] = nums[i];
                }
            }
        }

        return ++size;
    }
};
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>在數組元素小於3(即為2)時可直接返回vector數組大小。</li>
<li>初始化<code>occurence</code>的值為1，而不是0. 理解起來也方便些。</li>
<li>初始化下標值<code>i</code>從1開始<ul>
<li><code>nums[size] != nums[i]</code>時遞增<code>size</code>並賦值，同時重置<code>occurence</code>的值為1</li>
<li><code>(nums[size] == nums[i])</code>時，首先判斷<code>occurence</code>的值是否小於2，小於2則先遞增<code>size</code>，隨後將<code>nums[i]</code>的值賦給<code>nums[size]</code>。這裡由於小標<code>i</code>從1開始，免去了對<code>i</code>為0的特殊情況考慮。</li>
</ul>
</li>
<li>最後返回<code>size + 1</code>，即為<code>++size</code></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Merge Sorted Array]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/integer_array/merge_sorted_array.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/integer_array/merge_sorted_array.html">
        </link>
        <updated>2019-11-03T15:42:09Z</updated>
        <summary type="html"><![CDATA[<h1>Merge Sorted Array</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/merge-sorted-array/">Merge Sorted Array | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/merge-sorted-array/">(6) Merge Sorted Array</a></li>
</ul>
<pre><code>Given two sorted integer arrays A and B, merge B into A as one sorted array.

Example
A = [1, 2, 3, empty, empty], B = [4, 5]

After merge, A will be filled as [1, 2, 3, 4, 5]

Note
You may assume that A has enough space (size that is greater or equal to m + n)
to hold additional elements from B.
The number of elements initialized in A and B are m and n respectively.
</code></pre><h2>題解</h2>
<p>因為本題有 in-place 的限制，故必須從陣列末尾的兩個元素開始比較；否則就會產生挪動，一旦挪動就會是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span> 的。
自尾部向首部逐個比較兩個陣列內的元素，取較大的置於陣列 A 中。由於 A 的容量較 B 大，故最後 <code>m == 0</code> 或者 <code>n == 0</code> 時僅需處理 B 中的元素，因為 A 中的元素已經在 A 中，無需處理。</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    &quot;&quot;&quot;
    @param A: sorted integer array A which has m elements,
              but size of A is m+n
    @param B: sorted integer array B which has n elements
    @return: void
    &quot;&quot;&quot;
    def mergeSortedArray(self, A, m, B, n):
        if B is None:
            return A

        index = m + n - 1
        while m &gt; 0 and n &gt; 0:
            if A[m - 1] &gt; B[n - 1]:
                A[index] = A[m - 1]
                m -= 1
            else:
                A[index] = B[n - 1]
                n -= 1
            index -= 1

        # B has elements left
        while n &gt; 0:
            A[index] = B[n - 1]
            n -= 1
            index -= 1
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param A: sorted integer array A which has m elements,
     *           but size of A is m+n
     * @param B: sorted integer array B which has n elements
     * @return: void
     */
    void mergeSortedArray(int A[], int m, int B[], int n) {
        int index = m + n - 1;
        while (m &gt; 0 &amp;&amp; n &gt; 0) {
            if (A[m - 1] &gt; B[n - 1]) {
                A[index] = A[m - 1];
                --m;
            } else {
                A[index] = B[n - 1];
                --n;
            }
            --index;
        }

        // B has elements left
        while (n &gt; 0) {
            A[index] = B[n - 1];
            --n;
            --index;
        }
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">class Solution {
    /**
     * @param A: sorted integer array A which has m elements,
     *           but size of A is m+n
     * @param B: sorted integer array B which has n elements
     * @return: void
     */
    public void mergeSortedArray(int[] A, int m, int[] B, int n) {
        if (A == null || B == null) return;

        int index = m + n - 1;
        while (m &gt; 0 &amp;&amp; n &gt; 0) {
            if (A[m - 1] &gt; B[n - 1]) {
                A[index] = A[m - 1];
                m--;
            } else {
                A[index] = B[n - 1];
                n--;
            }
            index--;
        }

        // B has elements left
        while (n &gt; 0) {
            A[index] = B[n - 1];
            n--;
            index--;
        }
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>第一個 while 只能用條件與(conditional AND)。</p>
<h3>複雜度分析</h3>
<p>最壞情況下需要遍歷兩個陣列中所有元素，時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Merge Sorted Array</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/merge-sorted-array/">Merge Sorted Array | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/merge-sorted-array/">(6) Merge Sorted Array</a></li>
</ul>
<pre><code>Given two sorted integer arrays A and B, merge B into A as one sorted array.

Example
A = [1, 2, 3, empty, empty], B = [4, 5]

After merge, A will be filled as [1, 2, 3, 4, 5]

Note
You may assume that A has enough space (size that is greater or equal to m + n)
to hold additional elements from B.
The number of elements initialized in A and B are m and n respectively.
</code></pre><h2>題解</h2>
<p>因為本題有 in-place 的限制，故必須從陣列末尾的兩個元素開始比較；否則就會產生挪動，一旦挪動就會是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span> 的。
自尾部向首部逐個比較兩個陣列內的元素，取較大的置於陣列 A 中。由於 A 的容量較 B 大，故最後 <code>m == 0</code> 或者 <code>n == 0</code> 時僅需處理 B 中的元素，因為 A 中的元素已經在 A 中，無需處理。</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    &quot;&quot;&quot;
    @param A: sorted integer array A which has m elements,
              but size of A is m+n
    @param B: sorted integer array B which has n elements
    @return: void
    &quot;&quot;&quot;
    def mergeSortedArray(self, A, m, B, n):
        if B is None:
            return A

        index = m + n - 1
        while m &gt; 0 and n &gt; 0:
            if A[m - 1] &gt; B[n - 1]:
                A[index] = A[m - 1]
                m -= 1
            else:
                A[index] = B[n - 1]
                n -= 1
            index -= 1

        # B has elements left
        while n &gt; 0:
            A[index] = B[n - 1]
            n -= 1
            index -= 1
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param A: sorted integer array A which has m elements,
     *           but size of A is m+n
     * @param B: sorted integer array B which has n elements
     * @return: void
     */
    void mergeSortedArray(int A[], int m, int B[], int n) {
        int index = m + n - 1;
        while (m &gt; 0 &amp;&amp; n &gt; 0) {
            if (A[m - 1] &gt; B[n - 1]) {
                A[index] = A[m - 1];
                --m;
            } else {
                A[index] = B[n - 1];
                --n;
            }
            --index;
        }

        // B has elements left
        while (n &gt; 0) {
            A[index] = B[n - 1];
            --n;
            --index;
        }
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">class Solution {
    /**
     * @param A: sorted integer array A which has m elements,
     *           but size of A is m+n
     * @param B: sorted integer array B which has n elements
     * @return: void
     */
    public void mergeSortedArray(int[] A, int m, int[] B, int n) {
        if (A == null || B == null) return;

        int index = m + n - 1;
        while (m &gt; 0 &amp;&amp; n &gt; 0) {
            if (A[m - 1] &gt; B[n - 1]) {
                A[index] = A[m - 1];
                m--;
            } else {
                A[index] = B[n - 1];
                n--;
            }
            index--;
        }

        // B has elements left
        while (n &gt; 0) {
            A[index] = B[n - 1];
            n--;
            index--;
        }
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>第一個 while 只能用條件與(conditional AND)。</p>
<h3>複雜度分析</h3>
<p>最壞情況下需要遍歷兩個陣列中所有元素，時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Merge Sorted Array II]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/integer_array/merge_sorted_array_ii.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/integer_array/merge_sorted_array_ii.html">
        </link>
        <updated>2019-11-03T15:42:09Z</updated>
        <summary type="html"><![CDATA[<h1>Merge Sorted Array II</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a><ul>
<li><a href="#challenge">Challenge</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/merge-sorted-array-ii/">(64) Merge Sorted Array II</a></li>
</ul>
<pre><code>Merge two given sorted integer array A and B into a new sorted integer array.

Example
A=[1,2,3,4]

B=[2,4,5,6]

return [1,2,2,3,4,4,5,6]

Challenge
How can you optimize your algorithm
if one array is very large and the other is very small?
</code></pre><h2>題解</h2>
<p>上題要求 in-place, 此題要求返回新陣列。由於可以生成新陣列，故使用常規思路按順序遍歷即可。</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    #@param A and B: sorted integer array A and B.
    #@return: A new sorted integer array
    def mergeSortedArray(self, A, B):
        if A is None or len(A) == 0:
            return B
        if B is None or len(B) == 0:
            return A

        C = []
        aLen, bLen = len(A), len(B)
        i, j = 0, 0
        while i &lt; aLen and j &lt; bLen:
            if A[i] &lt; B[j]:
                C.append(A[i])
                i += 1
            else:
                C.append(B[j])
                j += 1

        # A has elements left
        while i &lt; aLen:
            C.append(A[i])
            i += 1

        # B has elements left
        while j &lt; bLen:
            C.append(B[j])
            j += 1

        return C
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param A and B: sorted integer array A and B.
     * @return: A new sorted integer array
     */
    vector&lt;int&gt; mergeSortedArray(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) {
        if (A.empty()) return B;
        if (B.empty()) return A;

        int aLen = A.size(), bLen = B.size();
        vector&lt;int&gt; C;
        int i = 0, j = 0;
        while (i &lt; aLen &amp;&amp; j &lt; bLen) {
            if (A[i] &lt; B[j]) {
                C.push_back(A[i]);
                ++i;
            } else {
                C.push_back(B[j]);
                ++j;
            }
        }

        // A has elements left
        while (i &lt; aLen) {
            C.push_back(A[i]);
            ++i;
        }

        // B has elements left
        while (j &lt; bLen) {
            C.push_back(B[j]);
            ++j;
        }

        return C;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">class Solution {
    /**
     * @param A and B: sorted integer array A and B.
     * @return: A new sorted integer array
     */
    public ArrayList&lt;Integer&gt; mergeSortedArray(ArrayList&lt;Integer&gt; A, ArrayList&lt;Integer&gt; B) {
        if (A == null || A.isEmpty()) return B;
        if (B == null || B.isEmpty()) return A;

        ArrayList&lt;Integer&gt; C = new ArrayList&lt;Integer&gt;();
        int aLen = A.size(), bLen = B.size();
        int i = 0, j = 0;
        while (i &lt; aLen &amp;&amp; j &lt; bLen) {
            if (A.get(i) &lt; B.get(j)) {
                C.add(A.get(i));
                i++;
            } else {
                C.add(B.get(j));
                j++;
            }
        }

        // A has elements left
        while (i &lt; aLen) {
            C.add(A.get(i));
            i++;
        }

        // B has elements left
        while (j &lt; bLen) {
            C.add(B.get(j));
            j++;
        }

        return C;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>分三步走，後面分別單獨處理剩餘的元素。</p>
<h3>複雜度分析</h3>
<p>遍歷 A, B 陣列各一次，時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h4>Challenge</h4>
<p>兩個倒排列表，一個特別大，一個特別小，如何 Merge？此時應該考慮用一個二分法插入小的，即記憶體拷貝。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Merge Sorted Array II</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a><ul>
<li><a href="#challenge">Challenge</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/merge-sorted-array-ii/">(64) Merge Sorted Array II</a></li>
</ul>
<pre><code>Merge two given sorted integer array A and B into a new sorted integer array.

Example
A=[1,2,3,4]

B=[2,4,5,6]

return [1,2,2,3,4,4,5,6]

Challenge
How can you optimize your algorithm
if one array is very large and the other is very small?
</code></pre><h2>題解</h2>
<p>上題要求 in-place, 此題要求返回新陣列。由於可以生成新陣列，故使用常規思路按順序遍歷即可。</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    #@param A and B: sorted integer array A and B.
    #@return: A new sorted integer array
    def mergeSortedArray(self, A, B):
        if A is None or len(A) == 0:
            return B
        if B is None or len(B) == 0:
            return A

        C = []
        aLen, bLen = len(A), len(B)
        i, j = 0, 0
        while i &lt; aLen and j &lt; bLen:
            if A[i] &lt; B[j]:
                C.append(A[i])
                i += 1
            else:
                C.append(B[j])
                j += 1

        # A has elements left
        while i &lt; aLen:
            C.append(A[i])
            i += 1

        # B has elements left
        while j &lt; bLen:
            C.append(B[j])
            j += 1

        return C
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param A and B: sorted integer array A and B.
     * @return: A new sorted integer array
     */
    vector&lt;int&gt; mergeSortedArray(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) {
        if (A.empty()) return B;
        if (B.empty()) return A;

        int aLen = A.size(), bLen = B.size();
        vector&lt;int&gt; C;
        int i = 0, j = 0;
        while (i &lt; aLen &amp;&amp; j &lt; bLen) {
            if (A[i] &lt; B[j]) {
                C.push_back(A[i]);
                ++i;
            } else {
                C.push_back(B[j]);
                ++j;
            }
        }

        // A has elements left
        while (i &lt; aLen) {
            C.push_back(A[i]);
            ++i;
        }

        // B has elements left
        while (j &lt; bLen) {
            C.push_back(B[j]);
            ++j;
        }

        return C;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">class Solution {
    /**
     * @param A and B: sorted integer array A and B.
     * @return: A new sorted integer array
     */
    public ArrayList&lt;Integer&gt; mergeSortedArray(ArrayList&lt;Integer&gt; A, ArrayList&lt;Integer&gt; B) {
        if (A == null || A.isEmpty()) return B;
        if (B == null || B.isEmpty()) return A;

        ArrayList&lt;Integer&gt; C = new ArrayList&lt;Integer&gt;();
        int aLen = A.size(), bLen = B.size();
        int i = 0, j = 0;
        while (i &lt; aLen &amp;&amp; j &lt; bLen) {
            if (A.get(i) &lt; B.get(j)) {
                C.add(A.get(i));
                i++;
            } else {
                C.add(B.get(j));
                j++;
            }
        }

        // A has elements left
        while (i &lt; aLen) {
            C.add(A.get(i));
            i++;
        }

        // B has elements left
        while (j &lt; bLen) {
            C.add(B.get(j));
            j++;
        }

        return C;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>分三步走，後面分別單獨處理剩餘的元素。</p>
<h3>複雜度分析</h3>
<p>遍歷 A, B 陣列各一次，時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h4>Challenge</h4>
<p>兩個倒排列表，一個特別大，一個特別小，如何 Merge？此時應該考慮用一個二分法插入小的，即記憶體拷貝。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Binary Search]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/binary_search/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/binary_search/">
        </link>
        <updated>2019-11-03T15:42:10Z</updated>
        <summary type="html"><![CDATA[<h1>Search - 搜索</h1>
<p>本章主要總結二分搜索相關的題目。</p>
<ul>
<li>能使用二分搜索的前提是數組已排序。</li>
<li>二分搜索的使用場景：（1）可轉換為find the first/last position of...（2）時間複雜度至少為<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>。</li>
<li>遞迴和迭代的使用場景：能用迭代就用迭代，特別複雜時採用遞迴。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Search - 搜索</h1>
<p>本章主要總結二分搜索相關的題目。</p>
<ul>
<li>能使用二分搜索的前提是數組已排序。</li>
<li>二分搜索的使用場景：（1）可轉換為find the first/last position of...（2）時間複雜度至少為<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>。</li>
<li>遞迴和迭代的使用場景：能用迭代就用迭代，特別複雜時採用遞迴。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Binary Search]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/binary_search/binary_search.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/binary_search/binary_search.html">
        </link>
        <updated>2019-11-03T15:42:10Z</updated>
        <summary type="html"><![CDATA[<h1>Binary Search - 二分搜尋</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/binary-search/">lintcode - (14) Binary Search</a></li>
</ul>
<pre><code>Binary search is a famous question in algorithm.

For a given sorted array (ascending order) and a target number, find the first index of this number in O(log n) time complexity.

If the target number does not exist in the array, return -1.

Example
If the array is [1, 2, 3, 3, 4, 5, 10], for given target 3, return 2.

Challenge
If the count of numbers is bigger than MAXINT, can your code work properly?
</code></pre><h2>題解</h2>
<p>對於已排序升序陣列，使用二分搜尋可滿足複雜度要求，注意陣列中可能有重複值。</p>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * 本代碼fork自九章算法。沒有版權歡迎轉發。
 * http://www.jiuzhang.com//solutions/binary-search/
 */
class Solution {
    /**
     * @param nums: The integer array.
     * @param target: Target to find.
     * @return: The first position of target. Position starts from 0.
     */
    public int binarySearch(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return -1;
        }

        int start = 0;
        int end = nums.length - 1;
        int mid;
        while (start + 1 &lt; end) {
            mid = start + (end - start) / 2; // avoid overflow when (end + start)
            if (target &lt; nums[mid]) {
                end = mid;
            } else if (target &gt; nums[mid]) {
                start = mid;
            } else {
                end = mid;
            }
        }

        if (nums[start] == target) {
            return start;
        }
        if (nums[end] == target) {
            return end;
        }

        return -1;
    }
}
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>首先對輸入做異常處理，陣列為空或者長度為0。</li>
<li>初始化 <code>start, end, mid</code>三個變量，注意mid的求值方法，可以防止兩個整型值相加時溢出。</li>
<li><strong>使用迭代而不是遞迴</strong>進行二分搜尋，因為工程中遞迴寫法存在潛在溢出的可能。</li>
<li>while終止條件應為<code>start + 1 &lt; end</code>而不是<code>start &lt;= end</code>，<code>start == end</code>時可能出現死循環。<strong>即循環終止條件是相鄰或相交元素時退出。</strong></li>
<li>迭代終止時target應為start或者end中的一個——由上述循環終止條件有兩個，具體誰先誰後視題目是找 first position or last position 而定。</li>
<li>賦值語句<code>end = mid</code>有兩個條件是相同的，可以選擇寫到一塊。</li>
<li>配合while終止條件<code>start + 1 &lt; end</code>（相鄰即退出）的賦值語句mid永遠沒有<code>+1</code>或者<code>-1</code>，這樣不會死循環。</li>
</ol>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param nums: The integer array.
     * @param target: Target number to find.
     * @return: The first position of target. Position starts from 0. 
     */
    int binarySearch(vector&lt;int&gt; &amp;nums, int target) {
        if( nums.size() == 0 ) return -1;

        int lo = 0, hi = nums.size();
        while(lo &lt; hi){
            int mi = lo + (hi - lo)/2;
            if(nums[mi] &lt; target)
                lo = mi + 1;
            else
                hi = mi;
        }

        if(nums[lo] == target) return lo;
        return -1;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>遇到需要處理陣列範圍的問題，由於C/C++語言本身的特性，統一使用開閉區間表示index範圍將有許多好處，[lo, hi)表示包含lo但不包含hi的區間。比方說，如果要遍歷這個區間，迴圈的條件可以寫為<code>for(i = lo; i &lt; hi; i++)</code>這類常用的方式，如果要求此段區間長度可用<code>int length = hi - lo;</code>，另外在很多邊界條件的判斷上也會比較簡潔。實際上在STL裡的iterator也是使用了用類似的概念，一個容器的end()表示的是一個已經超出指定範圍的iterator。以此題來說，可以看出C++的實現方法確實比較簡潔。</p>
<ol>
<li>終止條件簡單設定為<code>lo &lt; hi</code>，事實上觀察調整<code>lo</code>與<code>hi</code>範圍的過程，終止的時候一定是<code>lo == hi</code>。</li>
<li>觀察<code>lo</code>的更新條件，是當<code>nums[mi]</code>比目標值小時將<code>lo</code>更新為<code>mi + 1</code>，也就是說，<code>lo</code>可以保證下界一定會不斷排除比<code>target</code>小的值，其餘狀況每次循環<code>hi</code>則減少範圍，因此等到循環終止之後，<code>lo</code>就會指到<strong>不小於<code>target</code>的最小元素</strong>，我們再將這個元素與<code>target</code>比較，就知道是否有找到，沒有的話就返回-1</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h1>Binary Search - 二分搜尋</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/binary-search/">lintcode - (14) Binary Search</a></li>
</ul>
<pre><code>Binary search is a famous question in algorithm.

For a given sorted array (ascending order) and a target number, find the first index of this number in O(log n) time complexity.

If the target number does not exist in the array, return -1.

Example
If the array is [1, 2, 3, 3, 4, 5, 10], for given target 3, return 2.

Challenge
If the count of numbers is bigger than MAXINT, can your code work properly?
</code></pre><h2>題解</h2>
<p>對於已排序升序陣列，使用二分搜尋可滿足複雜度要求，注意陣列中可能有重複值。</p>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * 本代碼fork自九章算法。沒有版權歡迎轉發。
 * http://www.jiuzhang.com//solutions/binary-search/
 */
class Solution {
    /**
     * @param nums: The integer array.
     * @param target: Target to find.
     * @return: The first position of target. Position starts from 0.
     */
    public int binarySearch(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return -1;
        }

        int start = 0;
        int end = nums.length - 1;
        int mid;
        while (start + 1 &lt; end) {
            mid = start + (end - start) / 2; // avoid overflow when (end + start)
            if (target &lt; nums[mid]) {
                end = mid;
            } else if (target &gt; nums[mid]) {
                start = mid;
            } else {
                end = mid;
            }
        }

        if (nums[start] == target) {
            return start;
        }
        if (nums[end] == target) {
            return end;
        }

        return -1;
    }
}
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>首先對輸入做異常處理，陣列為空或者長度為0。</li>
<li>初始化 <code>start, end, mid</code>三個變量，注意mid的求值方法，可以防止兩個整型值相加時溢出。</li>
<li><strong>使用迭代而不是遞迴</strong>進行二分搜尋，因為工程中遞迴寫法存在潛在溢出的可能。</li>
<li>while終止條件應為<code>start + 1 &lt; end</code>而不是<code>start &lt;= end</code>，<code>start == end</code>時可能出現死循環。<strong>即循環終止條件是相鄰或相交元素時退出。</strong></li>
<li>迭代終止時target應為start或者end中的一個——由上述循環終止條件有兩個，具體誰先誰後視題目是找 first position or last position 而定。</li>
<li>賦值語句<code>end = mid</code>有兩個條件是相同的，可以選擇寫到一塊。</li>
<li>配合while終止條件<code>start + 1 &lt; end</code>（相鄰即退出）的賦值語句mid永遠沒有<code>+1</code>或者<code>-1</code>，這樣不會死循環。</li>
</ol>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param nums: The integer array.
     * @param target: Target number to find.
     * @return: The first position of target. Position starts from 0. 
     */
    int binarySearch(vector&lt;int&gt; &amp;nums, int target) {
        if( nums.size() == 0 ) return -1;

        int lo = 0, hi = nums.size();
        while(lo &lt; hi){
            int mi = lo + (hi - lo)/2;
            if(nums[mi] &lt; target)
                lo = mi + 1;
            else
                hi = mi;
        }

        if(nums[lo] == target) return lo;
        return -1;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>遇到需要處理陣列範圍的問題，由於C/C++語言本身的特性，統一使用開閉區間表示index範圍將有許多好處，[lo, hi)表示包含lo但不包含hi的區間。比方說，如果要遍歷這個區間，迴圈的條件可以寫為<code>for(i = lo; i &lt; hi; i++)</code>這類常用的方式，如果要求此段區間長度可用<code>int length = hi - lo;</code>，另外在很多邊界條件的判斷上也會比較簡潔。實際上在STL裡的iterator也是使用了用類似的概念，一個容器的end()表示的是一個已經超出指定範圍的iterator。以此題來說，可以看出C++的實現方法確實比較簡潔。</p>
<ol>
<li>終止條件簡單設定為<code>lo &lt; hi</code>，事實上觀察調整<code>lo</code>與<code>hi</code>範圍的過程，終止的時候一定是<code>lo == hi</code>。</li>
<li>觀察<code>lo</code>的更新條件，是當<code>nums[mi]</code>比目標值小時將<code>lo</code>更新為<code>mi + 1</code>，也就是說，<code>lo</code>可以保證下界一定會不斷排除比<code>target</code>小的值，其餘狀況每次循環<code>hi</code>則減少範圍，因此等到循環終止之後，<code>lo</code>就會指到<strong>不小於<code>target</code>的最小元素</strong>，我們再將這個元素與<code>target</code>比較，就知道是否有找到，沒有的話就返回-1</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Search Insert Position]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/binary_search/search_insert_position.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/binary_search/search_insert_position.html">
        </link>
        <updated>2019-11-03T15:42:10Z</updated>
        <summary type="html"><![CDATA[<h1>Search Insert Position</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/search-insert-position/">(60) Search Insert Position</a></li>
</ul>
<pre><code>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

Example
[1,3,5,6], 5 → 2
[1,3,5,6], 2 → 1
[1,3,5,6], 7 → 4
[1,3,5,6], 0 → 0
</code></pre><h2>題解</h2>
<p>應該把二分法的問題拆解為<code>find the first/last position of...</code>的問題。由最原始的二分搜尋可找到不小於目標整數的最小下標。返回此下標即可。</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * param A : an integer sorted array
     * param target :  an integer to be inserted
     * return : an integer
     */
    public int searchInsert(int[] A, int target) {
        if (A == null) {
            return -1;
        }
        if (A.length == 0) {
            return 0;
        }

        int start = 0, end = A.length - 1;
        int mid;

        while (start + 1 &lt; end) {
            mid = start + (end - start) / 2;
            if (A[mid] == target) {
                return mid; // no duplicates, if not `end = target;`
            } else if (A[mid] &lt; target) {
                start = mid;
            } else {
                end = mid;
            }
        }

        if (A[start] &gt;= target) {
            return start;
        } else if (A[end] &gt;= target) {
            return end; // in most cases
        } else {
            return end + 1; // A[end] &lt; target;
        }
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>要注意例子中的第三個, [1,3,5,6], 7 → 4，即找不到要找的數字的情況，此時應返回數組長度，即代碼中最後一個else的賦值語句<code>return end + 1;</code></p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
    /** 
     * param A : an integer sorted array
     * param target :  an integer to be inserted
     * return : an integer
     */
public:
    int searchInsert(vector&lt;int&gt; &amp;A, int target) {
        int N = A.size();
        if (N == 0) return 0;
        if (A[N-1] &lt; target) return N;
        int lo = 0, hi = N;
        while (lo &lt; hi) {
            int mi = lo + (hi - lo)/2;
            if (A[mi] &lt; target)
                lo = mi + 1;
            else
                hi = mi;
        }
        return lo;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>與lintcode - (14) Binary Search類似，在C++的解法裡我們也使用了[lo, hi)的表示方法，而題意是找出不小於<code>target</code>的最小位置，因此每次二分搜尋的循環裡如果發現<code>A[m]</code>已經小於<code>target</code>，就應該將下界<code>lo</code>往右推，其他狀況則將上界<code>hi</code>向左移動，然而必須注意的是如果<code>target</code>比陣列中所有元素都大，必須返回<code>ho</code>位置，然而此上下界的表示方法是不可能返回<code>ho</code>的，所以還有另外加一個判斷式，如果<code>target</code>已經大於陣列中最後一個元素，就直接返回其位置。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Search Insert Position</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/search-insert-position/">(60) Search Insert Position</a></li>
</ul>
<pre><code>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

Example
[1,3,5,6], 5 → 2
[1,3,5,6], 2 → 1
[1,3,5,6], 7 → 4
[1,3,5,6], 0 → 0
</code></pre><h2>題解</h2>
<p>應該把二分法的問題拆解為<code>find the first/last position of...</code>的問題。由最原始的二分搜尋可找到不小於目標整數的最小下標。返回此下標即可。</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * param A : an integer sorted array
     * param target :  an integer to be inserted
     * return : an integer
     */
    public int searchInsert(int[] A, int target) {
        if (A == null) {
            return -1;
        }
        if (A.length == 0) {
            return 0;
        }

        int start = 0, end = A.length - 1;
        int mid;

        while (start + 1 &lt; end) {
            mid = start + (end - start) / 2;
            if (A[mid] == target) {
                return mid; // no duplicates, if not `end = target;`
            } else if (A[mid] &lt; target) {
                start = mid;
            } else {
                end = mid;
            }
        }

        if (A[start] &gt;= target) {
            return start;
        } else if (A[end] &gt;= target) {
            return end; // in most cases
        } else {
            return end + 1; // A[end] &lt; target;
        }
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>要注意例子中的第三個, [1,3,5,6], 7 → 4，即找不到要找的數字的情況，此時應返回數組長度，即代碼中最後一個else的賦值語句<code>return end + 1;</code></p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
    /** 
     * param A : an integer sorted array
     * param target :  an integer to be inserted
     * return : an integer
     */
public:
    int searchInsert(vector&lt;int&gt; &amp;A, int target) {
        int N = A.size();
        if (N == 0) return 0;
        if (A[N-1] &lt; target) return N;
        int lo = 0, hi = N;
        while (lo &lt; hi) {
            int mi = lo + (hi - lo)/2;
            if (A[mi] &lt; target)
                lo = mi + 1;
            else
                hi = mi;
        }
        return lo;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>與lintcode - (14) Binary Search類似，在C++的解法裡我們也使用了[lo, hi)的表示方法，而題意是找出不小於<code>target</code>的最小位置，因此每次二分搜尋的循環裡如果發現<code>A[m]</code>已經小於<code>target</code>，就應該將下界<code>lo</code>往右推，其他狀況則將上界<code>hi</code>向左移動，然而必須注意的是如果<code>target</code>比陣列中所有元素都大，必須返回<code>ho</code>位置，然而此上下界的表示方法是不可能返回<code>ho</code>的，所以還有另外加一個判斷式，如果<code>target</code>已經大於陣列中最後一個元素，就直接返回其位置。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Search for a Range]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/binary_search/search_for_a_range.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/binary_search/search_for_a_range.html">
        </link>
        <updated>2019-11-03T15:42:11Z</updated>
        <summary type="html"><![CDATA[<h1>Search for a Range</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/search-for-a-range/">(61) Search for a Range</a></li>
</ul>
<pre><code>Given a sorted array of integers, find the starting and ending position of a given target value.

Your algorithm&#39;s runtime complexity must be in the order of O(log n).

If the target is not found in the array, return [-1, -1].

Example
Given [5, 7, 7, 8, 8, 10] and target value 8,
return [3, 4].
</code></pre><h2>題解</h2>
<p>Search for a range 的題目可以拆解為找 first &amp; last position 的題目，即要做兩次二分。由上題二分查找可找到滿足條件的左邊界，因此只需要再將右邊界找出即可。注意到在<code>(target == nums[mid]</code>時賦值語句為<code>end = mid</code>，將其改為<code>start = mid</code>即可找到右邊界，解畢。</p>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * 本代碼fork自九章算法。沒有版權歡迎轉發。
 * http://www.jiuzhang.com/solutions/search-for-a-range/
 */
public class Solution {
    /**
     *@param A : an integer sorted array
     *@param target :  an integer to be inserted
     *return : a list of length 2, [index1, index2]
     */
    public ArrayList&lt;Integer&gt; searchRange(ArrayList&lt;Integer&gt; A, int target) {
        ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        int start, end, mid;
        result.add(-1);
        result.add(-1);

        if (A == null || A.size() == 0) {
            return result;
        }

        // search for left bound
        start = 0;
        end = A.size() - 1;
        while (start + 1 &lt; end) {
            mid = start + (end - start) / 2;
            if (A.get(mid) == target) {
                end = mid; // set end = mid to find the minimum mid
            } else if (A.get(mid) &gt; target) {
                end = mid;
            } else {
                start = mid;
            }
        }
        if (A.get(start) == target) {
            result.set(0, start);
        } else if (A.get(end) == target) {
            result.set(0, end);
        } else {
            return result;
        }

        // search for right bound
        start = 0;
        end = A.size() - 1;
        while (start + 1 &lt; end) {
            mid = start + (end - start) / 2;
            if (A.get(mid) == target) {
                start = mid; // set start = mid to find the maximum mid
            } else if (A.get(mid) &gt; target) {
                end = mid;
            } else {
                start = mid;
            }
        }
        if (A.get(end) == target) {
            result.set(1, end);
        } else if (A.get(start) == target) {
            result.set(1, start);
        } else {
            return result;
        }

        return result;
        // write your code here
    }
}
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>首先對輸入做異常處理，數組為空或者長度為0</li>
<li>初始化 <code>start, end, mid</code>三個變量，注意mid的求值方法，可以防止兩個整型值相加時溢出</li>
<li><strong>使用迭代而不是遞歸</strong>進行二分查找</li>
<li>while終止條件應為<code>start + 1 &lt; end</code>而不是<code>start &lt;= end</code>，<code>start == end</code>時可能出現死循環</li>
<li>先求左邊界，迭代終止時先判斷<code>A.get(start) == target</code>，再判斷<code>A.get(end) == target</code>，因為迭代終止時target必取start或end中的一個，而end又大於start，取左邊界即為start.</li>
<li>再求右邊界，迭代終止時先判斷<code>A.get(end) == target</code>，再判斷<code>A.get(start) == target</code></li>
<li>兩次二分查找除了終止條件不同，中間邏輯也不同，即當<code>A.get(mid) == target</code>如果是左邊界（first postion），中間邏輯是<code>end = mid</code>；若是右邊界（last position），中間邏輯是<code>start = mid</code></li>
<li>兩次二分查找中間勿忘記重置 <code>start, end</code> 的變量值。</li>
</ol>
<h3>C++</h3>
<pre><code>class Solution {
    /** 
     *@param A : an integer sorted array
     *@param target :  an integer to be inserted
     *return : a list of length 2, [index1, index2]
     */
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt; &amp;A, int target) {
        // good, fail are the result
        // When found, returns good, otherwise returns fail
        int N = A.size();
        vector&lt;int&gt; fail = {-1, -1};
        if(N == 0) 
            return fail;
        vector&lt;int&gt; good;

        // search for starting position
        int lo = 0, hi = N;
        while(lo &lt; hi){
            int m = lo + (hi- lo)/2;
            if(A[m] &lt; target)
                lo = m + 1;
            else
                hi = m;
        }

        if(A[lo] != target) 
            return fail;

        good.push_back(lo);

        // search for ending position
        lo = 0; hi = N;
        while(lo &lt; hi){
            int m = lo + (hi - lo)/2;
            if(target &lt; A[m])
                hi = m;
            else
                lo = m + 1;
        }
        good.push_back(lo - 1);

        return good;
    }
};
</code></pre><h3>源碼分析</h3>
<p>與前面題目類似，此題是將兩個子題組合起來，前半為找出&quot;不小於target的最左元素&quot;，後半是&quot;不大於target的最右元素&quot;，同樣的，使用開閉區間[lo, hi)仍然可以簡潔的處理各種邊界條件，僅須注意在解第二個子題&quot;不大於target的最右元素&quot;時，由於每次<code>lo</code>更新時都至少加1，最後會落在我們要求的位置的下一個，因此記得減1回來，若直覺難以理解，可以使用一個例子在紙上推一次每個步驟就可以體會。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Search for a Range</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/search-for-a-range/">(61) Search for a Range</a></li>
</ul>
<pre><code>Given a sorted array of integers, find the starting and ending position of a given target value.

Your algorithm&#39;s runtime complexity must be in the order of O(log n).

If the target is not found in the array, return [-1, -1].

Example
Given [5, 7, 7, 8, 8, 10] and target value 8,
return [3, 4].
</code></pre><h2>題解</h2>
<p>Search for a range 的題目可以拆解為找 first &amp; last position 的題目，即要做兩次二分。由上題二分查找可找到滿足條件的左邊界，因此只需要再將右邊界找出即可。注意到在<code>(target == nums[mid]</code>時賦值語句為<code>end = mid</code>，將其改為<code>start = mid</code>即可找到右邊界，解畢。</p>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * 本代碼fork自九章算法。沒有版權歡迎轉發。
 * http://www.jiuzhang.com/solutions/search-for-a-range/
 */
public class Solution {
    /**
     *@param A : an integer sorted array
     *@param target :  an integer to be inserted
     *return : a list of length 2, [index1, index2]
     */
    public ArrayList&lt;Integer&gt; searchRange(ArrayList&lt;Integer&gt; A, int target) {
        ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        int start, end, mid;
        result.add(-1);
        result.add(-1);

        if (A == null || A.size() == 0) {
            return result;
        }

        // search for left bound
        start = 0;
        end = A.size() - 1;
        while (start + 1 &lt; end) {
            mid = start + (end - start) / 2;
            if (A.get(mid) == target) {
                end = mid; // set end = mid to find the minimum mid
            } else if (A.get(mid) &gt; target) {
                end = mid;
            } else {
                start = mid;
            }
        }
        if (A.get(start) == target) {
            result.set(0, start);
        } else if (A.get(end) == target) {
            result.set(0, end);
        } else {
            return result;
        }

        // search for right bound
        start = 0;
        end = A.size() - 1;
        while (start + 1 &lt; end) {
            mid = start + (end - start) / 2;
            if (A.get(mid) == target) {
                start = mid; // set start = mid to find the maximum mid
            } else if (A.get(mid) &gt; target) {
                end = mid;
            } else {
                start = mid;
            }
        }
        if (A.get(end) == target) {
            result.set(1, end);
        } else if (A.get(start) == target) {
            result.set(1, start);
        } else {
            return result;
        }

        return result;
        // write your code here
    }
}
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>首先對輸入做異常處理，數組為空或者長度為0</li>
<li>初始化 <code>start, end, mid</code>三個變量，注意mid的求值方法，可以防止兩個整型值相加時溢出</li>
<li><strong>使用迭代而不是遞歸</strong>進行二分查找</li>
<li>while終止條件應為<code>start + 1 &lt; end</code>而不是<code>start &lt;= end</code>，<code>start == end</code>時可能出現死循環</li>
<li>先求左邊界，迭代終止時先判斷<code>A.get(start) == target</code>，再判斷<code>A.get(end) == target</code>，因為迭代終止時target必取start或end中的一個，而end又大於start，取左邊界即為start.</li>
<li>再求右邊界，迭代終止時先判斷<code>A.get(end) == target</code>，再判斷<code>A.get(start) == target</code></li>
<li>兩次二分查找除了終止條件不同，中間邏輯也不同，即當<code>A.get(mid) == target</code>如果是左邊界（first postion），中間邏輯是<code>end = mid</code>；若是右邊界（last position），中間邏輯是<code>start = mid</code></li>
<li>兩次二分查找中間勿忘記重置 <code>start, end</code> 的變量值。</li>
</ol>
<h3>C++</h3>
<pre><code>class Solution {
    /** 
     *@param A : an integer sorted array
     *@param target :  an integer to be inserted
     *return : a list of length 2, [index1, index2]
     */
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt; &amp;A, int target) {
        // good, fail are the result
        // When found, returns good, otherwise returns fail
        int N = A.size();
        vector&lt;int&gt; fail = {-1, -1};
        if(N == 0) 
            return fail;
        vector&lt;int&gt; good;

        // search for starting position
        int lo = 0, hi = N;
        while(lo &lt; hi){
            int m = lo + (hi- lo)/2;
            if(A[m] &lt; target)
                lo = m + 1;
            else
                hi = m;
        }

        if(A[lo] != target) 
            return fail;

        good.push_back(lo);

        // search for ending position
        lo = 0; hi = N;
        while(lo &lt; hi){
            int m = lo + (hi - lo)/2;
            if(target &lt; A[m])
                hi = m;
            else
                lo = m + 1;
        }
        good.push_back(lo - 1);

        return good;
    }
};
</code></pre><h3>源碼分析</h3>
<p>與前面題目類似，此題是將兩個子題組合起來，前半為找出&quot;不小於target的最左元素&quot;，後半是&quot;不大於target的最右元素&quot;，同樣的，使用開閉區間[lo, hi)仍然可以簡潔的處理各種邊界條件，僅須注意在解第二個子題&quot;不大於target的最右元素&quot;時，由於每次<code>lo</code>更新時都至少加1，最後會落在我們要求的位置的下一個，因此記得減1回來，若直覺難以理解，可以使用一個例子在紙上推一次每個步驟就可以體會。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[First Bad Version]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/binary_search/first_bad_version.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/binary_search/first_bad_version.html">
        </link>
        <updated>2019-11-03T15:42:11Z</updated>
        <summary type="html"><![CDATA[<h1>First Bad Version</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#python">Python</a></li>
</ul>
</li>
<li><a href="#leetcode版題解">Leetcode版題解</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/first-bad-version/">First Bad Version</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/first-bad-version/">(74) First Bad Version</a></li>
</ul>
<pre><code>The code base version is an integer and start from 1 to n. One day, someone commit a bad version in the code case, so it caused itself and the following versions are all failed in the unit tests.
You can determine whether a version is bad by the following interface:

Java:
    public VersionControl {
        boolean isBadVersion(int version);
    }
C++:
    class VersionControl {
    public:
        bool isBadVersion(int version);
    };
Python:
    class VersionControl:
        def isBadVersion(version)

Find the first bad version.
Note
You should call isBadVersion as few as possible.

Please read the annotation in code area to get the correct way to call isBadVersion in different language. For example, Java is VersionControl.isBadVersion.

Example
Given n=5

Call isBadVersion(3), get false

Call isBadVersion(5), get true

Call isBadVersion(4), get true

return 4 is the first bad version

Challenge
Do not call isBadVersion exceed O(logn) times.
</code></pre><p>題 Search for a Range 的變形，找出左邊界即可。</p>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * public class VersionControl {
 *     public static boolean isBadVersion(int k);
 * }
 * you can use VersionControl.isBadVersion(k) to judge wether 
 * the kth code version is bad or not.
*/
class Solution {
    /**
     * @param n: An integers.
     * @return: An integer which is the first bad version.
     */
    public int findFirstBadVersion(int n) {
        // write your code here
        if (n == 0) {
            return -1;
        }

        int start = 1, end = n, mid;
        while (start + 1 &lt; end) {
            mid = start + (end - start)/2;
            if (VersionControl.isBadVersion(mid) == false) {
                start = mid;
            } else {
                end = mid;
            }
        }

        if (VersionControl.isBadVersion(start) == true) {
            return start;
        } else if (VersionControl.isBadVersion(end) == true) {
            return end;
        } else {
            return -1; // not found
        }
    }
}
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * class VersionControl {
 *     public:
 *     static bool isBadVersion(int k);
 * }
 * you can use VersionControl::isBadVersion(k) to judge wether
 * the kth code version is bad or not.
*/
class Solution {
public:
    /**
     * @param n: An integers.
     * @return: An integer which is the first bad version.
     */
    int findFirstBadVersion(int n) {
        if (n &lt; 1) {
            return -1;
        }

        int start = 1;
        int end = n;
        int mid;
        while (start + 1 &lt; end) {
            mid = start + (end - start) / 2;
            if (VersionControl::isBadVersion(mid)) {
                end = mid;
            } else {
                start = mid;
            }
        }

        if (VersionControl::isBadVersion(start)) {
            return start;
        } else if (VersionControl::isBadVersion(end)) {
            return end;
        }

        return -1;  // find no bad version
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>找左邊界和Search for a Range類似，但是最好要考慮到有可能end處也為good version，此部分異常也可放在開始的時候處理。</p>
<h3>Python</h3>
<pre><code class="lang-python">#class VersionControl:
#    @classmethod
#    def isBadVersion(cls, id)
#        # Run unit tests to check whether verison `id` is a bad version
#        # return true if unit tests passed else false.
# You can use VersionControl.isBadVersion(10) to check whether version 10 is a
# bad version.
class Solution:
    &quot;&quot;&quot;
    @param n: An integers.
    @return: An integer which is the first bad version.
    &quot;&quot;&quot;
    def findFirstBadVersion(self, n):
        if n &lt; 1:
            return -1

        start, end = 1, n
        while start + 1 &lt; end:
            mid = start + (end - start) / 2
            if VersionControl.isBadVersion(mid):
                end = mid
            else:
                start = mid

        if VersionControl.isBadVersion(start):
            return start
        elif VersionControl.isBadVersion(end):
            return end

        return -1
</code></pre>
<h2>Leetcode版題解</h2>
<p>很明顯使用二分搜索，此題的測試只有Bad version必定出現的情況，會不會全部都是好的，可以向面試官詢問清楚，二分搜索的範圍，仍然使用下標範圍[0, n)控制邊界，要注意的是返回值是產品的編號，記得+1。另外直接使用產品編號[1, n+1)是行不通的，因為當n是INT_MAX時就會出現問題。</p>
<pre><code class="lang-c++">// Forward declaration of isBadVersion API.
bool isBadVersion(int version);

class Solution {
public:
    int firstBadVersion(int n) {
        if(isBadVersion(1)) return 1;
        int lo = 0, hi = n;
        while(lo &lt; hi){
            int m = lo + (hi - lo)/2;
            if(!isBadVersion(m) and isBadVersion(m+1)) 
                return m+1;
            else if(isBadVersion(m) and isBadVersion(m+1)) 
                hi = m;
            else 
                lo = m + 1;
        }
    }
};
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1>First Bad Version</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#python">Python</a></li>
</ul>
</li>
<li><a href="#leetcode版題解">Leetcode版題解</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/first-bad-version/">First Bad Version</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/first-bad-version/">(74) First Bad Version</a></li>
</ul>
<pre><code>The code base version is an integer and start from 1 to n. One day, someone commit a bad version in the code case, so it caused itself and the following versions are all failed in the unit tests.
You can determine whether a version is bad by the following interface:

Java:
    public VersionControl {
        boolean isBadVersion(int version);
    }
C++:
    class VersionControl {
    public:
        bool isBadVersion(int version);
    };
Python:
    class VersionControl:
        def isBadVersion(version)

Find the first bad version.
Note
You should call isBadVersion as few as possible.

Please read the annotation in code area to get the correct way to call isBadVersion in different language. For example, Java is VersionControl.isBadVersion.

Example
Given n=5

Call isBadVersion(3), get false

Call isBadVersion(5), get true

Call isBadVersion(4), get true

return 4 is the first bad version

Challenge
Do not call isBadVersion exceed O(logn) times.
</code></pre><p>題 Search for a Range 的變形，找出左邊界即可。</p>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * public class VersionControl {
 *     public static boolean isBadVersion(int k);
 * }
 * you can use VersionControl.isBadVersion(k) to judge wether 
 * the kth code version is bad or not.
*/
class Solution {
    /**
     * @param n: An integers.
     * @return: An integer which is the first bad version.
     */
    public int findFirstBadVersion(int n) {
        // write your code here
        if (n == 0) {
            return -1;
        }

        int start = 1, end = n, mid;
        while (start + 1 &lt; end) {
            mid = start + (end - start)/2;
            if (VersionControl.isBadVersion(mid) == false) {
                start = mid;
            } else {
                end = mid;
            }
        }

        if (VersionControl.isBadVersion(start) == true) {
            return start;
        } else if (VersionControl.isBadVersion(end) == true) {
            return end;
        } else {
            return -1; // not found
        }
    }
}
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * class VersionControl {
 *     public:
 *     static bool isBadVersion(int k);
 * }
 * you can use VersionControl::isBadVersion(k) to judge wether
 * the kth code version is bad or not.
*/
class Solution {
public:
    /**
     * @param n: An integers.
     * @return: An integer which is the first bad version.
     */
    int findFirstBadVersion(int n) {
        if (n &lt; 1) {
            return -1;
        }

        int start = 1;
        int end = n;
        int mid;
        while (start + 1 &lt; end) {
            mid = start + (end - start) / 2;
            if (VersionControl::isBadVersion(mid)) {
                end = mid;
            } else {
                start = mid;
            }
        }

        if (VersionControl::isBadVersion(start)) {
            return start;
        } else if (VersionControl::isBadVersion(end)) {
            return end;
        }

        return -1;  // find no bad version
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>找左邊界和Search for a Range類似，但是最好要考慮到有可能end處也為good version，此部分異常也可放在開始的時候處理。</p>
<h3>Python</h3>
<pre><code class="lang-python">#class VersionControl:
#    @classmethod
#    def isBadVersion(cls, id)
#        # Run unit tests to check whether verison `id` is a bad version
#        # return true if unit tests passed else false.
# You can use VersionControl.isBadVersion(10) to check whether version 10 is a
# bad version.
class Solution:
    &quot;&quot;&quot;
    @param n: An integers.
    @return: An integer which is the first bad version.
    &quot;&quot;&quot;
    def findFirstBadVersion(self, n):
        if n &lt; 1:
            return -1

        start, end = 1, n
        while start + 1 &lt; end:
            mid = start + (end - start) / 2
            if VersionControl.isBadVersion(mid):
                end = mid
            else:
                start = mid

        if VersionControl.isBadVersion(start):
            return start
        elif VersionControl.isBadVersion(end):
            return end

        return -1
</code></pre>
<h2>Leetcode版題解</h2>
<p>很明顯使用二分搜索，此題的測試只有Bad version必定出現的情況，會不會全部都是好的，可以向面試官詢問清楚，二分搜索的範圍，仍然使用下標範圍[0, n)控制邊界，要注意的是返回值是產品的編號，記得+1。另外直接使用產品編號[1, n+1)是行不通的，因為當n是INT_MAX時就會出現問題。</p>
<pre><code class="lang-c++">// Forward declaration of isBadVersion API.
bool isBadVersion(int version);

class Solution {
public:
    int firstBadVersion(int n) {
        if(isBadVersion(1)) return 1;
        int lo = 0, hi = n;
        while(lo &lt; hi){
            int m = lo + (hi - lo)/2;
            if(!isBadVersion(m) and isBadVersion(m+1)) 
                return m+1;
            else if(isBadVersion(m) and isBadVersion(m+1)) 
                hi = m;
            else 
                lo = m + 1;
        }
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Find Peak Element]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/binary_search/find_peak_element.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/binary_search/find_peak_element.html">
        </link>
        <updated>2019-11-03T15:42:11Z</updated>
        <summary type="html"><![CDATA[<h1>Find Peak Element</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解1---lintcode">題解1 - lintcode</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
</ul>
</li>
<li><a href="#題解2---leetcode">題解2 - leetcode</a><ul>
<li><a href="#c-1">C++</a></li>
<li><a href="#java-1">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
<li><a href="#java---compact-implementationleetcodediscussion">Java - compact implementation<sup><a href="#fn_leetcode_discussion" id="reffn_leetcode_discussion">leetcode_discussion</a></sup></a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/find-peak-element/">Find Peak Element | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/find-peak-element/">(75) Find Peak Element</a></li>
</ul>
<pre><code>There is an integer array which has the following features:

    * The numbers in adjacent positions are different.
    * A[0] &lt; A[1] &amp;&amp; A[A.length - 2] &gt; A[A.length - 1].

We define a position P is a peek if A[P] &gt; A[P-1] &amp;&amp; A[P] &gt; A[P+1].

Find a peak element in this array. Return the index of the peak.

Note
The array may contains multiple peeks, find any of them.

Example
[1, 2, 1, 3, 4, 5, 7, 6]

return index 1 (which is number 2)  or 6 (which is number 7)

Challenge
Time complexity O(logN)
</code></pre><h2>題解1 - lintcode</h2>
<p>由時間複雜度的暗示可知應使用二分搜索。首先分析若使用傳統的二分搜索，若<code>A[mid] &gt; A[mid - 1] &amp;&amp; A[mid] &lt; A[mid + 1]</code>，則找到一個peak為A[mid]；若<code>A[mid - 1] &gt; A[mid]</code>，則A[mid]左側必定存在一個peak，可用反證法證明：若左側不存在peak，則A[mid]左側元素必滿足<code>A[0] &gt; A[1] &gt; ... &gt; A[mid -1] &gt; A[mid]</code>，與已知<code>A[0] &lt; A[1]</code>矛盾，證畢。同理可得若<code>A[mid + 1] &gt; A[mid]</code>，則A[mid]右側必定存在一個peak。如此迭代即可得解。</p>
<p>備注：如果本題是找 first/last peak，就不能用二分法了。</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    #@param A: An integers list.
    #@return: return any of peek positions.
    def findPeak(self, A):
        if not A:
            return -1

        l, r = 0, len(A) - 1
        while l + 1 &lt; r:
            mid = l + (r - l) / 2
            if A[mid] &lt; A[mid - 1]:
                r = mid
            elif A[mid] &lt; A[mid + 1]:
                l = mid
            else:
                return mid
        mid = l if A[l] &gt; A[r] else r
        return mid
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param A: An integers array.
     * @return: return any of peek positions.
     */
    int findPeak(vector&lt;int&gt; A) {
        if (A.size() == 0) return -1;

        int l = 0, r = A.size() - 1;
        while (l + 1 &lt; r) {
            int mid = l + (r - l) / 2;
            if (A[mid] &lt; A[mid - 1]) {
                r = mid;
            } else if (A[mid] &lt; A[mid + 1]) {
                l = mid;
            } else {
                return mid;
            }
        }

        int mid = A[l] &gt; A[r] ? l : r;
        return mid;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">class Solution {
    /**
     * @param A: An integers array.
     * @return: return any of peek positions.
     */
    public int findPeak(int[] A) {
        if (A == null || A.length == 0) return -1;

        int l = 0, r = A.length - 1;
        while (l + 1 &lt; r) {
            int mid = l + (r - l) / 2;
            if (A[mid] &lt; A[mid - 1]) {
                r = mid;
            } else if (A[mid] &lt; A[mid + 1]) {
                l = mid;
            } else {
                return mid;
            }
        }

        int mid = A[l] &gt; A[r] ? l : r;
        return mid;
    }
}
</code></pre>
<h2>題解2 - leetcode</h2>
<p>leetcode 上的題和 lintcode 上有細微的變化，題目如下：</p>
<pre><code>A peak element is an element that is greater than its neighbors.

Given an input array where num[i] ≠ num[i+1],
find a peak element and return its index.

The array may contain multiple peaks,
in that case return the index to any one of the peaks is fine.

You may imagine that num[-1] = num[n] = -∞.

For example, in array [1, 2, 3, 1], 3 is a peak element and
your function should return the index number 2.

click to show spoilers.

Note:
Your solution should be in logarithmic complexity.
</code></pre><p>如果一開始做的是 leetcode 上的版本而不是 lintcode 上的話，這道題難度要大一些。有了以上的分析基礎再來刷 leetcode 上的這道題就是小 case 了，注意題中的關鍵提示<code>num[-1] = num[n] = -∞</code>, 雖然不像 lintcode 上那麼直接，但是稍微變通下也能想到。即<code>num[-1] &lt; num[0] &amp;&amp; num[n-1] &gt; num[n]</code>, 那麼問題來了，這樣一來就不能確定峰值一定存在了，因為給定數組為單調序列的話就咩有峰值了，但是實際情況是——題中有負無窮的假設，也就是說在單調序列的情況下，峰值為數組首部或者尾部元素，誰大就是誰了。</p>
<h3>C++</h3>
<pre><code class="lang-C++">class Solution {
public:
    int findPeakElement(vector&lt;int&gt;&amp; arr) {
        int N = arr.size();
        int lo = 0, hi = N;
        while(lo &lt; hi) {
            int mi = lo + (hi - lo)/2;
            if( (mi == 0 || arr[mi-1] &lt;= arr[mi] ) &amp;&amp; (mi == N-1 || arr[mi] &gt;= arr[mi+1]) ) 
                return mi;
            else if((mi == 0 || arr[mi-1] &lt;= arr[mi] ))
                lo = mi + 1;
            else
                hi = mi;
        }
        return -1;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    public int findPeakElement(int[] nums) {
        if (nums == null || nums.length == 0) return -1;

        int l = 0, r = nums.length - 1;
        while (l + 1 &lt; r) {
            mid = l + (r - l) / 2;
            if (nums[mid] &lt; nums[mid - 1]) {
                // 1 peak at least in the left side
                r = mid;
            } else if (nums[mid] &lt; nums[mid + 1]) {
                // 1 peak at least in the right side
                l = mid;
            } else {
                return mid;
            }
        }

        mid = nums[l] &gt; nums[r] ? l : r;
        return mid;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>典型的二分法模板應用，需要注意的是需要考慮單調序列的特殊情況。當然也可使用緊湊一點的實現如改寫循環條件為<code>l &lt; r</code>，這樣就不用考慮單調序列了，見實現2.</p>
<h3>複雜度分析</h3>
<p>二分法，時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h3>Java - compact implementation<sup><a href="#fn_leetcode_discussion" id="reffn_leetcode_discussion">leetcode_discussion</a></sup></h3>
<pre><code class="lang-java">public class Solution {
    public int findPeakElement(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }

        int start = 0, end = nums.length - 1, mid = end / 2;
        while (start &lt; end) {
            if (nums[mid] &lt; nums[mid + 1]) {
                // 1 peak at least in the right side
                start = mid + 1;
            } else {
                // 1 peak at least in the left side
                end = mid;
            }
            mid = start + (end - start) / 2;
        }

        return start;
    }
}
</code></pre>
<p>C++ 的代碼可參考 Java 或者 @xuewei4d 的實現。</p>
<blockquote>
<p><strong>Warning</strong> leetcode 和 lintcode 上給的方法名不一樣，leetcode 上的為<code>findPeakElement</code>而 lintcode 上為<code>findPeak</code>，弄混的話會編譯錯誤。</p>
</blockquote>
<h2>Reference</h2>
<ul>
<li><blockquote id="fn_leetcode_discussion">
<sup>leetcode_discussion</sup>. <a href="https://leetcode.com/discuss/23840/java-binary-search-solution">Java - Binary-Search Solution - Leetcode Discuss</a><a href="#reffn_leetcode_discussion" title="Jump back to footnote [leetcode_discussion] in the text."> &#8617;</a>
</blockquote>
</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Find Peak Element</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解1---lintcode">題解1 - lintcode</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
</ul>
</li>
<li><a href="#題解2---leetcode">題解2 - leetcode</a><ul>
<li><a href="#c-1">C++</a></li>
<li><a href="#java-1">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
<li><a href="#java---compact-implementationleetcodediscussion">Java - compact implementation<sup><a href="#fn_leetcode_discussion" id="reffn_leetcode_discussion">leetcode_discussion</a></sup></a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/find-peak-element/">Find Peak Element | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/find-peak-element/">(75) Find Peak Element</a></li>
</ul>
<pre><code>There is an integer array which has the following features:

    * The numbers in adjacent positions are different.
    * A[0] &lt; A[1] &amp;&amp; A[A.length - 2] &gt; A[A.length - 1].

We define a position P is a peek if A[P] &gt; A[P-1] &amp;&amp; A[P] &gt; A[P+1].

Find a peak element in this array. Return the index of the peak.

Note
The array may contains multiple peeks, find any of them.

Example
[1, 2, 1, 3, 4, 5, 7, 6]

return index 1 (which is number 2)  or 6 (which is number 7)

Challenge
Time complexity O(logN)
</code></pre><h2>題解1 - lintcode</h2>
<p>由時間複雜度的暗示可知應使用二分搜索。首先分析若使用傳統的二分搜索，若<code>A[mid] &gt; A[mid - 1] &amp;&amp; A[mid] &lt; A[mid + 1]</code>，則找到一個peak為A[mid]；若<code>A[mid - 1] &gt; A[mid]</code>，則A[mid]左側必定存在一個peak，可用反證法證明：若左側不存在peak，則A[mid]左側元素必滿足<code>A[0] &gt; A[1] &gt; ... &gt; A[mid -1] &gt; A[mid]</code>，與已知<code>A[0] &lt; A[1]</code>矛盾，證畢。同理可得若<code>A[mid + 1] &gt; A[mid]</code>，則A[mid]右側必定存在一個peak。如此迭代即可得解。</p>
<p>備注：如果本題是找 first/last peak，就不能用二分法了。</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    #@param A: An integers list.
    #@return: return any of peek positions.
    def findPeak(self, A):
        if not A:
            return -1

        l, r = 0, len(A) - 1
        while l + 1 &lt; r:
            mid = l + (r - l) / 2
            if A[mid] &lt; A[mid - 1]:
                r = mid
            elif A[mid] &lt; A[mid + 1]:
                l = mid
            else:
                return mid
        mid = l if A[l] &gt; A[r] else r
        return mid
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param A: An integers array.
     * @return: return any of peek positions.
     */
    int findPeak(vector&lt;int&gt; A) {
        if (A.size() == 0) return -1;

        int l = 0, r = A.size() - 1;
        while (l + 1 &lt; r) {
            int mid = l + (r - l) / 2;
            if (A[mid] &lt; A[mid - 1]) {
                r = mid;
            } else if (A[mid] &lt; A[mid + 1]) {
                l = mid;
            } else {
                return mid;
            }
        }

        int mid = A[l] &gt; A[r] ? l : r;
        return mid;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">class Solution {
    /**
     * @param A: An integers array.
     * @return: return any of peek positions.
     */
    public int findPeak(int[] A) {
        if (A == null || A.length == 0) return -1;

        int l = 0, r = A.length - 1;
        while (l + 1 &lt; r) {
            int mid = l + (r - l) / 2;
            if (A[mid] &lt; A[mid - 1]) {
                r = mid;
            } else if (A[mid] &lt; A[mid + 1]) {
                l = mid;
            } else {
                return mid;
            }
        }

        int mid = A[l] &gt; A[r] ? l : r;
        return mid;
    }
}
</code></pre>
<h2>題解2 - leetcode</h2>
<p>leetcode 上的題和 lintcode 上有細微的變化，題目如下：</p>
<pre><code>A peak element is an element that is greater than its neighbors.

Given an input array where num[i] ≠ num[i+1],
find a peak element and return its index.

The array may contain multiple peaks,
in that case return the index to any one of the peaks is fine.

You may imagine that num[-1] = num[n] = -∞.

For example, in array [1, 2, 3, 1], 3 is a peak element and
your function should return the index number 2.

click to show spoilers.

Note:
Your solution should be in logarithmic complexity.
</code></pre><p>如果一開始做的是 leetcode 上的版本而不是 lintcode 上的話，這道題難度要大一些。有了以上的分析基礎再來刷 leetcode 上的這道題就是小 case 了，注意題中的關鍵提示<code>num[-1] = num[n] = -∞</code>, 雖然不像 lintcode 上那麼直接，但是稍微變通下也能想到。即<code>num[-1] &lt; num[0] &amp;&amp; num[n-1] &gt; num[n]</code>, 那麼問題來了，這樣一來就不能確定峰值一定存在了，因為給定數組為單調序列的話就咩有峰值了，但是實際情況是——題中有負無窮的假設，也就是說在單調序列的情況下，峰值為數組首部或者尾部元素，誰大就是誰了。</p>
<h3>C++</h3>
<pre><code class="lang-C++">class Solution {
public:
    int findPeakElement(vector&lt;int&gt;&amp; arr) {
        int N = arr.size();
        int lo = 0, hi = N;
        while(lo &lt; hi) {
            int mi = lo + (hi - lo)/2;
            if( (mi == 0 || arr[mi-1] &lt;= arr[mi] ) &amp;&amp; (mi == N-1 || arr[mi] &gt;= arr[mi+1]) ) 
                return mi;
            else if((mi == 0 || arr[mi-1] &lt;= arr[mi] ))
                lo = mi + 1;
            else
                hi = mi;
        }
        return -1;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    public int findPeakElement(int[] nums) {
        if (nums == null || nums.length == 0) return -1;

        int l = 0, r = nums.length - 1;
        while (l + 1 &lt; r) {
            mid = l + (r - l) / 2;
            if (nums[mid] &lt; nums[mid - 1]) {
                // 1 peak at least in the left side
                r = mid;
            } else if (nums[mid] &lt; nums[mid + 1]) {
                // 1 peak at least in the right side
                l = mid;
            } else {
                return mid;
            }
        }

        mid = nums[l] &gt; nums[r] ? l : r;
        return mid;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>典型的二分法模板應用，需要注意的是需要考慮單調序列的特殊情況。當然也可使用緊湊一點的實現如改寫循環條件為<code>l &lt; r</code>，這樣就不用考慮單調序列了，見實現2.</p>
<h3>複雜度分析</h3>
<p>二分法，時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h3>Java - compact implementation<sup><a href="#fn_leetcode_discussion" id="reffn_leetcode_discussion">leetcode_discussion</a></sup></h3>
<pre><code class="lang-java">public class Solution {
    public int findPeakElement(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }

        int start = 0, end = nums.length - 1, mid = end / 2;
        while (start &lt; end) {
            if (nums[mid] &lt; nums[mid + 1]) {
                // 1 peak at least in the right side
                start = mid + 1;
            } else {
                // 1 peak at least in the left side
                end = mid;
            }
            mid = start + (end - start) / 2;
        }

        return start;
    }
}
</code></pre>
<p>C++ 的代碼可參考 Java 或者 @xuewei4d 的實現。</p>
<blockquote>
<p><strong>Warning</strong> leetcode 和 lintcode 上給的方法名不一樣，leetcode 上的為<code>findPeakElement</code>而 lintcode 上為<code>findPeak</code>，弄混的話會編譯錯誤。</p>
</blockquote>
<h2>Reference</h2>
<ul>
<li><blockquote id="fn_leetcode_discussion">
<sup>leetcode_discussion</sup>. <a href="https://leetcode.com/discuss/23840/java-binary-search-solution">Java - Binary-Search Solution - Leetcode Discuss</a><a href="#reffn_leetcode_discussion" title="Jump back to footnote [leetcode_discussion] in the text."> &#8617;</a>
</blockquote>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sqrt x]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/binary_search/sqrt_x.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/binary_search/sqrt_x.html">
        </link>
        <updated>2019-11-03T15:42:11Z</updated>
        <summary type="html"><![CDATA[<h1>Sqrt x</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解---二分搜索">題解 - 二分搜索</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/sqrtx/">Sqrt(x) | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/sqrtx/">(141) Sqrt(x)</a></li>
</ul>
<h2>題解 - 二分搜索</h2>
<p>由於只需要求整數部分，故對於任意正整數 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>, 設其整數部分為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>, 顯然有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">1 \leq k \leq x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mrel">≤</span><span class="mord mathit">x</span></span></span></span>, 求解 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span> 的值也就轉化為了在有序陣列中查找滿足某種約束條件的元素，顯然二分搜索是解決此類問題的良方。</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    # @param {integer} x
    # @return {integer}
    def mySqrt(self, x):
        if x &lt; 0:
            return -1
        elif x == 0:
            return 0

        start, end = 1, x
        while start + 1 &lt; end:
            mid = start + (end - start) / 2
            if mid**2 == x:
                return mid
            elif mid**2 &gt; x:
                end = mid
            else:
                start = mid

        return start
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>異常檢測，先處理小於等於0的值。</li>
<li>使用二分搜索的經典模板，注意不能使用<code>start &lt; end</code>, 否則在給定值1時產生死循環。</li>
<li>最後返回平方根的整數部分<code>start</code>.</li>
</ol>
<p>二分搜索過程很好理解，關鍵是最後的返回結果還需不需要判斷？比如是取 start, end, 還是 mid? 我們首先來分析下二分搜索的循環條件，由<code>while</code>循環條件<code>start + 1 &lt; end</code>可知，<code>start</code>和<code>end</code>只可能有兩種關系，一個是<code>end == 1 || end ==2</code>這一特殊情況，返回值均為1，另一個就是循環終止時<code>start</code>恰好在<code>end</code>前一個元素。設值 x 的整數部分為 k, 那麼在執行二分搜索的過程中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>e</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex"> start \leq k \leq end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">t</span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mrel">≤</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">d</span></span></span></span> 關系一直存在，也就是說在沒有找到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><msup><mi>d</mi><mn>2</mn></msup><mo>=</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">mid^2 == x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord"><span class="mord mathit">d</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">=</span><span class="mrel">=</span><span class="mord mathit">x</span></span></span></span> 時，循環退出時有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo>&lt;</mo><mi>k</mi><mo>&lt;</mo><mi>e</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">start &lt; k &lt; end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">t</span><span class="mrel">&lt;</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mrel">&lt;</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">d</span></span></span></span>, 取整的話顯然就是<code>start</code>了。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution{
public:
    int mySqrt(int x) {
        if(x &lt;= 1) return x;
        int lo = 2, hi = x;
        while(lo &lt; hi){
            int m = lo + (hi - lo)/2;
            int q = x/m;
            if(q == m and x % m == 0)
                return m;
            else if(q &lt; m)
                hi = m;
            else
                lo = m + 1;
        }

        return lo - 1;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>此題依然可以被翻譯成&quot;找不大於target的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>&quot;，而所有待選的自然數當然是有序數列，因此同樣可以用二分搜索的思維解題，然而此題不會出現重複元素，因此可以增加一個相等就返回的條件，另外這邊我們同樣使用[lo, hi)的標示法來處理邊界條件，可以參照[Search for a range]，就不再贅述。另外特別注意，判斷找到的條件不是用<code>m * m == x</code>而是<code>x / m == m</code>，這是因為<code>x * x</code>可能會超出<code>INT_MAX</code>而溢位，因此用除法可以解決這個問題，再輔以餘數判斷是否整除以及下一步的走法。</p>
<h3>複雜度分析</h3>
<p>經典的二分搜索，時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 使用了<code>start</code>, <code>end</code>, <code>mid</code>變量，空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<p>除了使用二分法求平方根近似解之外，還可使用牛頓迭代法進一步提高運算效率，欲知後事如何，請猛戳 <a href="http://www.nowamagic.net/algorithm/algorithm_EfficacyOfFunctionSqrt.php">求平方根sqrt()函數的底層算法效率問題 -- 簡明現代魔法</a>，不得不感歎演算法的魔力！</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Sqrt x</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解---二分搜索">題解 - 二分搜索</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/sqrtx/">Sqrt(x) | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/sqrtx/">(141) Sqrt(x)</a></li>
</ul>
<h2>題解 - 二分搜索</h2>
<p>由於只需要求整數部分，故對於任意正整數 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span>, 設其整數部分為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span>, 顯然有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">1 \leq k \leq x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mrel">≤</span><span class="mord mathit">x</span></span></span></span>, 求解 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span> 的值也就轉化為了在有序陣列中查找滿足某種約束條件的元素，顯然二分搜索是解決此類問題的良方。</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    # @param {integer} x
    # @return {integer}
    def mySqrt(self, x):
        if x &lt; 0:
            return -1
        elif x == 0:
            return 0

        start, end = 1, x
        while start + 1 &lt; end:
            mid = start + (end - start) / 2
            if mid**2 == x:
                return mid
            elif mid**2 &gt; x:
                end = mid
            else:
                start = mid

        return start
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>異常檢測，先處理小於等於0的值。</li>
<li>使用二分搜索的經典模板，注意不能使用<code>start &lt; end</code>, 否則在給定值1時產生死循環。</li>
<li>最後返回平方根的整數部分<code>start</code>.</li>
</ol>
<p>二分搜索過程很好理解，關鍵是最後的返回結果還需不需要判斷？比如是取 start, end, 還是 mid? 我們首先來分析下二分搜索的循環條件，由<code>while</code>循環條件<code>start + 1 &lt; end</code>可知，<code>start</code>和<code>end</code>只可能有兩種關系，一個是<code>end == 1 || end ==2</code>這一特殊情況，返回值均為1，另一個就是循環終止時<code>start</code>恰好在<code>end</code>前一個元素。設值 x 的整數部分為 k, 那麼在執行二分搜索的過程中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>e</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex"> start \leq k \leq end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">t</span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mrel">≤</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">d</span></span></span></span> 關系一直存在，也就是說在沒有找到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><msup><mi>d</mi><mn>2</mn></msup><mo>=</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">mid^2 == x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord"><span class="mord mathit">d</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">=</span><span class="mrel">=</span><span class="mord mathit">x</span></span></span></span> 時，循環退出時有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo>&lt;</mo><mi>k</mi><mo>&lt;</mo><mi>e</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">start &lt; k &lt; end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">t</span><span class="mrel">&lt;</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mrel">&lt;</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">d</span></span></span></span>, 取整的話顯然就是<code>start</code>了。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution{
public:
    int mySqrt(int x) {
        if(x &lt;= 1) return x;
        int lo = 2, hi = x;
        while(lo &lt; hi){
            int m = lo + (hi - lo)/2;
            int q = x/m;
            if(q == m and x % m == 0)
                return m;
            else if(q &lt; m)
                hi = m;
            else
                lo = m + 1;
        }

        return lo - 1;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>此題依然可以被翻譯成&quot;找不大於target的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>&quot;，而所有待選的自然數當然是有序數列，因此同樣可以用二分搜索的思維解題，然而此題不會出現重複元素，因此可以增加一個相等就返回的條件，另外這邊我們同樣使用[lo, hi)的標示法來處理邊界條件，可以參照[Search for a range]，就不再贅述。另外特別注意，判斷找到的條件不是用<code>m * m == x</code>而是<code>x / m == m</code>，這是因為<code>x * x</code>可能會超出<code>INT_MAX</code>而溢位，因此用除法可以解決這個問題，再輔以餘數判斷是否整除以及下一步的走法。</p>
<h3>複雜度分析</h3>
<p>經典的二分搜索，時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 使用了<code>start</code>, <code>end</code>, <code>mid</code>變量，空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<p>除了使用二分法求平方根近似解之外，還可使用牛頓迭代法進一步提高運算效率，欲知後事如何，請猛戳 <a href="http://www.nowamagic.net/algorithm/algorithm_EfficacyOfFunctionSqrt.php">求平方根sqrt()函數的底層算法效率問題 -- 簡明現代魔法</a>，不得不感歎演算法的魔力！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Count 1 in Binary]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/math_and_bit_manipulation/count_1_in_binary.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/math_and_bit_manipulation/count_1_in_binary.html">
        </link>
        <updated>2019-11-03T15:42:12Z</updated>
        <summary type="html"><![CDATA[<h1>Count 1 in Binary</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/count-1-in-binary/">(365) Count 1 in Binary</a></li>
</ul>
<pre><code>Count how many 1 in binary representation of a 32-bit integer.

Example
Given 32, return 1

Given 5, return 2

Given 1023, return 9

Challenge
If the integer is n bits with m 1 bits. Can you do it in O(m) time?
</code></pre><h2>題解</h2>
<p>題 <a href="http://algorithm.yuanbin.me/zh-hans/math_and_bit_manipulation/o1_check_power_of_2.html">O1 Check Power of 2</a> 的進階版，<code>x &amp; (x - 1)</code> 的含義爲去掉二進制數中1的最後一位，無論 x 是正數還是負數都成立。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param num: an integer
     * @return: an integer, the number of ones in num
     */
    int countOnes(int num) {
        int count=0;
        while (num) {
            num &amp;= num-1;
            count++;
        }
        return count;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param num: an integer
     * @return: an integer, the number of ones in num
     */
    public int countOnes(int num) {
        int count = 0;
        while (num != 0) {
            num = num &amp; (num - 1);
            count++;
        }

        return count;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>累加計數器即可。</p>
<h3>複雜度分析</h3>
<p>這種算法依賴於數中1的個數，時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mclose">)</span></span></span></span>. 空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><a href="http://articles.leetcode.com/2010/09/number-of-1-bits.html">Number of 1 bits | LeetCode</a> - 評論中有關於不同演算法性能的討論</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Count 1 in Binary</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/count-1-in-binary/">(365) Count 1 in Binary</a></li>
</ul>
<pre><code>Count how many 1 in binary representation of a 32-bit integer.

Example
Given 32, return 1

Given 5, return 2

Given 1023, return 9

Challenge
If the integer is n bits with m 1 bits. Can you do it in O(m) time?
</code></pre><h2>題解</h2>
<p>題 <a href="http://algorithm.yuanbin.me/zh-hans/math_and_bit_manipulation/o1_check_power_of_2.html">O1 Check Power of 2</a> 的進階版，<code>x &amp; (x - 1)</code> 的含義爲去掉二進制數中1的最後一位，無論 x 是正數還是負數都成立。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param num: an integer
     * @return: an integer, the number of ones in num
     */
    int countOnes(int num) {
        int count=0;
        while (num) {
            num &amp;= num-1;
            count++;
        }
        return count;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param num: an integer
     * @return: an integer, the number of ones in num
     */
    public int countOnes(int num) {
        int count = 0;
        while (num != 0) {
            num = num &amp; (num - 1);
            count++;
        }

        return count;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>累加計數器即可。</p>
<h3>複雜度分析</h3>
<p>這種算法依賴於數中1的個數，時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mclose">)</span></span></span></span>. 空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><a href="http://articles.leetcode.com/2010/09/number-of-1-bits.html">Number of 1 bits | LeetCode</a> - 評論中有關於不同演算法性能的討論</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[A plus B Problem]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/math_and_bit_manipulation/a_plus_b_problem.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/math_and_bit_manipulation/a_plus_b_problem.html">
        </link>
        <updated>2019-11-03T15:42:12Z</updated>
        <summary type="html"><![CDATA[<h1>A plus B Problem</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/a-b-problem/">(1) A + B Problem</a></li>
</ul>
<pre><code>Write a function that add two numbers A and B.
You should not use + or any arithmetic operators.


Example
Given a=1 and b=2 return 3

Note
There is no need to read data from standard input stream.
Both parameters are given in function aplusb,
you job is to calculate the sum and return it.
Challenge
Of course you can just return a + b to get accepted.
But Can you challenge not do it like that?
Clarification
Are a and b both 32-bit integers?
Yes.
Can I use bit operation?

Sure you can.
</code></pre><h2>題解</h2>
<p>不用加減法實現加法，類似數字電路中的全加器 (Full Adder)，XOR 求得部分和，OR 求得進位，最後將進位作爲加法器的輸入，典型的遞迴實現思路。</p>
<h3>Java</h3>
<pre><code class="lang-java">class Solution {
    /*
     * param a: The first integer
     * param b: The second integer
     * return: The sum of a and b
     */
    public int aplusb(int a, int b) {
        int result = a ^ b;
        int carry = a &amp; b;
        carry &lt;&lt;= 1;
        if (carry != 0) {
            result = aplusb(result, carry);
        }

        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>遞迴步爲進位是否爲0，爲0時返回。</p>
<h3>複雜度分析</h3>
<p>取決於進位，近似爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>. 使用了部分額外變量，空間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
]]></summary>
        <content type="html"><![CDATA[<h1>A plus B Problem</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/a-b-problem/">(1) A + B Problem</a></li>
</ul>
<pre><code>Write a function that add two numbers A and B.
You should not use + or any arithmetic operators.


Example
Given a=1 and b=2 return 3

Note
There is no need to read data from standard input stream.
Both parameters are given in function aplusb,
you job is to calculate the sum and return it.
Challenge
Of course you can just return a + b to get accepted.
But Can you challenge not do it like that?
Clarification
Are a and b both 32-bit integers?
Yes.
Can I use bit operation?

Sure you can.
</code></pre><h2>題解</h2>
<p>不用加減法實現加法，類似數字電路中的全加器 (Full Adder)，XOR 求得部分和，OR 求得進位，最後將進位作爲加法器的輸入，典型的遞迴實現思路。</p>
<h3>Java</h3>
<pre><code class="lang-java">class Solution {
    /*
     * param a: The first integer
     * param b: The second integer
     * return: The sum of a and b
     */
    public int aplusb(int a, int b) {
        int result = a ^ b;
        int carry = a &amp; b;
        carry &lt;&lt;= 1;
        if (carry != 0) {
            result = aplusb(result, carry);
        }

        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>遞迴步爲進位是否爲0，爲0時返回。</p>
<h3>複雜度分析</h3>
<p>取決於進位，近似爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>. 使用了部分額外變量，空間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Plus One]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/math_and_bit_manipulation/plus_one.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/math_and_bit_manipulation/plus_one.html">
        </link>
        <updated>2019-11-03T15:42:12Z</updated>
        <summary type="html"><![CDATA[<h1>Plus One</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#example">Example</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/plus-one/">Plus One | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/plus-one/">(407) Plus One</a></li>
</ul>
<h3>Problem Statement</h3>
<p>Given a non-negative number represented as an array of digits, plus one to the number.</p>
<p>The digits are stored such that the most significant digit is at the head of the list.</p>
<h4>Example</h4>
<p>Given [1,2,3] which represents 123, return [1,2,4].</p>
<p>Given [9,9,9] which represents 999, return [1,0,0,0].</p>
<h2>題解</h2>
<p>又是一道兩個整數按數位相加的題，自後往前累加，處理下進位即可。這道題中是加1，其實還可以擴展至加2，加3等。</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param digits a number represented as an array of digits
     * @return the result
     */
    public int[] plusOne(int[] digits) {
        return plusDigit(digits, 1);
    }

    private int[] plusDigit(int[] digits, int digit) {
        if (digits == null || digits.length == 0) return null;

        // regard digit(0~9) as carry
        int carry = digit;
        int[] result = new int[digits.length];
        for (int i = digits.length - 1; i &gt;= 0; i--) {
            result[i] = (digits[i] + carry) % 10;
            carry = (digits[i] + carry) / 10;
        }

        // carry == 1
        if (carry == 1) {
            int[] finalResult = new int[result.length + 1];
            finalResult[0] = 1;
            return finalResult;
        }

        return result;
    }
}
</code></pre>
<h3>C++</h3>
<pre><code class="lang-C">class Solution {
public:
    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) {
        int carry = 1;
        for(int i = digits.size() - 1; i &gt;= 0; i--){
            digits[i] += carry;
            carry = digits[i] / 10;
            digits[i] %= 10;
        }

        if(carry == 1){
            digits.insert(digits.begin(), 1);
        }
        return digits;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>源碼中單獨實現了加任何數(0~9)的私有方法，更為通用，對於末尾第一個數，可以將要加的數當做進位處理，這樣就不必單獨區分最後一位了，十分優雅！</p>
<h3>複雜度分析</h3>
<p>Java 中需要返回數組，而這個數組在處理之前是不知道大小的，故需要對最後一個進位單獨處理。時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 空間複雜度在最後一位有進位時惡化為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 當然也可以通過兩次循環使得空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li>Soulmachine 的 leetcode 題解，將要加的數當做進位處理就是從這學到的。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Plus One</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#example">Example</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/plus-one/">Plus One | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/plus-one/">(407) Plus One</a></li>
</ul>
<h3>Problem Statement</h3>
<p>Given a non-negative number represented as an array of digits, plus one to the number.</p>
<p>The digits are stored such that the most significant digit is at the head of the list.</p>
<h4>Example</h4>
<p>Given [1,2,3] which represents 123, return [1,2,4].</p>
<p>Given [9,9,9] which represents 999, return [1,0,0,0].</p>
<h2>題解</h2>
<p>又是一道兩個整數按數位相加的題，自後往前累加，處理下進位即可。這道題中是加1，其實還可以擴展至加2，加3等。</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param digits a number represented as an array of digits
     * @return the result
     */
    public int[] plusOne(int[] digits) {
        return plusDigit(digits, 1);
    }

    private int[] plusDigit(int[] digits, int digit) {
        if (digits == null || digits.length == 0) return null;

        // regard digit(0~9) as carry
        int carry = digit;
        int[] result = new int[digits.length];
        for (int i = digits.length - 1; i &gt;= 0; i--) {
            result[i] = (digits[i] + carry) % 10;
            carry = (digits[i] + carry) / 10;
        }

        // carry == 1
        if (carry == 1) {
            int[] finalResult = new int[result.length + 1];
            finalResult[0] = 1;
            return finalResult;
        }

        return result;
    }
}
</code></pre>
<h3>C++</h3>
<pre><code class="lang-C">class Solution {
public:
    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) {
        int carry = 1;
        for(int i = digits.size() - 1; i &gt;= 0; i--){
            digits[i] += carry;
            carry = digits[i] / 10;
            digits[i] %= 10;
        }

        if(carry == 1){
            digits.insert(digits.begin(), 1);
        }
        return digits;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>源碼中單獨實現了加任何數(0~9)的私有方法，更為通用，對於末尾第一個數，可以將要加的數當做進位處理，這樣就不必單獨區分最後一位了，十分優雅！</p>
<h3>複雜度分析</h3>
<p>Java 中需要返回數組，而這個數組在處理之前是不知道大小的，故需要對最後一個進位單獨處理。時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 空間複雜度在最後一位有進位時惡化為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 當然也可以通過兩次循環使得空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li>Soulmachine 的 leetcode 題解，將要加的數當做進位處理就是從這學到的。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linked List]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/linked_list/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/linked_list/">
        </link>
        <updated>2019-11-03T15:42:12Z</updated>
        <summary type="html"><![CDATA[<h1>Linked List - 鏈表</h1>
<p>本節包含鏈表的一些常用操作，如刪除、插入和合併等。</p>
<p>常見錯誤有 遍歷鏈表不向前遞推節點，遍歷鏈表前未保存頭節點，返回鏈表節點指標錯誤。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Linked List - 鏈表</h1>
<p>本節包含鏈表的一些常用操作，如刪除、插入和合併等。</p>
<p>常見錯誤有 遍歷鏈表不向前遞推節點，遍歷鏈表前未保存頭節點，返回鏈表節點指標錯誤。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Remove Duplicates from Sorted List]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/linked_list/remove_duplicates_from_sorted_list.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/linked_list/remove_duplicates_from_sorted_list.html">
        </link>
        <updated>2019-11-03T15:42:13Z</updated>
        <summary type="html"><![CDATA[<h1>Remove Duplicates from Sorted List</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">Remove Duplicates from Sorted List | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/remove-duplicates-from-sorted-list/">(112) Remove Duplicates from Sorted List</a></li>
</ul>
<pre><code>Given a sorted linked list,
delete all duplicates such that each element appear only once.

Example
Given 1-&gt;1-&gt;2, return 1-&gt;2.
Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.
</code></pre><h2>題解</h2>
<p>遍歷之，遇到當前節點和下一節點的值相同時，刪除下一節點，並將當前節點<code>next</code>值指向下一個節點的<code>next</code>, 當前節點首先保持不變，直到相鄰節點的值不等時才移動到下一節點。</p>
<h3>Python</h3>
<pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # @param {ListNode} head
    # @return {ListNode}
    def deleteDuplicates(self, head):
        if head is None:
            return None

        node = head
        while node.next is not None:
            if node.val == node.next.val:
                node.next = node.next.next
            else:
                node = node.next

        return head
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of ListNode
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;next = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param head: The first node of linked list.
     * @return: head node
     */
    ListNode *deleteDuplicates(ListNode *head) {
        if (head == NULL) {
            return NULL;
        }

        ListNode *node = head;
        while (node-&gt;next != NULL) {
            if (node-&gt;val == node-&gt;next-&gt;val) {
                ListNode *temp = node-&gt;next;
                node-&gt;next = node-&gt;next-&gt;next;
                delete temp;
            } else {
                node = node-&gt;next;
            }
        }

        return head;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) return null;

        ListNode node = head;
        while (node.next != null) {
            if (node.val == node.next.val) {
                node.next = node.next.next;
            } else {
                node = node.next;
            }
        }

        return head;
    }
}
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>首先進行異常處理，判斷head是否為NULL</li>
<li>遍歷鏈表，<code>node-&gt;val == node-&gt;next-&gt;val</code>時，保存<code>node-&gt;next</code>，便於後面釋放記憶體(非C/C++無需手動管理記憶體)</li>
<li>不相等時移動當前節點至下一節點，注意這個步驟必須包含在<code>else</code>中，否則邏輯較為複雜</li>
</ol>
<p><code>while</code> 循環處也可使用<code>node != null &amp;&amp; node-&gt;next != null</code>, 這樣就不用單獨判斷<code>head</code> 是否為空了，但是這樣會降低遍歷的效率，因為需要判斷兩處。</p>
<h3>複雜度分析</h3>
<p>遍歷鏈表一次，時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 使用了一個變數進行遍歷，空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.jiuzhang.com/solutions/remove-duplicates-from-sorted-list/">Remove Duplicates from Sorted List 參考程序 | 九章</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Remove Duplicates from Sorted List</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">Remove Duplicates from Sorted List | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/remove-duplicates-from-sorted-list/">(112) Remove Duplicates from Sorted List</a></li>
</ul>
<pre><code>Given a sorted linked list,
delete all duplicates such that each element appear only once.

Example
Given 1-&gt;1-&gt;2, return 1-&gt;2.
Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.
</code></pre><h2>題解</h2>
<p>遍歷之，遇到當前節點和下一節點的值相同時，刪除下一節點，並將當前節點<code>next</code>值指向下一個節點的<code>next</code>, 當前節點首先保持不變，直到相鄰節點的值不等時才移動到下一節點。</p>
<h3>Python</h3>
<pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # @param {ListNode} head
    # @return {ListNode}
    def deleteDuplicates(self, head):
        if head is None:
            return None

        node = head
        while node.next is not None:
            if node.val == node.next.val:
                node.next = node.next.next
            else:
                node = node.next

        return head
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of ListNode
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;next = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param head: The first node of linked list.
     * @return: head node
     */
    ListNode *deleteDuplicates(ListNode *head) {
        if (head == NULL) {
            return NULL;
        }

        ListNode *node = head;
        while (node-&gt;next != NULL) {
            if (node-&gt;val == node-&gt;next-&gt;val) {
                ListNode *temp = node-&gt;next;
                node-&gt;next = node-&gt;next-&gt;next;
                delete temp;
            } else {
                node = node-&gt;next;
            }
        }

        return head;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) return null;

        ListNode node = head;
        while (node.next != null) {
            if (node.val == node.next.val) {
                node.next = node.next.next;
            } else {
                node = node.next;
            }
        }

        return head;
    }
}
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>首先進行異常處理，判斷head是否為NULL</li>
<li>遍歷鏈表，<code>node-&gt;val == node-&gt;next-&gt;val</code>時，保存<code>node-&gt;next</code>，便於後面釋放記憶體(非C/C++無需手動管理記憶體)</li>
<li>不相等時移動當前節點至下一節點，注意這個步驟必須包含在<code>else</code>中，否則邏輯較為複雜</li>
</ol>
<p><code>while</code> 循環處也可使用<code>node != null &amp;&amp; node-&gt;next != null</code>, 這樣就不用單獨判斷<code>head</code> 是否為空了，但是這樣會降低遍歷的效率，因為需要判斷兩處。</p>
<h3>複雜度分析</h3>
<p>遍歷鏈表一次，時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 使用了一個變數進行遍歷，空間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.jiuzhang.com/solutions/remove-duplicates-from-sorted-list/">Remove Duplicates from Sorted List 參考程序 | 九章</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Remove Duplicates from Sorted List II]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/linked_list/remove_duplicates_from_sorted_list_ii.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/linked_list/remove_duplicates_from_sorted_list_ii.html">
        </link>
        <updated>2019-11-03T15:42:13Z</updated>
        <summary type="html"><![CDATA[<h1>￼Remove Duplicates from Sorted List II</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#c---wrong">C++ - Wrong</a></li>
<li><a href="#錯因分析">錯因分析</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">Remove Duplicates from Sorted List II | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/remove-duplicates-from-sorted-list-ii/">(113) Remove Duplicates from Sorted List II</a></li>
</ul>
<pre><code>Given a sorted linked list, delete all nodes that have duplicate numbers,
leaving only distinct numbers from the original list.

Example
Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.
Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.
</code></pre><h2>題解</h2>
<p>上題為保留重複值節點的一個，這題刪除全部重複節點，看似區別不大，但是考慮到鏈表頭不確定(可能被刪除，也可能保留)，因此若用傳統方式需要較多的if條件語句。這裏介紹一個<strong>處理鏈表頭節點不確定的方法——引入dummy node.</strong></p>
<pre><code>ListNode *dummy = new ListNode(0);
dummy-&gt;next = head;
ListNode *node = dummy;
</code></pre><p>引入新的指標變數<code>dummy</code>，並將其next變數賦值為head，考慮到原來的鏈表頭節點可能被刪除，故應該從dummy處開始處理，這裏複用了head變數。考慮鏈表<code>A-&gt;B-&gt;C</code>，刪除B時，需要處理和考慮的是A和C，將A的next指向C。如果從空間使用效率考慮，可以使用head代替以上的node，含義一樣，node比較好理解點。</p>
<p>與上題不同的是，由於此題引入了新的節點<code>dummy</code>，不可再使用<code>node-&gt;val == node-&gt;next-&gt;val</code>，原因有二：</p>
<ol>
<li>此題需要將值相等的節點全部刪掉，而刪除鏈表的操作與節點前後兩個節點都有關系，故需要涉及三個鏈表節點。且刪除單向鏈表節點時不能刪除當前節點，只能改變當前節點的<code>next</code>指向的節點。</li>
<li>在判斷val是否相等時需先確定<code>node-&gt;next</code>和<code>node-&gt;next-&gt;next</code>均不為空，否則不可對其進行取值。</li>
</ol>
<p>說多了都是淚，先看看我的錯誤實現：</p>
<h3>C++ - Wrong</h3>
<pre><code>/**
 * Definition of ListNode
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;next = NULL;
 *     }
 * }
 */
class Solution{
public:
    /**
     * @param head: The first node of linked list.
     * @return: head node
     */
    ListNode * deleteDuplicates(ListNode *head) {
        if (head == NULL || head-&gt;next == NULL) {
            return NULL;
        }

        ListNode *dummy;
        dummy-&gt;next = head;
        ListNode *node = dummy;

        while (node-&gt;next != NULL &amp;&amp; node-&gt;next-&gt;next != NULL) {
            if (node-&gt;next-&gt;val == node-&gt;next-&gt;next-&gt;val) {
                int val = node-&gt;next-&gt;val;
                while (node-&gt;next != NULL &amp;&amp; val == node-&gt;next-&gt;val) {
                    ListNode *temp = node-&gt;next;
                    node-&gt;next = node-&gt;next-&gt;next;
                    delete temp;
                }
            } else {
                node-&gt;next = node-&gt;next-&gt;next;
            }
        }

        return dummy-&gt;next;
    }
};
</code></pre><h3>錯因分析</h3>
<p>錯在什麼地方？</p>
<ol>
<li>節點dummy的初始化有問題，對class的初始化應該使用<code>new</code></li>
<li>在else語句中<code>node-&gt;next = node-&gt;next-&gt;next;</code>改寫了<code>dummy-next</code>中的內容，返回的<code>dummy-next</code>不再是隊首元素，而是隊尾元素。原因很微妙，應該使用<code>node = node-&gt;next;</code>，node代表節點指標變數，而node-&gt;next代表當前節點所指向的下一節點地址。具體分析可自行在紙上畫圖分析，可對指標和鏈表的理解又加深不少。</li>
</ol>
<p><img src="../../shared-files/images/remove_duplicates_from_sorted_list.jpg" alt="remove_duplicates_from_sorted_list記憶體分析"></p>
<p>圖中上半部分為ListNode的記憶體示意圖，每個框底下為其內存地址。<code>dummy</code>指標本身的地址為ox7fff5d0d2500，其保存著指標值為0x7fbe7bc04c50. <code>head</code>指標本身的地址為ox7fff5d0d2508，其保存著指標值為0x7fbe7bc04c00.</p>
<p>好了，接下來看看正確實現及解析。</p>
<h3>Python</h3>
<pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # @param {ListNode} head
    # @return {ListNode}
    def deleteDuplicates(self, head):
        if head is None:
            return None

        dummy = ListNode(0)
        dummy.next = head
        node = dummy
        while node.next is not None and node.next.next is not None:
            if node.next.val == node.next.next.val:
                val_prev = node.next.val
                while node.next is not None and node.next.val == val_prev:
                    node.next = node.next.next
            else:
                node = node.next

        return dummy.next
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (head == NULL) return NULL;

        ListNode *dummy = new ListNode(0);
        dummy-&gt;next = head;
        ListNode *node = dummy;
        while (node-&gt;next != NULL &amp;&amp; node-&gt;next-&gt;next != NULL) {
            if (node-&gt;next-&gt;val == node-&gt;next-&gt;next-&gt;val) {
                int val_prev = node-&gt;next-&gt;val;
                // remove ListNode node-&gt;next
                while (node-&gt;next != NULL &amp;&amp; val_prev == node-&gt;next-&gt;val) {
                    ListNode *temp = node-&gt;next;
                    node-&gt;next = node-&gt;next-&gt;next;
                    delete temp;
                }
            } else {
                node = node-&gt;next;
            }
        }

        return dummy-&gt;next;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) return null;

        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode node = dummy;
        while(node.next != null &amp;&amp; node.next.next != null) {
            if (node.next.val == node.next.next.val) {
                int val_prev = node.next.val;
                while (node.next != null &amp;&amp; node.next.val == val_prev) {
                    node.next = node.next.next;
                }
            } else {
                node = node.next;
            }
        }

        return dummy.next;
    }
}
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>首先考慮異常情況，head 為 NULL 時返回 NULL</li>
<li>new一個dummy變數，<code>dummy-&gt;next</code>指向原鏈表頭。</li>
<li>使用新變數node並設置其為dummy頭節點，遍歷用。</li>
<li>當前節點和下一節點val相同時先保存當前值，便於while循環終止條件判斷和刪除節點。注意這一段代碼也比較精煉。</li>
<li>最後返回<code>dummy-&gt;next</code>，即題目所要求的頭節點。</li>
</ol>
<p>Python 中也可不使用<code>is not None</code>判斷，但是效率會低一點。</p>
<h3>複雜度分析</h3>
<p>兩個指標(node.next 和 node.next.next)遍歷，時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>2</mn><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 使用了一個 dummy 和中間緩存變數，空間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.jiuzhang.com/solutions/remove-duplicates-from-sorted-list-ii/">Remove Duplicates from Sorted List II | 九章</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>￼Remove Duplicates from Sorted List II</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#c---wrong">C++ - Wrong</a></li>
<li><a href="#錯因分析">錯因分析</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">Remove Duplicates from Sorted List II | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/remove-duplicates-from-sorted-list-ii/">(113) Remove Duplicates from Sorted List II</a></li>
</ul>
<pre><code>Given a sorted linked list, delete all nodes that have duplicate numbers,
leaving only distinct numbers from the original list.

Example
Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.
Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.
</code></pre><h2>題解</h2>
<p>上題為保留重複值節點的一個，這題刪除全部重複節點，看似區別不大，但是考慮到鏈表頭不確定(可能被刪除，也可能保留)，因此若用傳統方式需要較多的if條件語句。這裏介紹一個<strong>處理鏈表頭節點不確定的方法——引入dummy node.</strong></p>
<pre><code>ListNode *dummy = new ListNode(0);
dummy-&gt;next = head;
ListNode *node = dummy;
</code></pre><p>引入新的指標變數<code>dummy</code>，並將其next變數賦值為head，考慮到原來的鏈表頭節點可能被刪除，故應該從dummy處開始處理，這裏複用了head變數。考慮鏈表<code>A-&gt;B-&gt;C</code>，刪除B時，需要處理和考慮的是A和C，將A的next指向C。如果從空間使用效率考慮，可以使用head代替以上的node，含義一樣，node比較好理解點。</p>
<p>與上題不同的是，由於此題引入了新的節點<code>dummy</code>，不可再使用<code>node-&gt;val == node-&gt;next-&gt;val</code>，原因有二：</p>
<ol>
<li>此題需要將值相等的節點全部刪掉，而刪除鏈表的操作與節點前後兩個節點都有關系，故需要涉及三個鏈表節點。且刪除單向鏈表節點時不能刪除當前節點，只能改變當前節點的<code>next</code>指向的節點。</li>
<li>在判斷val是否相等時需先確定<code>node-&gt;next</code>和<code>node-&gt;next-&gt;next</code>均不為空，否則不可對其進行取值。</li>
</ol>
<p>說多了都是淚，先看看我的錯誤實現：</p>
<h3>C++ - Wrong</h3>
<pre><code>/**
 * Definition of ListNode
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;next = NULL;
 *     }
 * }
 */
class Solution{
public:
    /**
     * @param head: The first node of linked list.
     * @return: head node
     */
    ListNode * deleteDuplicates(ListNode *head) {
        if (head == NULL || head-&gt;next == NULL) {
            return NULL;
        }

        ListNode *dummy;
        dummy-&gt;next = head;
        ListNode *node = dummy;

        while (node-&gt;next != NULL &amp;&amp; node-&gt;next-&gt;next != NULL) {
            if (node-&gt;next-&gt;val == node-&gt;next-&gt;next-&gt;val) {
                int val = node-&gt;next-&gt;val;
                while (node-&gt;next != NULL &amp;&amp; val == node-&gt;next-&gt;val) {
                    ListNode *temp = node-&gt;next;
                    node-&gt;next = node-&gt;next-&gt;next;
                    delete temp;
                }
            } else {
                node-&gt;next = node-&gt;next-&gt;next;
            }
        }

        return dummy-&gt;next;
    }
};
</code></pre><h3>錯因分析</h3>
<p>錯在什麼地方？</p>
<ol>
<li>節點dummy的初始化有問題，對class的初始化應該使用<code>new</code></li>
<li>在else語句中<code>node-&gt;next = node-&gt;next-&gt;next;</code>改寫了<code>dummy-next</code>中的內容，返回的<code>dummy-next</code>不再是隊首元素，而是隊尾元素。原因很微妙，應該使用<code>node = node-&gt;next;</code>，node代表節點指標變數，而node-&gt;next代表當前節點所指向的下一節點地址。具體分析可自行在紙上畫圖分析，可對指標和鏈表的理解又加深不少。</li>
</ol>
<p><img src="../../shared-files/images/remove_duplicates_from_sorted_list.jpg" alt="remove_duplicates_from_sorted_list記憶體分析"></p>
<p>圖中上半部分為ListNode的記憶體示意圖，每個框底下為其內存地址。<code>dummy</code>指標本身的地址為ox7fff5d0d2500，其保存著指標值為0x7fbe7bc04c50. <code>head</code>指標本身的地址為ox7fff5d0d2508，其保存著指標值為0x7fbe7bc04c00.</p>
<p>好了，接下來看看正確實現及解析。</p>
<h3>Python</h3>
<pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # @param {ListNode} head
    # @return {ListNode}
    def deleteDuplicates(self, head):
        if head is None:
            return None

        dummy = ListNode(0)
        dummy.next = head
        node = dummy
        while node.next is not None and node.next.next is not None:
            if node.next.val == node.next.next.val:
                val_prev = node.next.val
                while node.next is not None and node.next.val == val_prev:
                    node.next = node.next.next
            else:
                node = node.next

        return dummy.next
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (head == NULL) return NULL;

        ListNode *dummy = new ListNode(0);
        dummy-&gt;next = head;
        ListNode *node = dummy;
        while (node-&gt;next != NULL &amp;&amp; node-&gt;next-&gt;next != NULL) {
            if (node-&gt;next-&gt;val == node-&gt;next-&gt;next-&gt;val) {
                int val_prev = node-&gt;next-&gt;val;
                // remove ListNode node-&gt;next
                while (node-&gt;next != NULL &amp;&amp; val_prev == node-&gt;next-&gt;val) {
                    ListNode *temp = node-&gt;next;
                    node-&gt;next = node-&gt;next-&gt;next;
                    delete temp;
                }
            } else {
                node = node-&gt;next;
            }
        }

        return dummy-&gt;next;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) return null;

        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode node = dummy;
        while(node.next != null &amp;&amp; node.next.next != null) {
            if (node.next.val == node.next.next.val) {
                int val_prev = node.next.val;
                while (node.next != null &amp;&amp; node.next.val == val_prev) {
                    node.next = node.next.next;
                }
            } else {
                node = node.next;
            }
        }

        return dummy.next;
    }
}
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>首先考慮異常情況，head 為 NULL 時返回 NULL</li>
<li>new一個dummy變數，<code>dummy-&gt;next</code>指向原鏈表頭。</li>
<li>使用新變數node並設置其為dummy頭節點，遍歷用。</li>
<li>當前節點和下一節點val相同時先保存當前值，便於while循環終止條件判斷和刪除節點。注意這一段代碼也比較精煉。</li>
<li>最後返回<code>dummy-&gt;next</code>，即題目所要求的頭節點。</li>
</ol>
<p>Python 中也可不使用<code>is not None</code>判斷，但是效率會低一點。</p>
<h3>複雜度分析</h3>
<p>兩個指標(node.next 和 node.next.next)遍歷，時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>2</mn><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 使用了一個 dummy 和中間緩存變數，空間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.jiuzhang.com/solutions/remove-duplicates-from-sorted-list-ii/">Remove Duplicates from Sorted List II | 九章</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linked List Cycle]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/linked_list/linked_list_cycle.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/linked_list/linked_list_cycle.html">
        </link>
        <updated>2019-11-03T15:42:13Z</updated>
        <summary type="html"><![CDATA[<h1>Linked List Cycle</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解---快慢指標">題解 - 快慢指標</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/linked-list-cycle/">Linked List Cycle | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/linked-list-cycle/">(102) Linked List Cycle</a></li>
</ul>
<pre><code>Given a linked list, determine if it has a cycle in it.

Example
Given -21-&gt;10-&gt;4-&gt;5, tail connects to node index 1, return true

Challenge
Follow up:
Can you solve it without using extra space?
</code></pre><h2>題解 - 快慢指標</h2>
<p>對於帶環鏈表的檢測，效率較高且易於實現的一種方式為使用快慢指標。快指標每次走兩步，慢指標每次走一步，如果快慢指標相遇(快慢指標所指內存為同一區域)則有環，否則快指標會一直走到<code>NULL</code>為止退出循環，返回<code>false</code>.</p>
<p>快指標走到<code>NULL</code>退出循環即可確定此鏈表一定無環這個很好理解。那麼帶環的鏈表快慢指標一定會相遇嗎？先來看看下圖。</p>
<p><img src="../../shared-files/images/linked_list_cycle.png" alt="Linked List Cycle"></p>
<p>在有環的情況下，最終快慢指標一定都走在環內，加入第<code>i</code>次遍歷時快指標還需要<code>k</code>步才能追上慢指標，由於快指標比慢指標每次多走一步。那麼每遍歷一次快慢指標間的間距都會減少1，直至最終相遇。故快慢指標相遇一定能確定該鏈表有環。</p>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of ListNode
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;next = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param head: The first node of linked list.
     * @return: True if it has a cycle, or false
     */
    bool hasCycle(ListNode *head) {
        ListNode *fast = head, *slow = head;
        while(fast and fast-&gt;next){
            slow = slow -&gt; next;
            fast = fast -&gt; next -&gt; next;
            if(slow == fast) return true;
        }
        return false;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }

        ListNode slow = head;
        ListNode fast = head;
        while (fast.next != null &amp;&amp; fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {
                return true;
            }
        }
        return false;
    }
}
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>異常處理，將<code>head-&gt;next</code>也考慮在內有助於簡化後面的代碼。</li>
<li>慢指標初始化為<code>head</code>, 快指標初始化為<code>head</code>的下一個節點，這是快慢指標初始化的一種方法，有時會簡化邊界處理，但有時會增加麻煩，比如該題的進階版。</li>
</ol>
<h3>複雜度分析</h3>
<ol>
<li>在無環時，快指標每次走兩步走到尾部節點，遍歷的時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span><span class="mclose">)</span></span></span></span>.</li>
<li>有環時，最壞的時間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 最壞情況下鏈表的頭尾相接，此時快指標恰好在慢指標前一個節點，還需 n 次快慢指標相遇。最好情況和無環相同，尾節點出現環。</li>
</ol>
<p>故總的時間複雜度可近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.jiuzhang.com/solutions/linked-list-cycle/">Linked List Cycle | 九章算法</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Linked List Cycle</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解---快慢指標">題解 - 快慢指標</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/linked-list-cycle/">Linked List Cycle | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/linked-list-cycle/">(102) Linked List Cycle</a></li>
</ul>
<pre><code>Given a linked list, determine if it has a cycle in it.

Example
Given -21-&gt;10-&gt;4-&gt;5, tail connects to node index 1, return true

Challenge
Follow up:
Can you solve it without using extra space?
</code></pre><h2>題解 - 快慢指標</h2>
<p>對於帶環鏈表的檢測，效率較高且易於實現的一種方式為使用快慢指標。快指標每次走兩步，慢指標每次走一步，如果快慢指標相遇(快慢指標所指內存為同一區域)則有環，否則快指標會一直走到<code>NULL</code>為止退出循環，返回<code>false</code>.</p>
<p>快指標走到<code>NULL</code>退出循環即可確定此鏈表一定無環這個很好理解。那麼帶環的鏈表快慢指標一定會相遇嗎？先來看看下圖。</p>
<p><img src="../../shared-files/images/linked_list_cycle.png" alt="Linked List Cycle"></p>
<p>在有環的情況下，最終快慢指標一定都走在環內，加入第<code>i</code>次遍歷時快指標還需要<code>k</code>步才能追上慢指標，由於快指標比慢指標每次多走一步。那麼每遍歷一次快慢指標間的間距都會減少1，直至最終相遇。故快慢指標相遇一定能確定該鏈表有環。</p>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of ListNode
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *     ListNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;next = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param head: The first node of linked list.
     * @return: True if it has a cycle, or false
     */
    bool hasCycle(ListNode *head) {
        ListNode *fast = head, *slow = head;
        while(fast and fast-&gt;next){
            slow = slow -&gt; next;
            fast = fast -&gt; next -&gt; next;
            if(slow == fast) return true;
        }
        return false;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }

        ListNode slow = head;
        ListNode fast = head;
        while (fast.next != null &amp;&amp; fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {
                return true;
            }
        }
        return false;
    }
}
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>異常處理，將<code>head-&gt;next</code>也考慮在內有助於簡化後面的代碼。</li>
<li>慢指標初始化為<code>head</code>, 快指標初始化為<code>head</code>的下一個節點，這是快慢指標初始化的一種方法，有時會簡化邊界處理，但有時會增加麻煩，比如該題的進階版。</li>
</ol>
<h3>複雜度分析</h3>
<ol>
<li>在無環時，快指標每次走兩步走到尾部節點，遍歷的時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span><span class="mclose">)</span></span></span></span>.</li>
<li>有環時，最壞的時間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 最壞情況下鏈表的頭尾相接，此時快指標恰好在慢指標前一個節點，還需 n 次快慢指標相遇。最好情況和無環相同，尾節點出現環。</li>
</ol>
<p>故總的時間複雜度可近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.jiuzhang.com/solutions/linked-list-cycle/">Linked List Cycle | 九章算法</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Reverse Linked List]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/linked_list/reverse_linked_list.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/linked_list/reverse_linked_list.html">
        </link>
        <updated>2019-11-03T15:42:13Z</updated>
        <summary type="html"><![CDATA[<h1>Reverse Linked List</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解1---非遞迴">題解1 - 非遞迴</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#題解2---遞迴">題解2 - 遞迴</a><ul>
<li><a href="#python-1">Python</a></li>
<li><a href="#c-1">C++</a></li>
<li><a href="#java-1">Java</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/reverse-linked-list/">Reverse Linked List | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/reverse-linked-list/">(35) Reverse Linked List</a></li>
</ul>
<pre><code>Reverse a linked list.

Example
For linked list 1-&gt;2-&gt;3, the reversed linked list is 3-&gt;2-&gt;1

Challenge
Reverse it in-place and in one-pass
</code></pre><h2>題解1 - 非遞迴</h2>
<p>聯想到同樣也可能需要翻轉的數組，在數組中由於可以利用下標隨機訪問，翻轉時使用下標即可完成。而在單向鏈表中，僅僅只知道頭節點，而且只能單向往前走，故需另尋出路。分析由<code>1-&gt;2-&gt;3</code>變為<code>3-&gt;2-&gt;1</code>的過程，由於是單向鏈表，故只能由1開始遍曆，1和2最開始的位置是<code>1-&gt;2</code>，最後變為<code>2-&gt;1</code>，故從這裡開始尋找突破口，探討如何交換1和2的節點。</p>
<pre><code>temp = head-&gt;next;
head-&gt;next = prev;
prev = head;
head = temp;
</code></pre><p>要點在於維護兩個指針變量<code>prev</code>和<code>head</code>, 翻轉相鄰兩個節點之前保存下一節點的值，分析如下圖所示：</p>
<p><img src="../../shared-files/images/reverse_linked_list_i.jpg" alt="Reverse Linked List"></p>
<ol>
<li>保存head下一節點</li>
<li>將head所指向的下一節點改為prev</li>
<li>將prev替換為head，波浪式前進</li>
<li>將第一步保存的下一節點替換為head，用於下一次循環</li>
</ol>
<h3>Python</h3>
<pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # @param {ListNode} head
    # @return {ListNode}
    def reverseList(self, head):
        prev = None
        curr = head
        while curr is not None:
            temp = curr.next
            curr.next = prev
            prev = curr
            curr = temp
        # fix head
        head = prev

        return head
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverse(ListNode* head) {
        ListNode *prev = NULL;
        ListNode *curr = head;
        while (curr != NULL) {
            ListNode *temp = curr-&gt;next;
            curr-&gt;next = prev;
            prev = curr;
            curr = temp;
        }
        // fix head
        head = prev;

        return head;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode temp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = temp;
        }
        // fix head
        head = prev;

        return head;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>題解中基本分析完畢，代碼中的prev賦值操作精煉，值得借鑒。</p>
<h3>複雜度分析</h3>
<p>遍歷一次鏈表，時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 使用了輔助變數，空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>題解2 - 遞迴</h2>
<p>遞迴的終止步分三種情況討論：</p>
<ol>
<li>原鏈表為空，直接返回空鏈表即可。</li>
<li>原鏈表僅有一個元素，返回該元素。</li>
<li>原鏈表有兩個以上元素，由於是單向鏈表，故翻轉需要自尾部向首部逆推。</li>
</ol>
<p>由尾部向首部逆推時大致步驟為先翻轉當前節點和下一節點，然後將當前節點指向的下一節點置空(否則會出現死循環和新生成的鏈表尾節點不指向空)，如此遞迴到頭節點為止。新鏈表的頭節點在整個遞迴過程中一直沒有變化，逐層向上返回。</p>
<h3>Python</h3>
<pre><code class="lang-python">&quot;&quot;&quot;
Definition of ListNode

class ListNode(object):

    def __init__(self, val, next=None):
        self.val = val
        self.next = next
&quot;&quot;&quot;
class Solution:
    &quot;&quot;&quot;
    @param head: The first node of the linked list.
    @return: You should return the head of the reversed linked list.
                  Reverse it in-place.
    &quot;&quot;&quot;
    def reverse(self, head):
        # case1: empty list
        if head is None:
            return head
        # case2: only one element list
        if head.next is None:
            return head
        # case3: reverse from the rest after head
        newHead = self.reverse(head.next)
        # reverse between head and head-&gt;next
        head.next.next = head
        # unlink list from the rest
        head.next = None

        return newHead
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of ListNode
 *
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *
 *     ListNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;next = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param head: The first node of linked list.
     * @return: The new head of reversed linked list.
     */
    ListNode *reverse(ListNode *head) {
        // case1: empty list
        if (head == NULL) return head;
        // case2: only one element list
        if (head-&gt;next == NULL) return head;
        // case3: reverse from the rest after head
        ListNode *newHead = reverse(head-&gt;next);
        // reverse between head and head-&gt;next
        head-&gt;next-&gt;next = head;
        // unlink list from the rest
        head-&gt;next = NULL;

        return newHead;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode reverse(ListNode head) {
        // case1: empty list
        if (head == null) return head;
        // case2: only one element list
        if (head.next == null) return head;
        // case3: reverse from the rest after head
        ListNode newHead = reverse(head.next);
        // reverse between head and head-&gt;next
        head.next.next = head;
        // unlink list from the rest
        head.next = null;

        return newHead;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>case1 和 case2 可以合在一起考慮，case3 返回的為新鏈表的頭節點，整個遞迴過程中保持不變。</p>
<h3>複雜度分析</h3>
<p>遞迴嵌套層數為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 空間(不含函數堆疊空間)複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.cnblogs.com/kubixuesheng/p/4394509.html">全面分析再動手的習慣：鏈表的反轉問題（遞迴和非遞迴方式） - 木棉和木槿 - 博客園</a></li>
<li><a href="http://stackoverflow.com/questions/354875/reversing-a-linked-list-in-java-recursively">data structures - Reversing a linked list in Java, recursively - Stack Overflow</a></li>
<li><a href="http://ceeji.net/blog/reserve-linked-list-cpp/">反轉單向鏈表的四種實現（遞迴與非遞迴，C++） | 寧心勉學，慎思篤行</a></li>
<li><a href="https://leetcode.com/discuss/37804/iteratively-and-recursively-java-solution">iteratively and recursively Java Solution - Leetcode Discuss</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Reverse Linked List</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解1---非遞迴">題解1 - 非遞迴</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#題解2---遞迴">題解2 - 遞迴</a><ul>
<li><a href="#python-1">Python</a></li>
<li><a href="#c-1">C++</a></li>
<li><a href="#java-1">Java</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/reverse-linked-list/">Reverse Linked List | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/reverse-linked-list/">(35) Reverse Linked List</a></li>
</ul>
<pre><code>Reverse a linked list.

Example
For linked list 1-&gt;2-&gt;3, the reversed linked list is 3-&gt;2-&gt;1

Challenge
Reverse it in-place and in one-pass
</code></pre><h2>題解1 - 非遞迴</h2>
<p>聯想到同樣也可能需要翻轉的數組，在數組中由於可以利用下標隨機訪問，翻轉時使用下標即可完成。而在單向鏈表中，僅僅只知道頭節點，而且只能單向往前走，故需另尋出路。分析由<code>1-&gt;2-&gt;3</code>變為<code>3-&gt;2-&gt;1</code>的過程，由於是單向鏈表，故只能由1開始遍曆，1和2最開始的位置是<code>1-&gt;2</code>，最後變為<code>2-&gt;1</code>，故從這裡開始尋找突破口，探討如何交換1和2的節點。</p>
<pre><code>temp = head-&gt;next;
head-&gt;next = prev;
prev = head;
head = temp;
</code></pre><p>要點在於維護兩個指針變量<code>prev</code>和<code>head</code>, 翻轉相鄰兩個節點之前保存下一節點的值，分析如下圖所示：</p>
<p><img src="../../shared-files/images/reverse_linked_list_i.jpg" alt="Reverse Linked List"></p>
<ol>
<li>保存head下一節點</li>
<li>將head所指向的下一節點改為prev</li>
<li>將prev替換為head，波浪式前進</li>
<li>將第一步保存的下一節點替換為head，用於下一次循環</li>
</ol>
<h3>Python</h3>
<pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # @param {ListNode} head
    # @return {ListNode}
    def reverseList(self, head):
        prev = None
        curr = head
        while curr is not None:
            temp = curr.next
            curr.next = prev
            prev = curr
            curr = temp
        # fix head
        head = prev

        return head
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverse(ListNode* head) {
        ListNode *prev = NULL;
        ListNode *curr = head;
        while (curr != NULL) {
            ListNode *temp = curr-&gt;next;
            curr-&gt;next = prev;
            prev = curr;
            curr = temp;
        }
        // fix head
        head = prev;

        return head;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode temp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = temp;
        }
        // fix head
        head = prev;

        return head;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>題解中基本分析完畢，代碼中的prev賦值操作精煉，值得借鑒。</p>
<h3>複雜度分析</h3>
<p>遍歷一次鏈表，時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 使用了輔助變數，空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>題解2 - 遞迴</h2>
<p>遞迴的終止步分三種情況討論：</p>
<ol>
<li>原鏈表為空，直接返回空鏈表即可。</li>
<li>原鏈表僅有一個元素，返回該元素。</li>
<li>原鏈表有兩個以上元素，由於是單向鏈表，故翻轉需要自尾部向首部逆推。</li>
</ol>
<p>由尾部向首部逆推時大致步驟為先翻轉當前節點和下一節點，然後將當前節點指向的下一節點置空(否則會出現死循環和新生成的鏈表尾節點不指向空)，如此遞迴到頭節點為止。新鏈表的頭節點在整個遞迴過程中一直沒有變化，逐層向上返回。</p>
<h3>Python</h3>
<pre><code class="lang-python">&quot;&quot;&quot;
Definition of ListNode

class ListNode(object):

    def __init__(self, val, next=None):
        self.val = val
        self.next = next
&quot;&quot;&quot;
class Solution:
    &quot;&quot;&quot;
    @param head: The first node of the linked list.
    @return: You should return the head of the reversed linked list.
                  Reverse it in-place.
    &quot;&quot;&quot;
    def reverse(self, head):
        # case1: empty list
        if head is None:
            return head
        # case2: only one element list
        if head.next is None:
            return head
        # case3: reverse from the rest after head
        newHead = self.reverse(head.next)
        # reverse between head and head-&gt;next
        head.next.next = head
        # unlink list from the rest
        head.next = None

        return newHead
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of ListNode
 *
 * class ListNode {
 * public:
 *     int val;
 *     ListNode *next;
 *
 *     ListNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;next = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param head: The first node of linked list.
     * @return: The new head of reversed linked list.
     */
    ListNode *reverse(ListNode *head) {
        // case1: empty list
        if (head == NULL) return head;
        // case2: only one element list
        if (head-&gt;next == NULL) return head;
        // case3: reverse from the rest after head
        ListNode *newHead = reverse(head-&gt;next);
        // reverse between head and head-&gt;next
        head-&gt;next-&gt;next = head;
        // unlink list from the rest
        head-&gt;next = NULL;

        return newHead;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode reverse(ListNode head) {
        // case1: empty list
        if (head == null) return head;
        // case2: only one element list
        if (head.next == null) return head;
        // case3: reverse from the rest after head
        ListNode newHead = reverse(head.next);
        // reverse between head and head-&gt;next
        head.next.next = head;
        // unlink list from the rest
        head.next = null;

        return newHead;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>case1 和 case2 可以合在一起考慮，case3 返回的為新鏈表的頭節點，整個遞迴過程中保持不變。</p>
<h3>複雜度分析</h3>
<p>遞迴嵌套層數為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 空間(不含函數堆疊空間)複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.cnblogs.com/kubixuesheng/p/4394509.html">全面分析再動手的習慣：鏈表的反轉問題（遞迴和非遞迴方式） - 木棉和木槿 - 博客園</a></li>
<li><a href="http://stackoverflow.com/questions/354875/reversing-a-linked-list-in-java-recursively">data structures - Reversing a linked list in Java, recursively - Stack Overflow</a></li>
<li><a href="http://ceeji.net/blog/reserve-linked-list-cpp/">反轉單向鏈表的四種實現（遞迴與非遞迴，C++） | 寧心勉學，慎思篤行</a></li>
<li><a href="https://leetcode.com/discuss/37804/iteratively-and-recursively-java-solution">iteratively and recursively Java Solution - Leetcode Discuss</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Merge Two Sorted Lists]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/linked_list/merge_two_sorted_lists.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/linked_list/merge_two_sorted_lists.html">
        </link>
        <updated>2019-11-03T15:42:14Z</updated>
        <summary type="html"><![CDATA[<h1>Merge Two Sorted Lists</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/merge-two-sorted-lists/">(165) Merge Two Sorted Lists</a></li>
<li>leetcode: <a href="https://leetcode.com/problems/merge-two-sorted-lists/">Merge Two Sorted Lists | LeetCode OJ</a></li>
</ul>
<pre><code>Merge two sorted linked lists and return it as a new list.
The new list should be made by splicing together the nodes of the first two lists.

Example
Given 1-&gt;3-&gt;8-&gt;11-&gt;15-&gt;null, 2-&gt;null , return 1-&gt;2-&gt;3-&gt;8-&gt;11-&gt;15-&gt;null
</code></pre><h2>題解</h2>
<p>此題為兩個鏈表的合併，合併後的表頭節點不一定，故應聯想到使用<code>dummy</code>節點。鏈表節點的插入主要涉及節點<code>next</code>指標值的改變，兩個鏈表的合併操作則涉及到兩個節點的<code>next</code>值變化，若每次合併一個節點都要改變兩個節點<code>next</code>的值且要對<code>NULL</code>指標做異常處理，勢必會異常麻煩。嗯，第一次做這題時我就是這麼想的... 下面看看相對較好的思路。</p>
<p>首先<code>dummy</code>節點還是必須要用到，除了<code>dummy</code>節點外還引入一個<code>lastNode</code>節點充當下一次合併時的頭節點。在<code>l1</code>或者<code>l2</code>的某一個節點為空指標<code>NULL</code>時，退出<code>while</code>循環，並將非空鏈表的頭部鏈接到<code>lastNode-&gt;next</code>中。</p>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode *dummy = new ListNode(0);
        ListNode *lastNode = dummy;
        while ((NULL != l1) &amp;&amp; (NULL != l2)) {
            if (l1-&gt;val &lt; l2-&gt;val) {
                lastNode-&gt;next = l1;
                l1 = l1-&gt;next;
            } else {
                lastNode-&gt;next = l2;
                l2 = l2-&gt;next;
            }

            lastNode = lastNode-&gt;next;
        }

        // do not forget this line!
        lastNode-&gt;next =  (NULL != l1) ? l1 : l2;

        return dummy-&gt;next;
    }
};
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>異常處理，包含在<code>dummy-&gt;next</code>中。</li>
<li>引入<code>dummy</code>和<code>lastNode</code>節點，此時<code>lastNode</code>指向的節點為<code>dummy</code></li>
<li>對非空l1,l2循環處理，將l1/l2的較小者鏈接到<code>lastNode-&gt;next</code>，往後遞推<code>lastNode</code></li>
<li>最後處理l1/l2中某一鏈表為空退出while循環，將非空鏈表頭鏈接到<code>lastNode-&gt;next</code></li>
<li>返回<code>dummy-&gt;next</code>，即最終的首指標</li>
</ol>
<p>注意<code>lastNode</code>的遞推並不影響<code>dummy-&gt;next</code>的值，因為<code>lastNode</code>和<code>dummy</code>是兩個不同的指標變量。</p>
<blockquote>
<p><strong>Note</strong> 鏈表的合併為常用操作，務必非常熟練，以上的模板非常精煉，有兩個地方需要記牢。1. 循環結束條件中為條件與操作；2. 最後處理<code>lastNode-&gt;next</code>指標的值。</p>
</blockquote>
<h3>複雜度分析</h3>
<p>最好情況下，一個鏈表為空，時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>. 最壞情況下，<code>lastNode</code>遍曆兩個鏈表中的每一個節點，時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mn>1</mn><mo>+</mo><mi>l</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(l1+l2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathrm">1</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathrm">2</span><span class="mclose">)</span></span></span></span>. 空間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.jiuzhang.com/solutions/merge-two-sorted-lists/">Merge Two Sorted Lists | 九章算法</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Merge Two Sorted Lists</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/merge-two-sorted-lists/">(165) Merge Two Sorted Lists</a></li>
<li>leetcode: <a href="https://leetcode.com/problems/merge-two-sorted-lists/">Merge Two Sorted Lists | LeetCode OJ</a></li>
</ul>
<pre><code>Merge two sorted linked lists and return it as a new list.
The new list should be made by splicing together the nodes of the first two lists.

Example
Given 1-&gt;3-&gt;8-&gt;11-&gt;15-&gt;null, 2-&gt;null , return 1-&gt;2-&gt;3-&gt;8-&gt;11-&gt;15-&gt;null
</code></pre><h2>題解</h2>
<p>此題為兩個鏈表的合併，合併後的表頭節點不一定，故應聯想到使用<code>dummy</code>節點。鏈表節點的插入主要涉及節點<code>next</code>指標值的改變，兩個鏈表的合併操作則涉及到兩個節點的<code>next</code>值變化，若每次合併一個節點都要改變兩個節點<code>next</code>的值且要對<code>NULL</code>指標做異常處理，勢必會異常麻煩。嗯，第一次做這題時我就是這麼想的... 下面看看相對較好的思路。</p>
<p>首先<code>dummy</code>節點還是必須要用到，除了<code>dummy</code>節點外還引入一個<code>lastNode</code>節點充當下一次合併時的頭節點。在<code>l1</code>或者<code>l2</code>的某一個節點為空指標<code>NULL</code>時，退出<code>while</code>循環，並將非空鏈表的頭部鏈接到<code>lastNode-&gt;next</code>中。</p>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode *dummy = new ListNode(0);
        ListNode *lastNode = dummy;
        while ((NULL != l1) &amp;&amp; (NULL != l2)) {
            if (l1-&gt;val &lt; l2-&gt;val) {
                lastNode-&gt;next = l1;
                l1 = l1-&gt;next;
            } else {
                lastNode-&gt;next = l2;
                l2 = l2-&gt;next;
            }

            lastNode = lastNode-&gt;next;
        }

        // do not forget this line!
        lastNode-&gt;next =  (NULL != l1) ? l1 : l2;

        return dummy-&gt;next;
    }
};
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>異常處理，包含在<code>dummy-&gt;next</code>中。</li>
<li>引入<code>dummy</code>和<code>lastNode</code>節點，此時<code>lastNode</code>指向的節點為<code>dummy</code></li>
<li>對非空l1,l2循環處理，將l1/l2的較小者鏈接到<code>lastNode-&gt;next</code>，往後遞推<code>lastNode</code></li>
<li>最後處理l1/l2中某一鏈表為空退出while循環，將非空鏈表頭鏈接到<code>lastNode-&gt;next</code></li>
<li>返回<code>dummy-&gt;next</code>，即最終的首指標</li>
</ol>
<p>注意<code>lastNode</code>的遞推並不影響<code>dummy-&gt;next</code>的值，因為<code>lastNode</code>和<code>dummy</code>是兩個不同的指標變量。</p>
<blockquote>
<p><strong>Note</strong> 鏈表的合併為常用操作，務必非常熟練，以上的模板非常精煉，有兩個地方需要記牢。1. 循環結束條件中為條件與操作；2. 最後處理<code>lastNode-&gt;next</code>指標的值。</p>
</blockquote>
<h3>複雜度分析</h3>
<p>最好情況下，一個鏈表為空，時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>. 最壞情況下，<code>lastNode</code>遍曆兩個鏈表中的每一個節點，時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mn>1</mn><mo>+</mo><mi>l</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(l1+l2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathrm">1</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathrm">2</span><span class="mclose">)</span></span></span></span>. 空間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.jiuzhang.com/solutions/merge-two-sorted-lists/">Merge Two Sorted Lists | 九章算法</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Remove Linked List Elements]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/linked_list/remove_linked_list_elements.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/linked_list/remove_linked_list_elements.html">
        </link>
        <updated>2019-11-03T15:42:14Z</updated>
        <summary type="html"><![CDATA[<h1>Remove Linked List Elements</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#example">Example</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#題解">題解</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/remove-linked-list-elements/">Remove Linked List Elements | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/remove-linked-list-elements/">(452) Remove Linked List Elements</a></li>
</ul>
<h3>Problem Statement</h3>
<p>Remove all elements from a linked list of integers that have value <code>val</code>.</p>
<h4>Example</h4>
<p>Given <code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;5-&gt;3</code>, val = 3, you should return the list as
<code>1-&gt;2-&gt;4-&gt;5</code></p>
<h2>題解</h2>
<p>刪除鏈表中指定值，找到其前一個節點即可，將 next 指向下一個節點即可。</p>
<h3>Python</h3>
<pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def removeElements(self, head, val):
        &quot;&quot;&quot;
        :type head: ListNode
        :type val: int
        :rtype: ListNode
        &quot;&quot;&quot;
        dummy = ListNode(0)
        dummy.next = head
        curr = dummy
        while curr.next is not None:
            if curr.next.val == val:
                curr.next = curr.next.next
            else:
                curr = curr.next

        return dummy.next
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    /**
     * @param head a ListNode
     * @param val an integer
     * @return a ListNode
     */
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode curr = dummy;
        while (curr.next != null) {
            if (curr.next.val == val) {
                curr.next = curr.next.next;
            } else {
                curr = curr.next;
            }
        }

        return dummy.next;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>while 循環中使用<code>curr.next</code>較爲方便，if 語句中比較時也使用<code>curr.next.val</code>也比較簡潔，如果使用<code>curr</code>會比較難處理。</p>
<h3>複雜度分析</h3>
<p>略</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Remove Linked List Elements</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#example">Example</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#題解">題解</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/remove-linked-list-elements/">Remove Linked List Elements | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/remove-linked-list-elements/">(452) Remove Linked List Elements</a></li>
</ul>
<h3>Problem Statement</h3>
<p>Remove all elements from a linked list of integers that have value <code>val</code>.</p>
<h4>Example</h4>
<p>Given <code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;5-&gt;3</code>, val = 3, you should return the list as
<code>1-&gt;2-&gt;4-&gt;5</code></p>
<h2>題解</h2>
<p>刪除鏈表中指定值，找到其前一個節點即可，將 next 指向下一個節點即可。</p>
<h3>Python</h3>
<pre><code class="lang-python"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def removeElements(self, head, val):
        &quot;&quot;&quot;
        :type head: ListNode
        :type val: int
        :rtype: ListNode
        &quot;&quot;&quot;
        dummy = ListNode(0)
        dummy.next = head
        curr = dummy
        while curr.next is not None:
            if curr.next.val == val:
                curr.next = curr.next.next
            else:
                curr = curr.next

        return dummy.next
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    /**
     * @param head a ListNode
     * @param val an integer
     * @return a ListNode
     */
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode curr = dummy;
        while (curr.next != null) {
            if (curr.next.val == val) {
                curr.next = curr.next.next;
            } else {
                curr = curr.next;
            }
        }

        return dummy.next;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>while 循環中使用<code>curr.next</code>較爲方便，if 語句中比較時也使用<code>curr.next.val</code>也比較簡潔，如果使用<code>curr</code>會比較難處理。</p>
<h3>複雜度分析</h3>
<p>略</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Binary Tree]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/binary_tree/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/binary_tree/">
        </link>
        <updated>2019-11-03T15:42:14Z</updated>
        <summary type="html"><![CDATA[<p>Maximum Depth of Binary Tree# Binary Tree - 二元樹</p>
<p>二元樹的基本概念在 <a href="http://algorithm.yuanbin.zh-hans/basics_data_structure/binary_tree.html">Binary Tree | Algorithm</a> 中有簡要的介紹，這裏就二元樹的一些應用做一些實戰演練。</p>
<p>二元樹的遍歷大致可分為前序、中序、後序三種方法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Maximum Depth of Binary Tree# Binary Tree - 二元樹</p>
<p>二元樹的基本概念在 <a href="http://algorithm.yuanbin.zh-hans/basics_data_structure/binary_tree.html">Binary Tree | Algorithm</a> 中有簡要的介紹，這裏就二元樹的一些應用做一些實戰演練。</p>
<p>二元樹的遍歷大致可分為前序、中序、後序三種方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Binary Tree Preorder Traversal]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/binary_tree/binary_tree_preorder_traversal.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/binary_tree/binary_tree_preorder_traversal.html">
        </link>
        <updated>2019-11-03T15:42:14Z</updated>
        <summary type="html"><![CDATA[<h1>Binary Tree Preorder Traversal</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解1---遞迴">題解1 - 遞迴</a><ul>
<li><a href="#python---divide-and-conquer">Python - Divide and Conquer</a></li>
<li><a href="#c---divide-and-conquer">C++ - Divide and Conquer</a></li>
<li><a href="#c---traversal">C++ - Traversal</a></li>
<li><a href="#java---divide-and-conquer">Java - Divide and Conquer</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#題解2---迭代">題解2 - 迭代</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/binary-tree-preorder-traversal/">Binary Tree Preorder Traversal | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/binary-tree-preorder-traversal/">(66) Binary Tree Preorder Traversal</a></li>
</ul>
<pre><code>Given a binary tree, return the preorder traversal of its nodes&#39; values.

Note
Given binary tree {1,#,2,3},

   1
    \
     2
    /
   3

return [1,2,3].

Example
Challenge
Can you do it without recursion?
</code></pre><h2>題解1 - 遞迴</h2>
<p><strong>面試時不推薦遞迴這種做法。</strong></p>
<p>遞迴版很好理解，首先判斷當前節點(根節點)是否為<code>null</code>，是則返回空vector，否則先返回當前節點的值，然後對當前節點的左節點遞迴，最後對當前節點的右節點遞迴。遞迴時對返回結果的處理方式不同可進一步細分為遍歷和分治兩種方法。</p>
<p>譯註：也不是完全不能這麼做，不過以二元樹的遍歷來說，遞迴方法太容易實現，面試官很可能進一步要求迭代的方法，並且有可能會問遞迴的缺點(連續呼叫函數導致stack的overflow問題)，不過如果遍歷並不是題幹而只是解決方法的步驟，用簡單的迭代方式實現有時亦無不可且可以減少錯誤，因此務必要和面試官充分溝通，另即使迭代寫不出來只寫出遞迴版本也要好過完全寫不出東西。</p>
<h3>Python - Divide and Conquer</h3>
<pre><code class="lang-python">&quot;&quot;&quot;
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        this.val = val
        this.left, this.right = None, None
&quot;&quot;&quot;


class Solution:
    &quot;&quot;&quot;
    @param root: The root of binary tree.
    @return: Preorder in ArrayList which contains node values.
    &quot;&quot;&quot;
    def preorderTraversal(self, root):
        if root == None:
            return []
        return [root.val] + self.preorderTraversal(root.left) \
                          + self.preorderTraversal(root.right)
</code></pre>
<h3>C++ - Divide and Conquer</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: The root of binary tree.
     * @return: Preorder in vector which contains node values.
     */
    vector&lt;int&gt; preorderTraversal(TreeNode *root) {
        vector&lt;int&gt; result;
        if (root != NULL) {
            // Divide (分)
            vector&lt;int&gt; left = preorderTraversal(root-&gt;left);
            vector&lt;int&gt; right = preorderTraversal(root-&gt;right);
            // Merge
            result.push_back(root-&gt;val);
            result.insert(result.end(), left.begin(), left.end());
            result.insert(result.end(), right.begin(), right.end());
        }

        return result;
    }
};
</code></pre>
<h3>C++ - Traversal</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: The root of binary tree.
     * @return: Preorder in vector which contains node values.
     */
    vector&lt;int&gt; preorderTraversal(TreeNode *root) {
        vector&lt;int&gt; result;
        traverse(root, result);

        return result;
    }

private:
    void traverse(TreeNode *root, vector&lt;int&gt; &amp;ret) {
        if (root != NULL) {
            ret.push_back(root-&gt;val);
            traverse(root-&gt;left, ret);
            traverse(root-&gt;right, ret);
        }
    }
};
</code></pre>
<h3>Java - Divide and Conquer</h3>
<pre><code class="lang-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        if (root != null) {
            // Divide
            List&lt;Integer&gt; left = preorderTraversal(root.left);
            List&lt;Integer&gt; right = preorderTraversal(root.right);
            // Merge
            result.add(root.val);
            result.addAll(left);
            result.addAll(right);
        }

        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>使用遍歷的方法保存遞迴返回結果需要使用輔助遞迴函數<code>traverse</code>，將結果作為參數傳入遞迴函數中，傳值時注意應使用<code>vector</code>的引用。
分治方法首先分開計算各結果，最後合並到最終結果中。
C++ 中由於是使用vector, 將新的vector插入另一vector不能再使用push_back, 而應該使用insert。
Java 中使用<code>addAll</code>方法.</p>
<h3>複雜度分析</h3>
<p>遍歷樹中節點，時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 未使用額外空間(不包括呼叫函數的stack開銷)。</p>
<h2>題解2 - 迭代</h2>
<p>迭代時需要利用堆疊來保存遍歷到的節點，紙上畫圖分析後發現應首先進行出堆疊拋出當前節點，保存當前節點的值，隨後將右、左節點分別進入堆疊(注意進入堆疊順序，先右後左)，迭代到其為葉子節點(NULL)為止。</p>
<h3>Python</h3>
<pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    # @param {TreeNode} root
    # @return {integer[]}
    def preorderTraversal(self, root):
        if root is None:
            return []

        result = []
        s = []
        s.append(root)
        while s:
            root = s.pop()
            result.append(root.val)
            if root.right is not None:
                s.append(root.right)
            if root.left is not None:
                s.append(root.left)

        return result
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: The root of binary tree.
     * @return: Preorder in vector which contains node values.
     */
    vector&lt;int&gt; preorderTraversal(TreeNode *root) {
        vector&lt;int&gt; result;
        if (root == NULL) return result;

        stack&lt;TreeNode *&gt; s;
        s.push(root);
        while (!s.empty()) {
            TreeNode *node = s.top();
            s.pop();
            result.push_back(node-&gt;val);
            if (node-&gt;right != NULL) {
                s.push(node-&gt;right);
            }
            if (node-&gt;left != NULL) {
                s.push(node-&gt;left);
            }
        }

        return result;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        if (root == null) return result;

        Stack&lt;TreeNode&gt; s = new Stack&lt;TreeNode&gt;();
        s.push(root);
        while (!s.empty()) {
            TreeNode node = s.pop();
            result.add(node.val);
            if (node.right != null) s.push(node.right);
            if (node.left != null) s.push(node.left);
        }

        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>對root進行異常處理</li>
<li>將root壓入堆疊</li>
<li>循環終止條件為堆疊s為空，所有元素均已處理完</li>
<li>訪問當前堆疊頂元素(首先取出堆疊頂元素，隨後pop掉堆疊頂元素)並存入最終結果</li>
<li>將右、左節點分別壓入堆疊內，以便取元素時為先左後右。</li>
<li>返回最終結果</li>
</ol>
<p>其中步驟4,5,6為迭代的核心，對應前序遍歷「根左右」。</p>
<p>所以說到底，<strong>使用迭代，只不過是另外一種形式的遞迴。</strong>使用遞迴的思想去理解遍歷問題會容易理解許多。</p>
<h3>複雜度分析</h3>
<p>使用輔助堆疊，最壞情況下堆疊空間與節點數相等，空間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 對每個節點遍歷一次，時間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Binary Tree Preorder Traversal</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解1---遞迴">題解1 - 遞迴</a><ul>
<li><a href="#python---divide-and-conquer">Python - Divide and Conquer</a></li>
<li><a href="#c---divide-and-conquer">C++ - Divide and Conquer</a></li>
<li><a href="#c---traversal">C++ - Traversal</a></li>
<li><a href="#java---divide-and-conquer">Java - Divide and Conquer</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#題解2---迭代">題解2 - 迭代</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/binary-tree-preorder-traversal/">Binary Tree Preorder Traversal | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/binary-tree-preorder-traversal/">(66) Binary Tree Preorder Traversal</a></li>
</ul>
<pre><code>Given a binary tree, return the preorder traversal of its nodes&#39; values.

Note
Given binary tree {1,#,2,3},

   1
    \
     2
    /
   3

return [1,2,3].

Example
Challenge
Can you do it without recursion?
</code></pre><h2>題解1 - 遞迴</h2>
<p><strong>面試時不推薦遞迴這種做法。</strong></p>
<p>遞迴版很好理解，首先判斷當前節點(根節點)是否為<code>null</code>，是則返回空vector，否則先返回當前節點的值，然後對當前節點的左節點遞迴，最後對當前節點的右節點遞迴。遞迴時對返回結果的處理方式不同可進一步細分為遍歷和分治兩種方法。</p>
<p>譯註：也不是完全不能這麼做，不過以二元樹的遍歷來說，遞迴方法太容易實現，面試官很可能進一步要求迭代的方法，並且有可能會問遞迴的缺點(連續呼叫函數導致stack的overflow問題)，不過如果遍歷並不是題幹而只是解決方法的步驟，用簡單的迭代方式實現有時亦無不可且可以減少錯誤，因此務必要和面試官充分溝通，另即使迭代寫不出來只寫出遞迴版本也要好過完全寫不出東西。</p>
<h3>Python - Divide and Conquer</h3>
<pre><code class="lang-python">&quot;&quot;&quot;
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        this.val = val
        this.left, this.right = None, None
&quot;&quot;&quot;


class Solution:
    &quot;&quot;&quot;
    @param root: The root of binary tree.
    @return: Preorder in ArrayList which contains node values.
    &quot;&quot;&quot;
    def preorderTraversal(self, root):
        if root == None:
            return []
        return [root.val] + self.preorderTraversal(root.left) \
                          + self.preorderTraversal(root.right)
</code></pre>
<h3>C++ - Divide and Conquer</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: The root of binary tree.
     * @return: Preorder in vector which contains node values.
     */
    vector&lt;int&gt; preorderTraversal(TreeNode *root) {
        vector&lt;int&gt; result;
        if (root != NULL) {
            // Divide (分)
            vector&lt;int&gt; left = preorderTraversal(root-&gt;left);
            vector&lt;int&gt; right = preorderTraversal(root-&gt;right);
            // Merge
            result.push_back(root-&gt;val);
            result.insert(result.end(), left.begin(), left.end());
            result.insert(result.end(), right.begin(), right.end());
        }

        return result;
    }
};
</code></pre>
<h3>C++ - Traversal</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: The root of binary tree.
     * @return: Preorder in vector which contains node values.
     */
    vector&lt;int&gt; preorderTraversal(TreeNode *root) {
        vector&lt;int&gt; result;
        traverse(root, result);

        return result;
    }

private:
    void traverse(TreeNode *root, vector&lt;int&gt; &amp;ret) {
        if (root != NULL) {
            ret.push_back(root-&gt;val);
            traverse(root-&gt;left, ret);
            traverse(root-&gt;right, ret);
        }
    }
};
</code></pre>
<h3>Java - Divide and Conquer</h3>
<pre><code class="lang-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        if (root != null) {
            // Divide
            List&lt;Integer&gt; left = preorderTraversal(root.left);
            List&lt;Integer&gt; right = preorderTraversal(root.right);
            // Merge
            result.add(root.val);
            result.addAll(left);
            result.addAll(right);
        }

        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>使用遍歷的方法保存遞迴返回結果需要使用輔助遞迴函數<code>traverse</code>，將結果作為參數傳入遞迴函數中，傳值時注意應使用<code>vector</code>的引用。
分治方法首先分開計算各結果，最後合並到最終結果中。
C++ 中由於是使用vector, 將新的vector插入另一vector不能再使用push_back, 而應該使用insert。
Java 中使用<code>addAll</code>方法.</p>
<h3>複雜度分析</h3>
<p>遍歷樹中節點，時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 未使用額外空間(不包括呼叫函數的stack開銷)。</p>
<h2>題解2 - 迭代</h2>
<p>迭代時需要利用堆疊來保存遍歷到的節點，紙上畫圖分析後發現應首先進行出堆疊拋出當前節點，保存當前節點的值，隨後將右、左節點分別進入堆疊(注意進入堆疊順序，先右後左)，迭代到其為葉子節點(NULL)為止。</p>
<h3>Python</h3>
<pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    # @param {TreeNode} root
    # @return {integer[]}
    def preorderTraversal(self, root):
        if root is None:
            return []

        result = []
        s = []
        s.append(root)
        while s:
            root = s.pop()
            result.append(root.val)
            if root.right is not None:
                s.append(root.right)
            if root.left is not None:
                s.append(root.left)

        return result
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: The root of binary tree.
     * @return: Preorder in vector which contains node values.
     */
    vector&lt;int&gt; preorderTraversal(TreeNode *root) {
        vector&lt;int&gt; result;
        if (root == NULL) return result;

        stack&lt;TreeNode *&gt; s;
        s.push(root);
        while (!s.empty()) {
            TreeNode *node = s.top();
            s.pop();
            result.push_back(node-&gt;val);
            if (node-&gt;right != NULL) {
                s.push(node-&gt;right);
            }
            if (node-&gt;left != NULL) {
                s.push(node-&gt;left);
            }
        }

        return result;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        if (root == null) return result;

        Stack&lt;TreeNode&gt; s = new Stack&lt;TreeNode&gt;();
        s.push(root);
        while (!s.empty()) {
            TreeNode node = s.pop();
            result.add(node.val);
            if (node.right != null) s.push(node.right);
            if (node.left != null) s.push(node.left);
        }

        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>對root進行異常處理</li>
<li>將root壓入堆疊</li>
<li>循環終止條件為堆疊s為空，所有元素均已處理完</li>
<li>訪問當前堆疊頂元素(首先取出堆疊頂元素，隨後pop掉堆疊頂元素)並存入最終結果</li>
<li>將右、左節點分別壓入堆疊內，以便取元素時為先左後右。</li>
<li>返回最終結果</li>
</ol>
<p>其中步驟4,5,6為迭代的核心，對應前序遍歷「根左右」。</p>
<p>所以說到底，<strong>使用迭代，只不過是另外一種形式的遞迴。</strong>使用遞迴的思想去理解遍歷問題會容易理解許多。</p>
<h3>複雜度分析</h3>
<p>使用輔助堆疊，最壞情況下堆疊空間與節點數相等，空間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 對每個節點遍歷一次，時間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Binary Tree Inorder Traversal]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/binary_tree/binary_tree_inorder_traversal.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/binary_tree/binary_tree_inorder_traversal.html">
        </link>
        <updated>2019-11-03T15:42:14Z</updated>
        <summary type="html"><![CDATA[<h1>Binary Tree Inorder Traversal</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#example">Example</a></li>
<li><a href="#challenge">Challenge</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#題解1---遞迴版">題解1 - 遞迴版</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#python---with-helper">Python - with helper</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#題解2----迭代版">題解2 - 迭代版</a><ul>
<li><a href="#python-1">Python</a></li>
<li><a href="#c-1">C++</a></li>
<li><a href="#java-1">Java</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">Binary Tree Inorder Traversal | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/binary-tree-inorder-traversal/">(67) Binary Tree Inorder Traversal</a></li>
</ul>
<h3>Problem Statement</h3>
<p>Given a binary tree, return the <em>inorder</em> traversal of its nodes&#39; values.</p>
<h4>Example</h4>
<p>Given binary tree <code>{1,#,2,3}</code>,</p>
<pre><code>   1
    \
     2
    /
   3
</code></pre><p>return <code>[1,3,2]</code>.</p>
<h4>Challenge</h4>
<p>Can you do it without recursion?</p>
<h2>題解1 - 遞迴版</h2>
<p>中序遍歷的訪問順序爲『先左再根後右』，遞迴版最好理解，遞迴調用時注意返回值和遞迴左右子樹的順序即可。</p>
<h3>Python</h3>
<pre><code class="lang-python">&quot;&quot;&quot;
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        this.val = val
        this.left, this.right = None, None
&quot;&quot;&quot;


class Solution:
    &quot;&quot;&quot;
    @param root: The root of binary tree.
    @return: Inorder in ArrayList which contains node values.
    &quot;&quot;&quot;
    def inorderTraversal(self, root):
        if root is None:
            return []
        else:
            return [root.val] + self.inorderTraversal(root.left) \
                              + self.inorderTraversal(root.right)
</code></pre>
<h3>Python - with helper</h3>
<pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    # @param {TreeNode} root
    # @return {integer[]}
    def inorderTraversal(self, root):
        result = []
        self.helper(root, result)
        return result

    def helper(self, root, ret):
        if root is not None:
            self.helper(root.left, ret)
            ret.append(root.val)
            self.helper(root.right, ret)
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        helper(root, result);
        return result;
    }

private:
    void helper(TreeNode *root, vector&lt;int&gt; &amp;ret) {
        if (root != NULL) {
            helper(root-&gt;left, ret);
            ret.push_back(root-&gt;val);
            helper(root-&gt;right, ret);
        }
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        helper(root, result);
        return result;
    }

    private void helper(TreeNode root, List&lt;Integer&gt; ret) {
        if (root != null) {
            helper(root.left, ret);
            ret.add(root.val);
            helper(root.right, ret);
        }
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>Python 這種動態語言在寫遞迴時返回結果好處理點，無需聲明類型。通用的方法爲在遞迴函數入口參數中傳入返回結果，
也可使用分治的方法替代輔助函數。</p>
<h3>複雜度分析</h3>
<p>樹中每個節點都需要被訪問常數次，時間複雜度近似爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 未使用額外輔助空間。</p>
<h2>題解2  - 迭代版</h2>
<p>使用輔助 stack 改寫遞迴程序，中序遍歷沒有前序遍歷好寫，其中之一就在於出入 stack 的順序和限制規則。我們採用「左根右」的訪問順序可知主要由如下四步構成。</p>
<ol>
<li>首先需要一直對左子樹迭代並將非空節點壓入 stack </li>
<li>節點指針爲空後不再壓入 stack </li>
<li>當前節點爲空時進行出 stack 操作，並訪問 stack 頂節點</li>
<li>將當前指針p用其右子節點替代</li>
</ol>
<p>步驟2,3,4對應「左根右」的遍歷結構，只是此時的步驟2取的左值爲空。</p>
<h3>Python</h3>
<pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    # @param {TreeNode} root
    # @return {integer[]}
    def inorderTraversal(self, root):
        result = []
        s = []
        while root is not None or s:
            if root is not None:
                s.append(root)
                root = root.left
            else:
                root = s.pop()
                result.append(root.val)
                root = root.right

        return result
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */
class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: Inorder in vector which contains node values.
     */
public:
    vector&lt;int&gt; inorderTraversal(TreeNode *root) {
        vector&lt;int&gt; result;
        stack&lt;TreeNode *&gt; s;

        while (!s.empty() || NULL != root) {
            if (root != NULL) {
                s.push(root);
                root = root-&gt;left;
            } else {
                root = s.top();
                s.pop();
                result.push_back(root-&gt;val);
                root = root-&gt;right;
            }
        }

        return result;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        if (root == null) return result;

        Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;TreeNode&gt;();
        while (root != null || (!stack.isEmpty())) {
            if (root != null) {
                stack.push(root);
                root = root.left;
            } else {
                root = stack.pop();
                result.add(root.val);
                root = root.right;
            }
        }

        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>使用 stack 的思想模擬遞迴，注意迭代的演進和邊界條件即可。</p>
<h3>複雜度分析</h3>
<p>最壞情況下 stack 保存所有節點，空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
]]></summary>
        <content type="html"><![CDATA[<h1>Binary Tree Inorder Traversal</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#example">Example</a></li>
<li><a href="#challenge">Challenge</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#題解1---遞迴版">題解1 - 遞迴版</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#python---with-helper">Python - with helper</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#題解2----迭代版">題解2 - 迭代版</a><ul>
<li><a href="#python-1">Python</a></li>
<li><a href="#c-1">C++</a></li>
<li><a href="#java-1">Java</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">Binary Tree Inorder Traversal | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/binary-tree-inorder-traversal/">(67) Binary Tree Inorder Traversal</a></li>
</ul>
<h3>Problem Statement</h3>
<p>Given a binary tree, return the <em>inorder</em> traversal of its nodes&#39; values.</p>
<h4>Example</h4>
<p>Given binary tree <code>{1,#,2,3}</code>,</p>
<pre><code>   1
    \
     2
    /
   3
</code></pre><p>return <code>[1,3,2]</code>.</p>
<h4>Challenge</h4>
<p>Can you do it without recursion?</p>
<h2>題解1 - 遞迴版</h2>
<p>中序遍歷的訪問順序爲『先左再根後右』，遞迴版最好理解，遞迴調用時注意返回值和遞迴左右子樹的順序即可。</p>
<h3>Python</h3>
<pre><code class="lang-python">&quot;&quot;&quot;
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        this.val = val
        this.left, this.right = None, None
&quot;&quot;&quot;


class Solution:
    &quot;&quot;&quot;
    @param root: The root of binary tree.
    @return: Inorder in ArrayList which contains node values.
    &quot;&quot;&quot;
    def inorderTraversal(self, root):
        if root is None:
            return []
        else:
            return [root.val] + self.inorderTraversal(root.left) \
                              + self.inorderTraversal(root.right)
</code></pre>
<h3>Python - with helper</h3>
<pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    # @param {TreeNode} root
    # @return {integer[]}
    def inorderTraversal(self, root):
        result = []
        self.helper(root, result)
        return result

    def helper(self, root, ret):
        if root is not None:
            self.helper(root.left, ret)
            ret.append(root.val)
            self.helper(root.right, ret)
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        helper(root, result);
        return result;
    }

private:
    void helper(TreeNode *root, vector&lt;int&gt; &amp;ret) {
        if (root != NULL) {
            helper(root-&gt;left, ret);
            ret.push_back(root-&gt;val);
            helper(root-&gt;right, ret);
        }
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        helper(root, result);
        return result;
    }

    private void helper(TreeNode root, List&lt;Integer&gt; ret) {
        if (root != null) {
            helper(root.left, ret);
            ret.add(root.val);
            helper(root.right, ret);
        }
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>Python 這種動態語言在寫遞迴時返回結果好處理點，無需聲明類型。通用的方法爲在遞迴函數入口參數中傳入返回結果，
也可使用分治的方法替代輔助函數。</p>
<h3>複雜度分析</h3>
<p>樹中每個節點都需要被訪問常數次，時間複雜度近似爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 未使用額外輔助空間。</p>
<h2>題解2  - 迭代版</h2>
<p>使用輔助 stack 改寫遞迴程序，中序遍歷沒有前序遍歷好寫，其中之一就在於出入 stack 的順序和限制規則。我們採用「左根右」的訪問順序可知主要由如下四步構成。</p>
<ol>
<li>首先需要一直對左子樹迭代並將非空節點壓入 stack </li>
<li>節點指針爲空後不再壓入 stack </li>
<li>當前節點爲空時進行出 stack 操作，並訪問 stack 頂節點</li>
<li>將當前指針p用其右子節點替代</li>
</ol>
<p>步驟2,3,4對應「左根右」的遍歷結構，只是此時的步驟2取的左值爲空。</p>
<h3>Python</h3>
<pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    # @param {TreeNode} root
    # @return {integer[]}
    def inorderTraversal(self, root):
        result = []
        s = []
        while root is not None or s:
            if root is not None:
                s.append(root)
                root = root.left
            else:
                root = s.pop()
                result.append(root.val)
                root = root.right

        return result
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */
class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: Inorder in vector which contains node values.
     */
public:
    vector&lt;int&gt; inorderTraversal(TreeNode *root) {
        vector&lt;int&gt; result;
        stack&lt;TreeNode *&gt; s;

        while (!s.empty() || NULL != root) {
            if (root != NULL) {
                s.push(root);
                root = root-&gt;left;
            } else {
                root = s.top();
                s.pop();
                result.push_back(root-&gt;val);
                root = root-&gt;right;
            }
        }

        return result;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        if (root == null) return result;

        Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;TreeNode&gt;();
        while (root != null || (!stack.isEmpty())) {
            if (root != null) {
                stack.push(root);
                root = root.left;
            } else {
                root = stack.pop();
                result.add(root.val);
                root = root.right;
            }
        }

        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>使用 stack 的思想模擬遞迴，注意迭代的演進和邊界條件即可。</p>
<h3>複雜度分析</h3>
<p>最壞情況下 stack 保存所有節點，空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Binary Tree Postorder Traversal]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/binary_tree/binary_tree_postorder_traversal.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/binary_tree/binary_tree_postorder_traversal.html">
        </link>
        <updated>2019-11-03T15:42:15Z</updated>
        <summary type="html"><![CDATA[<h1>Binary Tree Postorder Traversal</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#example">Example</a></li>
<li><a href="#challenge">Challenge</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#題解1---遞迴">題解1 - 遞迴</a><ul>
<li><a href="#python---divide-and-conquer">Python - Divide and Conquer</a></li>
<li><a href="#c---traversal">C++ - Traversal</a></li>
<li><a href="#java---divide-and-conquer">Java - Divide and Conquer</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#題解2---迭代">題解2 - 迭代</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
<li><a href="#題解3---反轉先序遍歷">題解3 - 反轉先序遍歷</a><ul>
<li><a href="#c-1">C++</a></li>
<li><a href="#java-1">Java</a></li>
<li><a href="#源碼分析-2">源碼分析</a></li>
<li><a href="#複雜度分析-2">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/binary-tree-postorder-traversal/">Binary Tree Postorder Traversal | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/binary-tree-postorder-traversal/">(68) Binary Tree Postorder Traversal</a></li>
</ul>
<h3>Problem Statement</h3>
<p>Given a binary tree, return the <em>postorder</em> traversal of its nodes&#39; values.</p>
<h4>Example</h4>
<p>Given binary tree <code>{1,#,2,3}</code>,</p>
<pre><code>   1
    \
     2
    /
   3
</code></pre><p>return <code>[3,2,1]</code>.</p>
<h4>Challenge</h4>
<p>Can you do it without recursion?</p>
<h2>題解1 - 遞迴</h2>
<p>首先使用遞迴便於理解。</p>
<h3>Python - Divide and Conquer</h3>
<pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    # @param {TreeNode} root
    # @return {integer[]}
    def postorderTraversal(self, root):
        if root is None:
            return []
        else:
            return self.postorderTraversal(root.left) +\
                   self.postorderTraversal(root.right) + [root.val]
</code></pre>
<h3>C++ - Traversal</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */
class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: Postorder in vector which contains node values.
     */
public:
    vector&lt;int&gt; postorderTraversal(TreeNode *root) {
        vector&lt;int&gt; result;

        traverse(root, result);

        return result;
    }

private:
    void traverse(TreeNode *root, vector&lt;int&gt; &amp;ret) {
        if (root == NULL) {
            return;
        }

        traverse(root-&gt;left, ret);
        traverse(root-&gt;right, ret);
        ret.push_back(root-&gt;val);
    }
};
</code></pre>
<h3>Java - Divide and Conquer</h3>
<pre><code class="lang-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        if (root != null) {
            List&lt;Integer&gt; left = postorderTraversal(root.left);
            result.addAll(left);
            List&lt;Integer&gt; right = postorderTraversal(root.right);
            result.addAll(right);
            result.add(root.val);
        }

        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>遞迴版的太簡單了，沒啥好說的，注意入 Stack 順序。</p>
<h3>複雜度分析</h3>
<p>時間複雜度近似爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h2>題解2 - 迭代</h2>
<p>使用遞迴寫後序遍歷那是相當的簡單，我們來個不使用遞迴的迭代版。整體思路仍然爲「左右根」，那麼怎麼才能知道什麼時候該訪問根節點呢？問題即轉化爲如何保證左右子節點一定先被訪問到？由於入Stack之後左右節點已無法區分，因此需要區分左右子節點是否被訪問過(加入到最終返回結果中)。除了有左右節點的情況，根節點也可能沒有任何子節點，此時也可直接將其值加入到最終返回結果中。</p>
<h3>Python</h3>
<pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    # @param {TreeNode} root
    # @return {integer[]}
    def postorderTraversal(self, root):
        result = []
        if root is None:
            return result
        s = []
        # previously traversed node
        prev = None
        s.append(root)
        while s:
            curr = s[-1]
            noChild = curr.left is None and curr.right is None
            childVisited = (prev is not None) and \
                           (curr.left == prev or curr.right == prev)
            if noChild or childVisited:
                result.append(curr.val)
                s.pop()
                prev = curr
            else:
                if curr.right is not None:
                    s.append(curr.right)
                if curr.left is not None:
                    s.append(curr.left)

        return result
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        if (root == NULL) return result;

        TreeNode *prev = NULL;
        stack&lt;TreeNode *&gt; s;
        s.push(root);
        while (!s.empty()) {
            TreeNode *curr = s.top();
            bool noChild = false;
            if (curr-&gt;left == NULL &amp;&amp; curr-&gt;right == NULL) {
                noChild = true;
            }
            bool childVisited = false;
            if (prev != NULL &amp;&amp; (curr-&gt;left == prev || curr-&gt;right == prev)) {
                childVisited = true;
            }

            // traverse
            if (noChild || childVisited) {
                result.push_back(curr-&gt;val);
                s.pop();
                prev = curr;
            } else {
                if (curr-&gt;right != NULL) s.push(curr-&gt;right);
                if (curr-&gt;left != NULL) s.push(curr-&gt;left);
            }
        }

        return result;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        if (root == null) return result;

        Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;TreeNode&gt;();
        stack.push(root);
        TreeNode prev = null;
        while (!stack.isEmpty()) {
            TreeNode curr = stack.peek();
            boolean noChild = (curr.left == null &amp;&amp; curr.right == null);
            boolean childVisited = false;
            if (prev != null &amp;&amp; (curr.left == prev || curr.right == prev)) {
                childVisited = true;
            }

            if (noChild || childVisited) {
                result.add(curr.val);
                stack.pop();
                prev = curr;
            } else {
                if (curr.right != null) stack.push(curr.right);
                if (curr.left != null) stack.push(curr.left);
            }
        }

        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>遍歷順序爲『左右根』，判斷根節點是否應該從Stack中剔除有兩種條件，一爲無子節點，二爲子節點已遍歷過。判斷子節點是否遍歷過需要排除<code>prev == null</code> 的情況，因爲 prev 初始化爲 null.</p>
<p><strong>將遞迴寫成迭代的難點在於如何在迭代中體現遞迴本質及邊界條件的確立，可使用簡單示例和紙上畫出Stack調用圖輔助分析。</strong></p>
<h3>複雜度分析</h3>
<p>最壞情況下Stack內存儲所有節點，空間複雜度近似爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 每個節點遍歷兩次或以上，時間複雜度近似爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h2>題解3 - 反轉先序遍歷</h2>
<p>要想得到『左右根』的後序遍歷結果，我們發現只需將『根右左』的結果轉置即可，而先序遍歷通常爲『根左右』，故改變『左右』的順序即可，所以如此一來後序遍歷的非遞迴實現起來就非常簡單了。</p>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */
class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: Postorder in vector which contains node values.
     */
public:
    vector&lt;int&gt; postorderTraversal(TreeNode *root) {
        vector&lt;int&gt; result;
        if (root == NULL) return result;

        stack&lt;TreeNode*&gt; s;
        s.push(root);
        while (!s.empty()) {
            TreeNode *node = s.top();
            s.pop();
            result.push_back(node-&gt;val);
            // root, right, left =&gt; left, right, root
            if (node-&gt;left != NULL) s.push(node-&gt;left);
            if (node-&gt;right != NULL) s.push(node-&gt;right);
        }
        // reverse
        std::reverse(result.begin(), result.end());
        return result;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: Postorder in ArrayList which contains node values.
     */
    public ArrayList&lt;Integer&gt; postorderTraversal(TreeNode root) {
        ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        if (root == null) return result;

        Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;TreeNode&gt;();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            result.add(node.val);
            if (node.left != null) stack.push(node.left);
            if (node.right != null) stack.push(node.right);
        }
        Collections.reverse(result);

        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>注意入Stack的順序和最後轉置即可。</p>
<h3>複雜度分析</h3>
<p>同先序遍歷。</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.cnblogs.com/zuoyuan/p/3720846.html">[leetcode]Binary Tree Postorder Traversal @ Python - 南郭子綦</a> - 解釋清晰</li>
<li><a href="http://zisong.me/post/suan-fa/geng-jian-dan-de-bian-li-er-cha-shu-de-fang-fa">更簡單的非遞迴遍歷二叉樹的方法</a> - 比較新穎和簡潔的實現</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Binary Tree Postorder Traversal</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#example">Example</a></li>
<li><a href="#challenge">Challenge</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#題解1---遞迴">題解1 - 遞迴</a><ul>
<li><a href="#python---divide-and-conquer">Python - Divide and Conquer</a></li>
<li><a href="#c---traversal">C++ - Traversal</a></li>
<li><a href="#java---divide-and-conquer">Java - Divide and Conquer</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#題解2---迭代">題解2 - 迭代</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
<li><a href="#題解3---反轉先序遍歷">題解3 - 反轉先序遍歷</a><ul>
<li><a href="#c-1">C++</a></li>
<li><a href="#java-1">Java</a></li>
<li><a href="#源碼分析-2">源碼分析</a></li>
<li><a href="#複雜度分析-2">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/binary-tree-postorder-traversal/">Binary Tree Postorder Traversal | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/binary-tree-postorder-traversal/">(68) Binary Tree Postorder Traversal</a></li>
</ul>
<h3>Problem Statement</h3>
<p>Given a binary tree, return the <em>postorder</em> traversal of its nodes&#39; values.</p>
<h4>Example</h4>
<p>Given binary tree <code>{1,#,2,3}</code>,</p>
<pre><code>   1
    \
     2
    /
   3
</code></pre><p>return <code>[3,2,1]</code>.</p>
<h4>Challenge</h4>
<p>Can you do it without recursion?</p>
<h2>題解1 - 遞迴</h2>
<p>首先使用遞迴便於理解。</p>
<h3>Python - Divide and Conquer</h3>
<pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    # @param {TreeNode} root
    # @return {integer[]}
    def postorderTraversal(self, root):
        if root is None:
            return []
        else:
            return self.postorderTraversal(root.left) +\
                   self.postorderTraversal(root.right) + [root.val]
</code></pre>
<h3>C++ - Traversal</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */
class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: Postorder in vector which contains node values.
     */
public:
    vector&lt;int&gt; postorderTraversal(TreeNode *root) {
        vector&lt;int&gt; result;

        traverse(root, result);

        return result;
    }

private:
    void traverse(TreeNode *root, vector&lt;int&gt; &amp;ret) {
        if (root == NULL) {
            return;
        }

        traverse(root-&gt;left, ret);
        traverse(root-&gt;right, ret);
        ret.push_back(root-&gt;val);
    }
};
</code></pre>
<h3>Java - Divide and Conquer</h3>
<pre><code class="lang-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        if (root != null) {
            List&lt;Integer&gt; left = postorderTraversal(root.left);
            result.addAll(left);
            List&lt;Integer&gt; right = postorderTraversal(root.right);
            result.addAll(right);
            result.add(root.val);
        }

        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>遞迴版的太簡單了，沒啥好說的，注意入 Stack 順序。</p>
<h3>複雜度分析</h3>
<p>時間複雜度近似爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h2>題解2 - 迭代</h2>
<p>使用遞迴寫後序遍歷那是相當的簡單，我們來個不使用遞迴的迭代版。整體思路仍然爲「左右根」，那麼怎麼才能知道什麼時候該訪問根節點呢？問題即轉化爲如何保證左右子節點一定先被訪問到？由於入Stack之後左右節點已無法區分，因此需要區分左右子節點是否被訪問過(加入到最終返回結果中)。除了有左右節點的情況，根節點也可能沒有任何子節點，此時也可直接將其值加入到最終返回結果中。</p>
<h3>Python</h3>
<pre><code class="lang-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    # @param {TreeNode} root
    # @return {integer[]}
    def postorderTraversal(self, root):
        result = []
        if root is None:
            return result
        s = []
        # previously traversed node
        prev = None
        s.append(root)
        while s:
            curr = s[-1]
            noChild = curr.left is None and curr.right is None
            childVisited = (prev is not None) and \
                           (curr.left == prev or curr.right == prev)
            if noChild or childVisited:
                result.append(curr.val)
                s.pop()
                prev = curr
            else:
                if curr.right is not None:
                    s.append(curr.right)
                if curr.left is not None:
                    s.append(curr.left)

        return result
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        if (root == NULL) return result;

        TreeNode *prev = NULL;
        stack&lt;TreeNode *&gt; s;
        s.push(root);
        while (!s.empty()) {
            TreeNode *curr = s.top();
            bool noChild = false;
            if (curr-&gt;left == NULL &amp;&amp; curr-&gt;right == NULL) {
                noChild = true;
            }
            bool childVisited = false;
            if (prev != NULL &amp;&amp; (curr-&gt;left == prev || curr-&gt;right == prev)) {
                childVisited = true;
            }

            // traverse
            if (noChild || childVisited) {
                result.push_back(curr-&gt;val);
                s.pop();
                prev = curr;
            } else {
                if (curr-&gt;right != NULL) s.push(curr-&gt;right);
                if (curr-&gt;left != NULL) s.push(curr-&gt;left);
            }
        }

        return result;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        if (root == null) return result;

        Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;TreeNode&gt;();
        stack.push(root);
        TreeNode prev = null;
        while (!stack.isEmpty()) {
            TreeNode curr = stack.peek();
            boolean noChild = (curr.left == null &amp;&amp; curr.right == null);
            boolean childVisited = false;
            if (prev != null &amp;&amp; (curr.left == prev || curr.right == prev)) {
                childVisited = true;
            }

            if (noChild || childVisited) {
                result.add(curr.val);
                stack.pop();
                prev = curr;
            } else {
                if (curr.right != null) stack.push(curr.right);
                if (curr.left != null) stack.push(curr.left);
            }
        }

        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>遍歷順序爲『左右根』，判斷根節點是否應該從Stack中剔除有兩種條件，一爲無子節點，二爲子節點已遍歷過。判斷子節點是否遍歷過需要排除<code>prev == null</code> 的情況，因爲 prev 初始化爲 null.</p>
<p><strong>將遞迴寫成迭代的難點在於如何在迭代中體現遞迴本質及邊界條件的確立，可使用簡單示例和紙上畫出Stack調用圖輔助分析。</strong></p>
<h3>複雜度分析</h3>
<p>最壞情況下Stack內存儲所有節點，空間複雜度近似爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 每個節點遍歷兩次或以上，時間複雜度近似爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h2>題解3 - 反轉先序遍歷</h2>
<p>要想得到『左右根』的後序遍歷結果，我們發現只需將『根右左』的結果轉置即可，而先序遍歷通常爲『根左右』，故改變『左右』的順序即可，所以如此一來後序遍歷的非遞迴實現起來就非常簡單了。</p>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */
class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: Postorder in vector which contains node values.
     */
public:
    vector&lt;int&gt; postorderTraversal(TreeNode *root) {
        vector&lt;int&gt; result;
        if (root == NULL) return result;

        stack&lt;TreeNode*&gt; s;
        s.push(root);
        while (!s.empty()) {
            TreeNode *node = s.top();
            s.pop();
            result.push_back(node-&gt;val);
            // root, right, left =&gt; left, right, root
            if (node-&gt;left != NULL) s.push(node-&gt;left);
            if (node-&gt;right != NULL) s.push(node-&gt;right);
        }
        // reverse
        std::reverse(result.begin(), result.end());
        return result;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: Postorder in ArrayList which contains node values.
     */
    public ArrayList&lt;Integer&gt; postorderTraversal(TreeNode root) {
        ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
        if (root == null) return result;

        Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;TreeNode&gt;();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            result.add(node.val);
            if (node.left != null) stack.push(node.left);
            if (node.right != null) stack.push(node.right);
        }
        Collections.reverse(result);

        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>注意入Stack的順序和最後轉置即可。</p>
<h3>複雜度分析</h3>
<p>同先序遍歷。</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.cnblogs.com/zuoyuan/p/3720846.html">[leetcode]Binary Tree Postorder Traversal @ Python - 南郭子綦</a> - 解釋清晰</li>
<li><a href="http://zisong.me/post/suan-fa/geng-jian-dan-de-bian-li-er-cha-shu-de-fang-fa">更簡單的非遞迴遍歷二叉樹的方法</a> - 比較新穎和簡潔的實現</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Binary Tree Level Order Traversal]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/binary_tree/binary_tree_level_order_traversal.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/binary_tree/binary_tree_level_order_traversal.html">
        </link>
        <updated>2019-11-03T15:42:15Z</updated>
        <summary type="html"><![CDATA[<h1>Binary Tree Level Order Traversal</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#example">Example</a></li>
<li><a href="#challenge">Challenge</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#題解---使用隊列">題解 - 使用隊列</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">Binary Tree Level Order Traversal | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/binary-tree-level-order-traversal/">(69) Binary Tree Level Order Traversal</a></li>
</ul>
<h3>Problem Statement</h3>
<p>Given a binary tree, return the <em>level order</em> traversal of its nodes&#39; values.
(ie, from left to right, level by level).</p>
<h4>Example</h4>
<p>Given binary tree <code>{3,9,20,#,#,15,7}</code>,</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre><p>return its level order traversal as:</p>
<pre><code>[
  [3],
  [9,20],
  [15,7]
]
</code></pre><h4>Challenge</h4>
<p>Challenge 1: Using only 1 queue to implement it.</p>
<p>Challenge 2: Use DFS algorithm to do it.</p>
<h2>題解 - 使用隊列</h2>
<p>此題爲廣度優先搜索(BFS)的基礎題，使用一個隊列保存每層的節點即可。出隊列和將子節點入隊列的實現使用 for 循環，將每一輪的節點輸出。</p>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */

class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: Level order a list of lists of integer
     */
public:
    vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) {
        vector&lt;vector&lt;int&gt; &gt; result;

        if (NULL == root) {
            return result;
        }

        queue&lt;TreeNode *&gt; q;
        q.push(root);
        while (!q.empty()) {
            vector&lt;int&gt; list;
            int size = q.size(); // keep the queue size first
            for (int i = 0; i != size; ++i) {
                TreeNode * node = q.front();
                q.pop();
                list.push_back(node-&gt;val);
                if (node-&gt;left) {
                    q.push(node-&gt;left);
                }
                if (node-&gt;right) {
                    q.push(node-&gt;right);
                }
            }
            result.push_back(list);
        }

        return result;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        if (root == null) return result;

        Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();
        q.offer(root);
        while (!q.isEmpty()) {
            List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
            int qSize = q.size();
            for (int i = 0; i &lt; qSize; i++) {
                TreeNode node = q.poll();
                list.add(node.val);
                // push child node into queue
                if (node.left != null) q.offer(node.left);
                if (node.right != null) q.offer(node.right);
            }
            result.add(new ArrayList&lt;Integer&gt;(list));
        }

        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>異常，還是異常</li>
<li>使用STL的<code>queue</code>數據結構，將<code>root</code>添加進隊列</li>
<li><strong>遍歷當前層所有節點，注意需要先保存隊列大小，因爲在入隊出隊時隊列大小會變化</strong></li>
<li><code>list</code>保存每層節點的值，每次使用均要初始化</li>
</ol>
<h3>複雜度分析</h3>
<p>使用輔助隊列，空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Binary Tree Level Order Traversal</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#example">Example</a></li>
<li><a href="#challenge">Challenge</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#題解---使用隊列">題解 - 使用隊列</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">Binary Tree Level Order Traversal | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/binary-tree-level-order-traversal/">(69) Binary Tree Level Order Traversal</a></li>
</ul>
<h3>Problem Statement</h3>
<p>Given a binary tree, return the <em>level order</em> traversal of its nodes&#39; values.
(ie, from left to right, level by level).</p>
<h4>Example</h4>
<p>Given binary tree <code>{3,9,20,#,#,15,7}</code>,</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre><p>return its level order traversal as:</p>
<pre><code>[
  [3],
  [9,20],
  [15,7]
]
</code></pre><h4>Challenge</h4>
<p>Challenge 1: Using only 1 queue to implement it.</p>
<p>Challenge 2: Use DFS algorithm to do it.</p>
<h2>題解 - 使用隊列</h2>
<p>此題爲廣度優先搜索(BFS)的基礎題，使用一個隊列保存每層的節點即可。出隊列和將子節點入隊列的實現使用 for 循環，將每一輪的節點輸出。</p>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */

class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: Level order a list of lists of integer
     */
public:
    vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) {
        vector&lt;vector&lt;int&gt; &gt; result;

        if (NULL == root) {
            return result;
        }

        queue&lt;TreeNode *&gt; q;
        q.push(root);
        while (!q.empty()) {
            vector&lt;int&gt; list;
            int size = q.size(); // keep the queue size first
            for (int i = 0; i != size; ++i) {
                TreeNode * node = q.front();
                q.pop();
                list.push_back(node-&gt;val);
                if (node-&gt;left) {
                    q.push(node-&gt;left);
                }
                if (node-&gt;right) {
                    q.push(node-&gt;right);
                }
            }
            result.push_back(list);
        }

        return result;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        if (root == null) return result;

        Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();
        q.offer(root);
        while (!q.isEmpty()) {
            List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
            int qSize = q.size();
            for (int i = 0; i &lt; qSize; i++) {
                TreeNode node = q.poll();
                list.add(node.val);
                // push child node into queue
                if (node.left != null) q.offer(node.left);
                if (node.right != null) q.offer(node.right);
            }
            result.add(new ArrayList&lt;Integer&gt;(list));
        }

        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>異常，還是異常</li>
<li>使用STL的<code>queue</code>數據結構，將<code>root</code>添加進隊列</li>
<li><strong>遍歷當前層所有節點，注意需要先保存隊列大小，因爲在入隊出隊時隊列大小會變化</strong></li>
<li><code>list</code>保存每層節點的值，每次使用均要初始化</li>
</ol>
<h3>複雜度分析</h3>
<p>使用輔助隊列，空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Binary Tree Level Order Traversal II]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/binary_tree/binary_tree_level_order_traversal_ii.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/binary_tree/binary_tree_level_order_traversal_ii.html">
        </link>
        <updated>2019-11-03T15:42:15Z</updated>
        <summary type="html"><![CDATA[<h1>Binary Tree Level Order Traversal II</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java---stack">Java - Stack</a></li>
<li><a href="#java---reverse">Java - Reverse</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">Binary Tree Level Order Traversal II | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/binary-tree-level-order-traversal-ii/">(70) Binary Tree Level Order Traversal II</a></li>
</ul>
<pre><code>Given a binary tree, return the bottom-up level order traversal of its nodes&#39; values.
(ie, from left to right, level by level from leaf to root).

Example
Given binary tree {3,9,20,#,#,15,7},

    3
   / \
  9  20
    /  \
   15   7


return its bottom-up level order traversal as:
[
  [15,7],
  [9,20],
  [3]
]
</code></pre><h2>題解</h2>
<p>這題在普通的 BFS 基礎上增加了逆序輸出，簡單的實現可以使用 Stack 或者最後對結果逆序。</p>
<h3>Java - Stack</h3>
<pre><code class="lang-java">/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */


public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: buttom-up level order a list of lists of integer
     */
    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {
        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
        if (root == null) return result;

        Stack&lt;ArrayList&lt;Integer&gt;&gt; s = new Stack&lt;ArrayList&lt;Integer&gt;&gt;();
        Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();
        q.offer(root);
        while (!q.isEmpty()) {
            int qLen = q.size();
            ArrayList&lt;Integer&gt; aList = new ArrayList&lt;Integer&gt;();
            for (int i = 0; i &lt; qLen; i++) {
                TreeNode node = q.poll();
                aList.add(node.val);
                if (node.left != null) q.offer(node.left);
                if (node.right != null) q.offer(node.right);
            }
            s.push(aList);
        }

        while (!s.empty()) {
            result.add(s.pop());
        }
        return result;
    }
}
</code></pre>
<h3>Java - Reverse</h3>
<pre><code class="lang-java">/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */


public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: buttom-up level order a list of lists of integer
     */
    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {
        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
        if (root == null) return result;

        Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();
        q.offer(root);
        while (!q.isEmpty()) {
            int qLen = q.size();
            ArrayList&lt;Integer&gt; aList = new ArrayList&lt;Integer&gt;();
            for (int i = 0; i &lt; qLen; i++) {
                TreeNode node = q.poll();
                aList.add(node.val);
                if (node.left != null) q.offer(node.left);
                if (node.right != null) q.offer(node.right);
            }
            result.add(aList);
        }

        Collections.reverse(result);
        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>Java 中 Queue 是接口，通常可用 LinkedList 實例化。</p>
<h3>複雜度分析</h3>
<p>時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 使用了 Queue 或者 Stack 作爲輔助空間，空間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Binary Tree Level Order Traversal II</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java---stack">Java - Stack</a></li>
<li><a href="#java---reverse">Java - Reverse</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">Binary Tree Level Order Traversal II | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/binary-tree-level-order-traversal-ii/">(70) Binary Tree Level Order Traversal II</a></li>
</ul>
<pre><code>Given a binary tree, return the bottom-up level order traversal of its nodes&#39; values.
(ie, from left to right, level by level from leaf to root).

Example
Given binary tree {3,9,20,#,#,15,7},

    3
   / \
  9  20
    /  \
   15   7


return its bottom-up level order traversal as:
[
  [15,7],
  [9,20],
  [3]
]
</code></pre><h2>題解</h2>
<p>這題在普通的 BFS 基礎上增加了逆序輸出，簡單的實現可以使用 Stack 或者最後對結果逆序。</p>
<h3>Java - Stack</h3>
<pre><code class="lang-java">/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */


public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: buttom-up level order a list of lists of integer
     */
    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {
        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
        if (root == null) return result;

        Stack&lt;ArrayList&lt;Integer&gt;&gt; s = new Stack&lt;ArrayList&lt;Integer&gt;&gt;();
        Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();
        q.offer(root);
        while (!q.isEmpty()) {
            int qLen = q.size();
            ArrayList&lt;Integer&gt; aList = new ArrayList&lt;Integer&gt;();
            for (int i = 0; i &lt; qLen; i++) {
                TreeNode node = q.poll();
                aList.add(node.val);
                if (node.left != null) q.offer(node.left);
                if (node.right != null) q.offer(node.right);
            }
            s.push(aList);
        }

        while (!s.empty()) {
            result.add(s.pop());
        }
        return result;
    }
}
</code></pre>
<h3>Java - Reverse</h3>
<pre><code class="lang-java">/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */


public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: buttom-up level order a list of lists of integer
     */
    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {
        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
        if (root == null) return result;

        Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();
        q.offer(root);
        while (!q.isEmpty()) {
            int qLen = q.size();
            ArrayList&lt;Integer&gt; aList = new ArrayList&lt;Integer&gt;();
            for (int i = 0; i &lt; qLen; i++) {
                TreeNode node = q.poll();
                aList.add(node.val);
                if (node.left != null) q.offer(node.left);
                if (node.right != null) q.offer(node.right);
            }
            result.add(aList);
        }

        Collections.reverse(result);
        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>Java 中 Queue 是接口，通常可用 LinkedList 實例化。</p>
<h3>複雜度分析</h3>
<p>時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 使用了 Queue 或者 Stack 作爲輔助空間，空間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Maximum Depth of Binary Tree]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/binary_tree/maximum_depth_of_binary_tree.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/binary_tree/maximum_depth_of_binary_tree.html">
        </link>
        <updated>2019-11-03T15:42:15Z</updated>
        <summary type="html"><![CDATA[<h1>Maximum Depth of Binary Tree</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#example">Example</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#題解---遞迴">題解 - 遞迴</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
</ul>
</li>
<li><a href="#題解---迭代顯式使用-stack">題解 - 迭代(顯式使用 Stack)</a><ul>
<li><a href="#c-1">C++</a></li>
</ul>
</li>
<li><a href="#題解3---迭代隊列">題解3 - 迭代(隊列)</a><ul>
<li><a href="#c-2">C++</a></li>
<li><a href="#java-1">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">Maximum Depth of Binary Tree | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/maximum-depth-of-binary-tree/">(97) Maximum Depth of Binary Tree</a></li>
</ul>
<h3>Problem Statement</h3>
<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root
node down to the farthest leaf node.</p>
<h4>Example</h4>
<p>Given a binary tree as follow:</p>
<pre><code>  1
 / \
2   3
   / \
  4   5
</code></pre><p>The maximum depth is <code>3</code>.</p>
<h2>題解 - 遞迴</h2>
<p>樹遍歷的題目最方便的寫法自然是遞迴，不過遞迴調用的層數過多可能會導致 Stack 空間 overflow，因此需要適當考慮遞迴調用的層數。我們首先來看看使用遞迴如何解這道題，要求二叉樹的最大深度，直觀上來講使用深度優先搜索判斷左右子樹的深度孰大孰小即可，從根節點往下一層樹的深度即自增1，遇到<code>NULL</code>時即返回0。</p>
<p>由於對每個節點都會使用一次<code>maxDepth</code>，故時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 樹的深度最大爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span>, 最小爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>log</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">\log_2 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.9388799999999999em;vertical-align:-0.24444em;"></span><span class="base textstyle uncramped"><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist"><span style="top:0.24444em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit">n</span></span></span></span>, 故空間複雜度介於 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 之間。</p>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param root: The root of binary tree.
     * @return: An integer
     */
    int maxDepth(TreeNode *root) {
        if (NULL == root) {
            return 0;
        }

        int left_depth = maxDepth(root-&gt;left);
        int right_depth = maxDepth(root-&gt;right);

        return max(left_depth, right_depth) + 1;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: An integer.
     */
    public int maxDepth(TreeNode root) {
        // write your code here
        if (root == null) {
            return 0;
        }
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
</code></pre>
<h2>題解 - 迭代(顯式使用 Stack)</h2>
<p>使用遞迴可能會導致棧空間溢出，這裏使用顯式棧空間(使用堆內存)來代替之前的隱式 Stack 空間。從上節遞迴版的程式碼(先處理左子樹，後處理右子樹，最後返回其中的較大值)來看，是可以使用類似後序遍歷的迭代思想去實現的。</p>
<p>首先使用後序遍歷的模板，在每次迭代循環結束處比較棧當前的大小和當前最大值<code>max_depth</code>進行比較。</p>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param root: The root of binary tree.
     * @return: An integer
     */
    int maxDepth(TreeNode *root) {
        if (NULL == root) {
            return 0;
        }

        TreeNode *curr = NULL, *prev = NULL;
        stack&lt;TreeNode *&gt; s;
        s.push(root);

        int max_depth = 0;

        while(!s.empty()) {
            curr = s.top();
            if (!prev || prev-&gt;left == curr || prev-&gt;right == curr) {
                if (curr-&gt;left) {
                    s.push(curr-&gt;left);
                } else if (curr-&gt;right){
                    s.push(curr-&gt;right);
                }
            } else if (curr-&gt;left == prev) {
                if (curr-&gt;right) {
                    s.push(curr-&gt;right);
                }
            } else {
                s.pop();
            }

            prev = curr;

            if (s.size() &gt; max_depth) {
                max_depth = s.size();
            }
        }

        return max_depth;
    }
};
</code></pre>
<h2>題解3 - 迭代(隊列)</h2>
<p>在使用了遞迴/後序遍歷求解樹最大深度之後，我們還可以直接從問題出發進行分析，樹的最大深度即爲廣度優先搜索中的層數，故可以直接使用廣度優先搜索求出最大深度。</p>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param root: The root of binary tree.
     * @return: An integer
     */
    int maxDepth(TreeNode *root) {
        if (NULL == root) {
            return 0;
        }

        queue&lt;TreeNode *&gt; q;
        q.push(root);

        int max_depth = 0;
        while(!q.empty()) {
            int size = q.size();
            for (int i = 0; i != size; ++i) {
                TreeNode *node = q.front();
                q.pop();

                if (node-&gt;left) {
                    q.push(node-&gt;left);
                }
                if (node-&gt;right) {
                    q.push(node-&gt;right);
                }
            }

            ++max_depth;
        }

        return max_depth;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: An integer.
     */
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int depth = 0;
        Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();
        q.offer(root);
        while (!q.isEmpty()) {
            depth++;
            int qLen = q.size();
            for (int i = 0; i &lt; qLen; i++) {
                TreeNode node = q.poll();
                if (node.left != null) q.offer(node.left);
                if (node.right != null) q.offer(node.right);
            }
        }

        return depth;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>廣度優先中隊列的使用中，<code>qLen</code> 需要在for 循環遍歷之前獲得，因爲它是一個變量。</p>
<h3>複雜度分析</h3>
<p>最壞情況下空間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 遍歷每一個節點，時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>,</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Maximum Depth of Binary Tree</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#example">Example</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#題解---遞迴">題解 - 遞迴</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
</ul>
</li>
<li><a href="#題解---迭代顯式使用-stack">題解 - 迭代(顯式使用 Stack)</a><ul>
<li><a href="#c-1">C++</a></li>
</ul>
</li>
<li><a href="#題解3---迭代隊列">題解3 - 迭代(隊列)</a><ul>
<li><a href="#c-2">C++</a></li>
<li><a href="#java-1">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">Maximum Depth of Binary Tree | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/maximum-depth-of-binary-tree/">(97) Maximum Depth of Binary Tree</a></li>
</ul>
<h3>Problem Statement</h3>
<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root
node down to the farthest leaf node.</p>
<h4>Example</h4>
<p>Given a binary tree as follow:</p>
<pre><code>  1
 / \
2   3
   / \
  4   5
</code></pre><p>The maximum depth is <code>3</code>.</p>
<h2>題解 - 遞迴</h2>
<p>樹遍歷的題目最方便的寫法自然是遞迴，不過遞迴調用的層數過多可能會導致 Stack 空間 overflow，因此需要適當考慮遞迴調用的層數。我們首先來看看使用遞迴如何解這道題，要求二叉樹的最大深度，直觀上來講使用深度優先搜索判斷左右子樹的深度孰大孰小即可，從根節點往下一層樹的深度即自增1，遇到<code>NULL</code>時即返回0。</p>
<p>由於對每個節點都會使用一次<code>maxDepth</code>，故時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 樹的深度最大爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span>, 最小爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>log</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">\log_2 n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.9388799999999999em;vertical-align:-0.24444em;"></span><span class="base textstyle uncramped"><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist"><span style="top:0.24444em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit">n</span></span></span></span>, 故空間複雜度介於 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 之間。</p>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param root: The root of binary tree.
     * @return: An integer
     */
    int maxDepth(TreeNode *root) {
        if (NULL == root) {
            return 0;
        }

        int left_depth = maxDepth(root-&gt;left);
        int right_depth = maxDepth(root-&gt;right);

        return max(left_depth, right_depth) + 1;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: An integer.
     */
    public int maxDepth(TreeNode root) {
        // write your code here
        if (root == null) {
            return 0;
        }
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
</code></pre>
<h2>題解 - 迭代(顯式使用 Stack)</h2>
<p>使用遞迴可能會導致棧空間溢出，這裏使用顯式棧空間(使用堆內存)來代替之前的隱式 Stack 空間。從上節遞迴版的程式碼(先處理左子樹，後處理右子樹，最後返回其中的較大值)來看，是可以使用類似後序遍歷的迭代思想去實現的。</p>
<p>首先使用後序遍歷的模板，在每次迭代循環結束處比較棧當前的大小和當前最大值<code>max_depth</code>進行比較。</p>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param root: The root of binary tree.
     * @return: An integer
     */
    int maxDepth(TreeNode *root) {
        if (NULL == root) {
            return 0;
        }

        TreeNode *curr = NULL, *prev = NULL;
        stack&lt;TreeNode *&gt; s;
        s.push(root);

        int max_depth = 0;

        while(!s.empty()) {
            curr = s.top();
            if (!prev || prev-&gt;left == curr || prev-&gt;right == curr) {
                if (curr-&gt;left) {
                    s.push(curr-&gt;left);
                } else if (curr-&gt;right){
                    s.push(curr-&gt;right);
                }
            } else if (curr-&gt;left == prev) {
                if (curr-&gt;right) {
                    s.push(curr-&gt;right);
                }
            } else {
                s.pop();
            }

            prev = curr;

            if (s.size() &gt; max_depth) {
                max_depth = s.size();
            }
        }

        return max_depth;
    }
};
</code></pre>
<h2>題解3 - 迭代(隊列)</h2>
<p>在使用了遞迴/後序遍歷求解樹最大深度之後，我們還可以直接從問題出發進行分析，樹的最大深度即爲廣度優先搜索中的層數，故可以直接使用廣度優先搜索求出最大深度。</p>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param root: The root of binary tree.
     * @return: An integer
     */
    int maxDepth(TreeNode *root) {
        if (NULL == root) {
            return 0;
        }

        queue&lt;TreeNode *&gt; q;
        q.push(root);

        int max_depth = 0;
        while(!q.empty()) {
            int size = q.size();
            for (int i = 0; i != size; ++i) {
                TreeNode *node = q.front();
                q.pop();

                if (node-&gt;left) {
                    q.push(node-&gt;left);
                }
                if (node-&gt;right) {
                    q.push(node-&gt;right);
                }
            }

            ++max_depth;
        }

        return max_depth;
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: An integer.
     */
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int depth = 0;
        Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();
        q.offer(root);
        while (!q.isEmpty()) {
            depth++;
            int qLen = q.size();
            for (int i = 0; i &lt; qLen; i++) {
                TreeNode node = q.poll();
                if (node.left != null) q.offer(node.left);
                if (node.right != null) q.offer(node.right);
            }
        }

        return depth;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>廣度優先中隊列的使用中，<code>qLen</code> 需要在for 循環遍歷之前獲得，因爲它是一個變量。</p>
<h3>複雜度分析</h3>
<p>最壞情況下空間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 遍歷每一個節點，時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>,</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Invert Binary Tree]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/binary_tree/invert_binary_tree.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/binary_tree/invert_binary_tree.html">
        </link>
        <updated>2019-11-03T15:42:16Z</updated>
        <summary type="html"><![CDATA[<h1>Invert Binary Tree</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解1---recursive">題解1 - Recursive</a><ul>
<li><a href="#c---return-void">C++ - return void</a></li>
<li><a href="#c---return-treenode-">C++ - return TreeNode *</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#題解2---iterative">題解2 - Iterative</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/invert-binary-tree/">Invert Binary Tree | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/invert-binary-tree/">(175) Invert Binary Tree</a></li>
</ul>
<pre><code>Invert a binary tree.

Example
  1         1
 / \       / \
2   3  =&gt; 3   2
   /       \
  4         4
Challenge
Do it in recursion is acceptable, can you do it without recursion?
</code></pre><h2>題解1 - Recursive</h2>
<p>二元樹的題用遞迴的思想求解自然是最容易的，此題要求爲交換左右子節點，故遞迴交換即可。具體實現可分返回值爲<code>NULL</code>或者二元樹節點兩種情況，返回值爲節點的情況理解起來相對不那麼直觀一些。</p>
<h3>C++ - return void</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * };
 */
class Solution {
public:
    /**
     * @param root: a TreeNode, the root of the binary tree
     * @return: nothing
     */
    void invertBinaryTree(TreeNode *root) {
        if (root == NULL) return;
        swap(root-&gt;left, root-&gt;right);
        invertBinaryTree(root-&gt;left);
        invertBinaryTree(root-&gt;right);
    }
};
</code></pre>
<h3>C++ - return TreeNode *</h3>
<pre><code class="lang-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return NULL;

        TreeNode *temp = root-&gt;left;
        root-&gt;left = invertTree(root-&gt;right);
        root-&gt;right = invertTree(temp);

        return root;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>分三塊實現，首先是節點爲空的情況，然後交換左右節點，最後遞迴調用，遞迴調用的正確性可通過畫圖理解。</p>
<h3>複雜度分析</h3>
<p>每個節點遍歷一次，時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 使用了臨時變數，空間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>題解2 - Iterative</h2>
<p>遞迴的實現非常簡單，那麼非遞迴的如何實現呢？如果將遞迴改寫成 stack 的實現，那麼簡單來講就需要兩個 stack 了，稍顯複雜。其實仔細觀察此題可發現使用 level-order 的遍歷次序也可實現。即從根節點開始進入隊列 queue，交換左右節點，並將非空的左右子節點進入隊列，從隊列中取出節點，交換之，直至隊列爲空。</p>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * };
 */
class Solution {
public:
    /**
     * @param root: a TreeNode, the root of the binary tree
     * @return: nothing
     */
    void invertBinaryTree(TreeNode *root) {
        if (root == NULL) return;

        queue&lt;TreeNode*&gt; q;
        q.push(root);
        while (!q.empty()) {
            // pop out the front node
            TreeNode *node = q.front();
            q.pop();
            // swap between left and right pointer
            swap(node-&gt;left, node-&gt;right);
            // push non-NULL node
            if (node-&gt;left != NULL) q.push(node-&gt;left);
            if (node-&gt;right != NULL) q.push(node-&gt;right);
        }
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>交換左右指針後需要判斷子節點是否非空，僅入隊非空子節點。</p>
<h3>複雜度分析</h3>
<p>遍歷每一個節點，時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 使用了隊列，最多存儲最下一層子節點數目，最多只有總節點數的一半，故最壞情況下 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><a href="https://leetcode.com/discuss/42613/0ms-c-recursive-iterative-solutions-with-explanations">0ms C++ Recursive/Iterative Solutions with Explanations - Leetcode Discuss</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Invert Binary Tree</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解1---recursive">題解1 - Recursive</a><ul>
<li><a href="#c---return-void">C++ - return void</a></li>
<li><a href="#c---return-treenode-">C++ - return TreeNode *</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#題解2---iterative">題解2 - Iterative</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/invert-binary-tree/">Invert Binary Tree | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/invert-binary-tree/">(175) Invert Binary Tree</a></li>
</ul>
<pre><code>Invert a binary tree.

Example
  1         1
 / \       / \
2   3  =&gt; 3   2
   /       \
  4         4
Challenge
Do it in recursion is acceptable, can you do it without recursion?
</code></pre><h2>題解1 - Recursive</h2>
<p>二元樹的題用遞迴的思想求解自然是最容易的，此題要求爲交換左右子節點，故遞迴交換即可。具體實現可分返回值爲<code>NULL</code>或者二元樹節點兩種情況，返回值爲節點的情況理解起來相對不那麼直觀一些。</p>
<h3>C++ - return void</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * };
 */
class Solution {
public:
    /**
     * @param root: a TreeNode, the root of the binary tree
     * @return: nothing
     */
    void invertBinaryTree(TreeNode *root) {
        if (root == NULL) return;
        swap(root-&gt;left, root-&gt;right);
        invertBinaryTree(root-&gt;left);
        invertBinaryTree(root-&gt;right);
    }
};
</code></pre>
<h3>C++ - return TreeNode *</h3>
<pre><code class="lang-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return NULL;

        TreeNode *temp = root-&gt;left;
        root-&gt;left = invertTree(root-&gt;right);
        root-&gt;right = invertTree(temp);

        return root;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>分三塊實現，首先是節點爲空的情況，然後交換左右節點，最後遞迴調用，遞迴調用的正確性可通過畫圖理解。</p>
<h3>複雜度分析</h3>
<p>每個節點遍歷一次，時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 使用了臨時變數，空間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>題解2 - Iterative</h2>
<p>遞迴的實現非常簡單，那麼非遞迴的如何實現呢？如果將遞迴改寫成 stack 的實現，那麼簡單來講就需要兩個 stack 了，稍顯複雜。其實仔細觀察此題可發現使用 level-order 的遍歷次序也可實現。即從根節點開始進入隊列 queue，交換左右節點，並將非空的左右子節點進入隊列，從隊列中取出節點，交換之，直至隊列爲空。</p>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * };
 */
class Solution {
public:
    /**
     * @param root: a TreeNode, the root of the binary tree
     * @return: nothing
     */
    void invertBinaryTree(TreeNode *root) {
        if (root == NULL) return;

        queue&lt;TreeNode*&gt; q;
        q.push(root);
        while (!q.empty()) {
            // pop out the front node
            TreeNode *node = q.front();
            q.pop();
            // swap between left and right pointer
            swap(node-&gt;left, node-&gt;right);
            // push non-NULL node
            if (node-&gt;left != NULL) q.push(node-&gt;left);
            if (node-&gt;right != NULL) q.push(node-&gt;right);
        }
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>交換左右指針後需要判斷子節點是否非空，僅入隊非空子節點。</p>
<h3>複雜度分析</h3>
<p>遍歷每一個節點，時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 使用了隊列，最多存儲最下一層子節點數目，最多只有總節點數的一半，故最壞情況下 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><a href="https://leetcode.com/discuss/42613/0ms-c-recursive-iterative-solutions-with-explanations">0ms C++ Recursive/Iterative Solutions with Explanations - Leetcode Discuss</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Binary Search Tree]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/binary_search_tree/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/binary_search_tree/">
        </link>
        <updated>2019-11-03T15:42:16Z</updated>
        <summary type="html"><![CDATA[<h1>Binary Search Tree - 二元搜尋樹</h1>
<p>二元搜尋樹的定義及簡介在 <a href="http://algorithm.yuanbin.me/zh-hans/basics_data_structure/binary_search_tree.html">Binary Search Trees</a> 中已經有所介紹。簡單來說就是每個節點的值大於等於左子結點的值，而小於右子節點的值。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Binary Search Tree - 二元搜尋樹</h1>
<p>二元搜尋樹的定義及簡介在 <a href="http://algorithm.yuanbin.me/zh-hans/basics_data_structure/binary_search_tree.html">Binary Search Trees</a> 中已經有所介紹。簡單來說就是每個節點的值大於等於左子結點的值，而小於右子節點的值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Insert Node in a Binary Search Tree]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/binary_search_tree/insert_node_in_a_binary_search_tree.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/binary_search_tree/insert_node_in_a_binary_search_tree.html">
        </link>
        <updated>2019-11-03T15:42:16Z</updated>
        <summary type="html"><![CDATA[<h1>Insert Node in a Binary Search Tree</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解---遞迴">題解 - 遞迴</a><ul>
<li><a href="#c-recursion">C++ Recursion</a></li>
<li><a href="#java-recursion">Java Recursion</a></li>
</ul>
</li>
<li><a href="#題解---迭代">題解 - 迭代</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#java-iterative">Java Iterative</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/insert-node-in-a-binary-search-tree/">(85) Insert Node in a Binary Search Tree</a></li>
</ul>
<pre><code>Given a binary search tree and a new tree node, insert the node into the tree. You should keep the tree still be a valid binary search tree.

Example
Given binary search tree as follow:

     2

  /    \

1        4

         /

       3

after Insert node 6, the tree should be:

     2

  /    \

1        4

         /   \

       3        6

Challenge
Do it without recursion
</code></pre><h2>題解 - 遞迴</h2>
<p>二元樹的題使用遞迴自然是最好理解的，程式碼也簡潔易懂，缺點就是遞迴調用時stack空間容易溢出，故實際實現中一般使用迭代替代遞迴，性能更佳嘛。不過迭代的缺點就是程式碼量稍(很)大，邏輯也可能不是那麼好懂。</p>
<p>既然確定使用遞迴，那麼接下來就應該考慮具體的實現問題了。在遞迴的具體實現中，主要考慮如下兩點：</p>
<ol>
<li>基本條件/終止條件 - 返回值需斟酌。</li>
<li>遞迴步/條件遞迴 - 能使原始問題收斂。</li>
</ol>
<p>首先來找找遞迴步，根據二叉查找樹的定義，若插入節點的值若大於當前節點的值，則繼續與當前節點的右子樹的值進行比較；反之則繼續與當前節點的左子樹的值進行比較。題目的要求是返回最終二元搜尋樹的根節點，從以上遞迴步的描述中似乎還難以對應到實際程式碼，這時不妨分析下終止條件。</p>
<p>有了遞迴步，終止條件也就水到渠成了，若當前節點爲空時，即返回結果。問題是——返回什麼結果？當前節點爲空時，說明應該將「插入節點」插入到上一個遍歷節點的左子節點或右子節點。對應到程序程式碼中即爲<code>root-&gt;right = node</code>或者<code>root-&gt;left = node</code>. 也就是說遞迴步使用<code>root-&gt;right/left = func(...)</code>即可。</p>
<h3>C++ Recursion</h3>
<pre><code class="lang-c++">/**
 * forked from http://www.jiuzhang.com/solutions/insert-node-in-binary-search-tree/
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param root: The root of the binary search tree.
     * @param node: insert this node into the binary search tree
     * @return: The root of the new binary search tree.
     */
    TreeNode* insertNode(TreeNode* root, TreeNode* node) {
        if (NULL == root) {
            return node;
        }

        if (node-&gt;val &lt;= root-&gt;val) {
            root-&gt;left = insertNode(root-&gt;left, node);
        } else {
            root-&gt;right = insertNode(root-&gt;right, node);
        }

        return root;
    }
};
</code></pre>
<h3>Java Recursion</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param root: The root of the binary search tree.
     * @param node: insert this node into the binary search tree
     * @return: The root of the new binary search tree.
     */
    public TreeNode insertNode(TreeNode root, TreeNode node) {
        if (root == null) {
            return node;
        }
        if (root.val &gt; node.val) {
            root.left = insertNode(root.left, node);
        } else {
            root.right = insertNode(root.right, node);
        }
        return root;
    }
}
</code></pre>
<h2>題解 - 迭代</h2>
<p>看過了以上遞迴版的題解，對於這個題來說，將遞迴轉化爲迭代的思路也是非常清晰易懂的。迭代比較當前節點的值和插入節點的值，到了二元樹的最後一層時選擇是鏈接至左子結點還是右子節點。</p>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param root: The root of the binary search tree.
     * @param node: insert this node into the binary search tree
     * @return: The root of the new binary search tree.
     */
    TreeNode* insertNode(TreeNode* root, TreeNode* node) {
        if (NULL == root) {
            return node;
        }

        TreeNode* tempNode = root;
        while (NULL != tempNode) {
            if (node-&gt;val &lt;= tempNode-&gt;val) {
                if (NULL == tempNode-&gt;left) {
                    tempNode-&gt;left = node;
                    return root;
                }
                tempNode = tempNode-&gt;left;
            } else {
                if (NULL == tempNode-&gt;right) {
                    tempNode-&gt;right = node;
                    return root;
                }
                tempNode = tempNode-&gt;right;
            }
        }

        return root;
    }
};
</code></pre>
<h3>Java Iterative</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param root: The root of the binary search tree.
     * @param node: insert this node into the binary search tree
     * @return: The root of the new binary search tree.
     */
    public TreeNode insertNode(TreeNode root, TreeNode node) {
        // write your code here
        if (root == null) return node;
        if (node == null) return root;

        TreeNode rootcopy = root;
        while (root != null) {
            if (root.val &lt;= node.val &amp;&amp; root.right == null) {
                root.right = node;
                break;
            }
            else if (root.val &gt; node.val &amp;&amp; root.left == null) {
                root.left = node;
                break;
            }
            else if(root.val &lt;= node.val) root = root.right;
            else root = root.left;
        }
        return rootcopy;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>在<code>NULL == tempNode-&gt;right</code>或者<code>NULL == tempNode-&gt;left</code>時需要在鏈接完<code>node</code>後立即返回<code>root</code>，避免死循環。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Insert Node in a Binary Search Tree</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解---遞迴">題解 - 遞迴</a><ul>
<li><a href="#c-recursion">C++ Recursion</a></li>
<li><a href="#java-recursion">Java Recursion</a></li>
</ul>
</li>
<li><a href="#題解---迭代">題解 - 迭代</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#java-iterative">Java Iterative</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/insert-node-in-a-binary-search-tree/">(85) Insert Node in a Binary Search Tree</a></li>
</ul>
<pre><code>Given a binary search tree and a new tree node, insert the node into the tree. You should keep the tree still be a valid binary search tree.

Example
Given binary search tree as follow:

     2

  /    \

1        4

         /

       3

after Insert node 6, the tree should be:

     2

  /    \

1        4

         /   \

       3        6

Challenge
Do it without recursion
</code></pre><h2>題解 - 遞迴</h2>
<p>二元樹的題使用遞迴自然是最好理解的，程式碼也簡潔易懂，缺點就是遞迴調用時stack空間容易溢出，故實際實現中一般使用迭代替代遞迴，性能更佳嘛。不過迭代的缺點就是程式碼量稍(很)大，邏輯也可能不是那麼好懂。</p>
<p>既然確定使用遞迴，那麼接下來就應該考慮具體的實現問題了。在遞迴的具體實現中，主要考慮如下兩點：</p>
<ol>
<li>基本條件/終止條件 - 返回值需斟酌。</li>
<li>遞迴步/條件遞迴 - 能使原始問題收斂。</li>
</ol>
<p>首先來找找遞迴步，根據二叉查找樹的定義，若插入節點的值若大於當前節點的值，則繼續與當前節點的右子樹的值進行比較；反之則繼續與當前節點的左子樹的值進行比較。題目的要求是返回最終二元搜尋樹的根節點，從以上遞迴步的描述中似乎還難以對應到實際程式碼，這時不妨分析下終止條件。</p>
<p>有了遞迴步，終止條件也就水到渠成了，若當前節點爲空時，即返回結果。問題是——返回什麼結果？當前節點爲空時，說明應該將「插入節點」插入到上一個遍歷節點的左子節點或右子節點。對應到程序程式碼中即爲<code>root-&gt;right = node</code>或者<code>root-&gt;left = node</code>. 也就是說遞迴步使用<code>root-&gt;right/left = func(...)</code>即可。</p>
<h3>C++ Recursion</h3>
<pre><code class="lang-c++">/**
 * forked from http://www.jiuzhang.com/solutions/insert-node-in-binary-search-tree/
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param root: The root of the binary search tree.
     * @param node: insert this node into the binary search tree
     * @return: The root of the new binary search tree.
     */
    TreeNode* insertNode(TreeNode* root, TreeNode* node) {
        if (NULL == root) {
            return node;
        }

        if (node-&gt;val &lt;= root-&gt;val) {
            root-&gt;left = insertNode(root-&gt;left, node);
        } else {
            root-&gt;right = insertNode(root-&gt;right, node);
        }

        return root;
    }
};
</code></pre>
<h3>Java Recursion</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param root: The root of the binary search tree.
     * @param node: insert this node into the binary search tree
     * @return: The root of the new binary search tree.
     */
    public TreeNode insertNode(TreeNode root, TreeNode node) {
        if (root == null) {
            return node;
        }
        if (root.val &gt; node.val) {
            root.left = insertNode(root.left, node);
        } else {
            root.right = insertNode(root.right, node);
        }
        return root;
    }
}
</code></pre>
<h2>題解 - 迭代</h2>
<p>看過了以上遞迴版的題解，對於這個題來說，將遞迴轉化爲迭代的思路也是非常清晰易懂的。迭代比較當前節點的值和插入節點的值，到了二元樹的最後一層時選擇是鏈接至左子結點還是右子節點。</p>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this-&gt;val = val;
 *         this-&gt;left = this-&gt;right = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param root: The root of the binary search tree.
     * @param node: insert this node into the binary search tree
     * @return: The root of the new binary search tree.
     */
    TreeNode* insertNode(TreeNode* root, TreeNode* node) {
        if (NULL == root) {
            return node;
        }

        TreeNode* tempNode = root;
        while (NULL != tempNode) {
            if (node-&gt;val &lt;= tempNode-&gt;val) {
                if (NULL == tempNode-&gt;left) {
                    tempNode-&gt;left = node;
                    return root;
                }
                tempNode = tempNode-&gt;left;
            } else {
                if (NULL == tempNode-&gt;right) {
                    tempNode-&gt;right = node;
                    return root;
                }
                tempNode = tempNode-&gt;right;
            }
        }

        return root;
    }
};
</code></pre>
<h3>Java Iterative</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param root: The root of the binary search tree.
     * @param node: insert this node into the binary search tree
     * @return: The root of the new binary search tree.
     */
    public TreeNode insertNode(TreeNode root, TreeNode node) {
        // write your code here
        if (root == null) return node;
        if (node == null) return root;

        TreeNode rootcopy = root;
        while (root != null) {
            if (root.val &lt;= node.val &amp;&amp; root.right == null) {
                root.right = node;
                break;
            }
            else if (root.val &gt; node.val &amp;&amp; root.left == null) {
                root.left = node;
                break;
            }
            else if(root.val &lt;= node.val) root = root.right;
            else root = root.left;
        }
        return rootcopy;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>在<code>NULL == tempNode-&gt;right</code>或者<code>NULL == tempNode-&gt;left</code>時需要在鏈接完<code>node</code>後立即返回<code>root</code>，避免死循環。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Exhaustive Search]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/exhaustive_search/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/exhaustive_search/">
        </link>
        <updated>2019-11-03T15:42:16Z</updated>
        <summary type="html"><![CDATA[<h1>Exhaustive Search - 窮竭搜索</h1>
<!-- toc -->
<ul>
<li><a href="#dfs">DFS</a><ul>
<li><a href="#bfs">BFS</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<p>窮竭搜索又稱暴力搜索，指代將所有可能性列出來，然後再在其中尋找滿足題目條件的解。常用求解方法和工具有：</p>
<ol>
<li>遞歸函數</li>
<li>棧</li>
<li>隊列</li>
<li>深度優先搜索(DFS, Depth-First Search)，又常稱為回溯法</li>
<li>廣度優先搜索(BFS, Breadth-First Search)</li>
</ol>
<p>1, 2, 3 往往在深搜或者廣搜中體現。</p>
<h2>DFS</h2>
<p>DFS 通常從某個狀態開始，根據特定的規則轉移狀態，直至無法轉移(節點為空)，然後回退到之前一步狀態，繼續按照指定規則轉移狀態，直至遍曆完所有狀態。</p>
<p>回溯法包含了多類問題，模板類似。</p>
<p>排列組合模板-&gt;搜索問題(是否要排序，哪些情況要跳過)</p>
<p>使用回溯法的一般步驟：</p>
<ol>
<li>確定所給問題的解空間：首先應明確定義問題的解空間，解空間中至少包含問題的一個解。</li>
<li>確定結點的擴展搜索規則</li>
<li>以深度優先方式搜索解空間，並在搜索過程中用剪枝函數避免無效搜索。</li>
</ol>
<h3>BFS</h3>
<p>BFS 從某個狀態開始，搜索<strong>所有可以到達的狀態</strong>，轉移順序為『初始狀態-&gt;只需一次轉移就可到達的所有狀態-&gt;只需兩次轉移就可到達的所有狀態-&gt;...』，所以對於同一個狀態，BFS 只搜索一次，故時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>s</mi><mo>×</mo><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">_</mi><mi>m</mi><mi>e</mi><mi>t</mi><mi>h</mi><mi>o</mi><mi>d</mi><mi>s</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(states \times transfer\_methods)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.06em;vertical-align:-0.31em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mbin">×</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">t</span><span class="mord mathit">h</span><span class="mord mathit">o</span><span class="mord mathit">d</span><span class="mord mathit">s</span><span class="mclose">)</span></span></span></span>. BFS 通常配合隊列一起使用，搜索時先將狀態加入到隊列中，然後從隊列頂端不斷取出狀態，再把從該狀態可轉移到的狀態中尚未訪問過的部分加入隊列，知道隊列為空或已找到解。因此 BFS 適合用於『由近及遠』的搜索，比較適合用於求解最短路徑、最少操作之類的問題。</p>
<h2>Reference</h2>
<ul>
<li>《挑戰程序設計競賽》Chaper 2.1 p26 最基礎的「窮竭搜索」</li>
<li><a href="http://7xojrx.com1.z0.glb.clouddn.com/docs/algorithm-exercise/docs/lecture15-backtracking.pdf">Steven Skiena: Lecture15 - Backtracking</a></li>
<li><a href="http://www.cnblogs.com/wuyuegb2312/p/3273337.html">全面解析回溯法：算法框架與問題求解 - 五嶽 - 博客園</a></li>
<li><a href="http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741376.html">五大常用算法之四：回溯法 - 紅臉書生 - 博客園</a></li>
<li><a href="http://www.csie.ntnu.edu.tw/~u91029/Backtracking.html">演算法筆記 - Backtracking</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Exhaustive Search - 窮竭搜索</h1>
<!-- toc -->
<ul>
<li><a href="#dfs">DFS</a><ul>
<li><a href="#bfs">BFS</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<p>窮竭搜索又稱暴力搜索，指代將所有可能性列出來，然後再在其中尋找滿足題目條件的解。常用求解方法和工具有：</p>
<ol>
<li>遞歸函數</li>
<li>棧</li>
<li>隊列</li>
<li>深度優先搜索(DFS, Depth-First Search)，又常稱為回溯法</li>
<li>廣度優先搜索(BFS, Breadth-First Search)</li>
</ol>
<p>1, 2, 3 往往在深搜或者廣搜中體現。</p>
<h2>DFS</h2>
<p>DFS 通常從某個狀態開始，根據特定的規則轉移狀態，直至無法轉移(節點為空)，然後回退到之前一步狀態，繼續按照指定規則轉移狀態，直至遍曆完所有狀態。</p>
<p>回溯法包含了多類問題，模板類似。</p>
<p>排列組合模板-&gt;搜索問題(是否要排序，哪些情況要跳過)</p>
<p>使用回溯法的一般步驟：</p>
<ol>
<li>確定所給問題的解空間：首先應明確定義問題的解空間，解空間中至少包含問題的一個解。</li>
<li>確定結點的擴展搜索規則</li>
<li>以深度優先方式搜索解空間，並在搜索過程中用剪枝函數避免無效搜索。</li>
</ol>
<h3>BFS</h3>
<p>BFS 從某個狀態開始，搜索<strong>所有可以到達的狀態</strong>，轉移順序為『初始狀態-&gt;只需一次轉移就可到達的所有狀態-&gt;只需兩次轉移就可到達的所有狀態-&gt;...』，所以對於同一個狀態，BFS 只搜索一次，故時間複雜度為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>s</mi><mo>×</mo><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>f</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">_</mi><mi>m</mi><mi>e</mi><mi>t</mi><mi>h</mi><mi>o</mi><mi>d</mi><mi>s</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(states \times transfer\_methods)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.06em;vertical-align:-0.31em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">a</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mbin">×</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit">t</span><span class="mord mathit">h</span><span class="mord mathit">o</span><span class="mord mathit">d</span><span class="mord mathit">s</span><span class="mclose">)</span></span></span></span>. BFS 通常配合隊列一起使用，搜索時先將狀態加入到隊列中，然後從隊列頂端不斷取出狀態，再把從該狀態可轉移到的狀態中尚未訪問過的部分加入隊列，知道隊列為空或已找到解。因此 BFS 適合用於『由近及遠』的搜索，比較適合用於求解最短路徑、最少操作之類的問題。</p>
<h2>Reference</h2>
<ul>
<li>《挑戰程序設計競賽》Chaper 2.1 p26 最基礎的「窮竭搜索」</li>
<li><a href="http://7xojrx.com1.z0.glb.clouddn.com/docs/algorithm-exercise/docs/lecture15-backtracking.pdf">Steven Skiena: Lecture15 - Backtracking</a></li>
<li><a href="http://www.cnblogs.com/wuyuegb2312/p/3273337.html">全面解析回溯法：算法框架與問題求解 - 五嶽 - 博客園</a></li>
<li><a href="http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741376.html">五大常用算法之四：回溯法 - 紅臉書生 - 博客園</a></li>
<li><a href="http://www.csie.ntnu.edu.tw/~u91029/Backtracking.html">演算法筆記 - Backtracking</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Subsets]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/exhaustive_search/subsets.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/exhaustive_search/subsets.html">
        </link>
        <updated>2019-11-03T15:42:17Z</updated>
        <summary type="html"><![CDATA[<h1>Subsets - 子集</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/subsets/">Subsets | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/subsets/">(17) Subsets</a></li>
</ul>
<pre><code>Given a set of distinct integers, return all possible subsets.

Note
Elements in a subset must be in non-descending order.

The solution set must not contain duplicate subsets.

Example
If S = [1,2,3], a solution is:

[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
</code></pre><h2>題解</h2>
<p>子集類問題類似Combination，以輸入陣列<code>[1, 2, 3]</code>分析，根據題意，最終返回結果中子集類的元素應該按照升序排列，故首先需要對原陣列進行排序。題目的第二點要求是子集不能重複，至此原題即轉化為數學中的組合問題。我們首先嘗試使用 DFS 進行求解，大致步驟如下：</p>
<ol>
<li><code>[1] -&gt; [1, 2] -&gt; [1, 2, 3]</code></li>
<li><code>[2] -&gt; [2, 3]</code></li>
<li><code>[3]</code></li>
</ol>
<p>將上述過程轉化為程式碼即為對陣列遍歷，每一輪都保存之前的結果並將其依次加入到最終返回結果中。</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    # @param {integer[]} nums
    # @return {integer[][]}
    def subsets(self, nums):
        if nums is None:
            return []

        result = []
        nums.sort()
        self.dfs(nums, 0, [], result)
        return result

    def dfs(self, nums, pos, list_temp, ret):
        # append new object with []
        ret.append([] + list_temp)

        for i in xrange(pos, len(nums)):
            list_temp.append(nums[i])
            self.dfs(nums, i + 1, list_temp, ret)
            list_temp.pop()
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt; &gt; result;
        if (nums.empty()) return result;

        sort(nums.begin(), nums.end());
        vector&lt;int&gt; list;
        dfs(nums, 0, list, result);

        return result;
    }

private:
    void dfs(vector&lt;int&gt;&amp; nums, int pos, vector&lt;int&gt; &amp;list,
             vector&lt;vector&lt;int&gt; &gt; &amp;ret) {

        ret.push_back(list);

        for (int i = pos; i &lt; nums.size(); ++i) {
            list.push_back(nums[i]);
            dfs(nums, i + 1, list, ret);
            list.pop_back();
        }
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        if (nums == null || nums.length == 0) {
            return result;
        }

        Arrays.sort(nums);
        dfs(nums, 0, list, result);

        return result;
    }

    private void dfs(int[] nums, int pos, List&lt;Integer&gt; list,
                     List&lt;List&lt;Integer&gt;&gt; ret) {

        // add temp result first
        ret.add(new ArrayList&lt;Integer&gt;(list));

        for (int i = pos; i &lt; nums.length; i++) {
            list.add(nums[i]);
            dfs(nums, i + 1, list, ret);
            list.remove(list.size() - 1);
        }
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>Java 和 Python 的程式碼中在將臨時list 添加到最終結果時新生成了物件，(Python 使用<code>[] +</code>), 否則最終返回結果將隨著<code>list</code> 的變化而變化。</p>
<p><strong>Notice: backTrack(num, i + 1, list, ret);中的『i + 1』不可誤寫為『pos + 1』，因為<code>pos</code>用於每次大的循環，<code>i</code>用於內循環，第一次寫subsets的時候在這坑了很久... :(</strong></p>
<p>回溯法可用圖示和函數運行的堆棧圖來理解，強烈建議<strong>使用圖形和遞迴的思想</strong>分析，以陣列<code>[1, 2, 3]</code>進行分析。下圖所示為<code>list</code>及<code>result</code>動態變化的過程，箭頭向下表示<code>list.add</code>及<code>result.add</code>操作，箭頭向上表示<code>list.remove</code>操作。</p>
<p><img src="../../shared-files/images/subsets.jpg" alt="Subsets運行遞迴調用圖"></p>
<h3>複雜度分析</h3>
<p>對原有陣列排序，時間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 狀態數為所有可能的組合數 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>, 生成每個狀態所需的時間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>, 如<code>[1] -&gt; [1, 2]</code>, 故總的時間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p>使用了臨時空間<code>list</code>保存中間結果，<code>list</code> 最大長度為陣列長度，故空間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><a href="http://okckd.github.io/blog/2014/06/12/NineChap-Permutation/">[NineChap 1.2] Permutation - Woodstock Blog</a></li>
<li><a href="http://www.jiuzhang.com/solutions/subsets/">九章算法 - subsets模板</a></li>
<li><a href="http://www.cnblogs.com/yuzhangcmu/p/4211815.html">LeetCode: Subsets 解題報告 - Yu&#39;s Garden - 博客園</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Subsets - 子集</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/subsets/">Subsets | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/subsets/">(17) Subsets</a></li>
</ul>
<pre><code>Given a set of distinct integers, return all possible subsets.

Note
Elements in a subset must be in non-descending order.

The solution set must not contain duplicate subsets.

Example
If S = [1,2,3], a solution is:

[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
</code></pre><h2>題解</h2>
<p>子集類問題類似Combination，以輸入陣列<code>[1, 2, 3]</code>分析，根據題意，最終返回結果中子集類的元素應該按照升序排列，故首先需要對原陣列進行排序。題目的第二點要求是子集不能重複，至此原題即轉化為數學中的組合問題。我們首先嘗試使用 DFS 進行求解，大致步驟如下：</p>
<ol>
<li><code>[1] -&gt; [1, 2] -&gt; [1, 2, 3]</code></li>
<li><code>[2] -&gt; [2, 3]</code></li>
<li><code>[3]</code></li>
</ol>
<p>將上述過程轉化為程式碼即為對陣列遍歷，每一輪都保存之前的結果並將其依次加入到最終返回結果中。</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    # @param {integer[]} nums
    # @return {integer[][]}
    def subsets(self, nums):
        if nums is None:
            return []

        result = []
        nums.sort()
        self.dfs(nums, 0, [], result)
        return result

    def dfs(self, nums, pos, list_temp, ret):
        # append new object with []
        ret.append([] + list_temp)

        for i in xrange(pos, len(nums)):
            list_temp.append(nums[i])
            self.dfs(nums, i + 1, list_temp, ret)
            list_temp.pop()
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt; &gt; result;
        if (nums.empty()) return result;

        sort(nums.begin(), nums.end());
        vector&lt;int&gt; list;
        dfs(nums, 0, list, result);

        return result;
    }

private:
    void dfs(vector&lt;int&gt;&amp; nums, int pos, vector&lt;int&gt; &amp;list,
             vector&lt;vector&lt;int&gt; &gt; &amp;ret) {

        ret.push_back(list);

        for (int i = pos; i &lt; nums.size(); ++i) {
            list.push_back(nums[i]);
            dfs(nums, i + 1, list, ret);
            list.pop_back();
        }
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        if (nums == null || nums.length == 0) {
            return result;
        }

        Arrays.sort(nums);
        dfs(nums, 0, list, result);

        return result;
    }

    private void dfs(int[] nums, int pos, List&lt;Integer&gt; list,
                     List&lt;List&lt;Integer&gt;&gt; ret) {

        // add temp result first
        ret.add(new ArrayList&lt;Integer&gt;(list));

        for (int i = pos; i &lt; nums.length; i++) {
            list.add(nums[i]);
            dfs(nums, i + 1, list, ret);
            list.remove(list.size() - 1);
        }
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>Java 和 Python 的程式碼中在將臨時list 添加到最終結果時新生成了物件，(Python 使用<code>[] +</code>), 否則最終返回結果將隨著<code>list</code> 的變化而變化。</p>
<p><strong>Notice: backTrack(num, i + 1, list, ret);中的『i + 1』不可誤寫為『pos + 1』，因為<code>pos</code>用於每次大的循環，<code>i</code>用於內循環，第一次寫subsets的時候在這坑了很久... :(</strong></p>
<p>回溯法可用圖示和函數運行的堆棧圖來理解，強烈建議<strong>使用圖形和遞迴的思想</strong>分析，以陣列<code>[1, 2, 3]</code>進行分析。下圖所示為<code>list</code>及<code>result</code>動態變化的過程，箭頭向下表示<code>list.add</code>及<code>result.add</code>操作，箭頭向上表示<code>list.remove</code>操作。</p>
<p><img src="../../shared-files/images/subsets.jpg" alt="Subsets運行遞迴調用圖"></p>
<h3>複雜度分析</h3>
<p>對原有陣列排序，時間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 狀態數為所有可能的組合數 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>, 生成每個狀態所需的時間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>, 如<code>[1] -&gt; [1, 2]</code>, 故總的時間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<p>使用了臨時空間<code>list</code>保存中間結果，<code>list</code> 最大長度為陣列長度，故空間複雜度近似為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li><a href="http://okckd.github.io/blog/2014/06/12/NineChap-Permutation/">[NineChap 1.2] Permutation - Woodstock Blog</a></li>
<li><a href="http://www.jiuzhang.com/solutions/subsets/">九章算法 - subsets模板</a></li>
<li><a href="http://www.cnblogs.com/yuzhangcmu/p/4211815.html">LeetCode: Subsets 解題報告 - Yu&#39;s Garden - 博客園</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Next Permutation]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/exhaustive_search/next_permutation.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/exhaustive_search/next_permutation.html">
        </link>
        <updated>2019-11-03T15:42:17Z</updated>
        <summary type="html"><![CDATA[<h1>Next Permutation</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#example">Example</a></li>
<li><a href="#note">Note</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#題解">題解</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/next-permutation/">Next Permutation | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/next-permutation/">(52) Next Permutation</a></li>
</ul>
<h3>Problem Statement</h3>
<p>Given a list of integers, which denote a permutation.</p>
<p>Find the next permutation in ascending order.</p>
<h4>Example</h4>
<p>For <code>[1,3,2,3]</code>, the next permutation is <code>[1,3,3,2]</code></p>
<p>For <code>[4,3,2,1]</code>, the next permutation is <code>[1,2,3,4]</code></p>
<h4>Note</h4>
<p>The list may contains duplicate integers.</p>
<h2>題解</h2>
<p>找下一個升序排列，C++ STL 源碼剖析一書中有提及，<a href="http://algorithm.yuanbin.me/zh-hans/exhaustive_search/permutations.html">Permutations</a> 一小節中也有詳細介紹，下面簡要介紹一下字典序算法：</p>
<ol>
<li>從後往前尋找索引滿足 <code>a[k] &lt; a[k + 1]</code>, 如果此條件不滿足，則說明已遍歷到最後一個。</li>
<li>從後往前遍歷，找到第一個比<code>a[k]</code>大的數<code>a[l]</code>, 即<code>a[k] &lt; a[l]</code>.</li>
<li>交換<code>a[k]</code>與<code>a[l]</code>.</li>
<li>反轉<code>k + 1 ~ n</code>之間的元素。</li>
</ol>
<p>由於這道題中規定對於<code>[4,3,2,1]</code>, 輸出爲<code>[1,2,3,4]</code>, 故在第一步稍加處理即可。</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    # @param num :  a list of integer
    # @return : a list of integer
    def nextPermutation(self, num):
        if num is None or len(num) &lt;= 1:
            return num
        # step1: find nums[i] &lt; nums[i + 1], Loop backwards
        i = 0
        for i in xrange(len(num) - 2, -1, -1):
            if num[i] &lt; num[i + 1]:
                break
            elif i == 0:
                # reverse nums if reach maximum
                num = num[::-1]
                return num
        # step2: find nums[i] &lt; nums[j], Loop backwards
        j = 0
        for j in xrange(len(num) - 1, i, -1):
            if num[i] &lt; num[j]:
                break
        # step3: swap betwenn nums[i] and nums[j]
        num[i], num[j] = num[j], num[i]
        # step4: reverse between [i + 1, n - 1]
        num[i + 1:len(num)] = num[len(num) - 1:i:-1]

        return num
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param nums: An array of integers
     * @return: An array of integers that&#39;s next permuation
     */
    vector&lt;int&gt; nextPermutation(vector&lt;int&gt; &amp;nums) {
        if (nums.empty() || nums.size() &lt;= 1) {
            return nums;
        }
        // step1: find nums[i] &lt; nums[i + 1]
        int i = 0;
        for (i = nums.size() - 2; i &gt;= 0; --i) {
            if (nums[i] &lt; nums[i + 1]) {
                break;
            } else if (0 == i) {
                // reverse nums if reach maximum
                reverse(nums, 0, nums.size() - 1);
                return nums;
            }
        }
        // step2: find nums[i] &lt; nums[j]
        int j = 0;
        for (j = nums.size() - 1; j &gt; i; --j) {
            if (nums[i] &lt; nums[j]) break;
        }
        // step3: swap betwenn nums[i] and nums[j]
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
        // step4: reverse between [i + 1, n - 1]
        reverse(nums, i + 1, nums.size() - 1);

        return nums;

    }

private:
    void reverse(vector&lt;int&gt;&amp; nums, int start, int end) {
        for (int i = start, j = end; i &lt; j; ++i, --j) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param nums: an array of integers
     * @return: return nothing (void), do not return anything, modify nums in-place instead
     */
    public void nextPermutation(int[] nums) {
        if (nums == null || nums.length == 0) return;

        // step1: search the first nums[k] &lt; nums[k+1] backward
        int k = -1;
        for (int i = nums.length - 2; i &gt;= 0; i--) {
            if (nums[i] &lt; nums[i + 1]) {
                k = i;
                break;
            }
        }
        // if current rank is the largest, reverse it to smallest, return
        if (k == -1) {
            reverse(nums, 0, nums.length - 1);
            return;
        }

        // step2: search the first nums[k] &lt; nums[l] backward
        int l = nums.length - 1;
        while (l &gt; k &amp;&amp; nums[l] &lt;= nums[k]) l--;

        // step3: swap nums[k] with nums[l]
        int temp = nums[k];
        nums[k] = nums[l];
        nums[l] = temp;

        // step4: reverse between k+1 and nums.length-1;
        reverse(nums, k + 1, nums.length - 1);
    }

    private void reverse(int[] nums, int lb, int ub) {
        for (int i = lb, j = ub; i &lt; j; i++, j--) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>和 Permutation 一小節類似，這裏只需要注意在step 1中<code>i == -1</code>時需要反轉之以獲得最小的序列。對於有重復元素，只要在 step1和 step2中判斷元素大小時不取等號即可。Lintcode 上給的註釋要求（其實是 Leetcode 上的要求）和實際給出的輸出不一樣。</p>
<h3>複雜度分析</h3>
<p>最壞情況下，遍歷兩次原陣列，反轉一次陣列，時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 使用了 temp 臨時變量，空間複雜度可認爲是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Next Permutation</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#example">Example</a></li>
<li><a href="#note">Note</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#題解">題解</a><ul>
<li><a href="#python">Python</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/next-permutation/">Next Permutation | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/next-permutation/">(52) Next Permutation</a></li>
</ul>
<h3>Problem Statement</h3>
<p>Given a list of integers, which denote a permutation.</p>
<p>Find the next permutation in ascending order.</p>
<h4>Example</h4>
<p>For <code>[1,3,2,3]</code>, the next permutation is <code>[1,3,3,2]</code></p>
<p>For <code>[4,3,2,1]</code>, the next permutation is <code>[1,2,3,4]</code></p>
<h4>Note</h4>
<p>The list may contains duplicate integers.</p>
<h2>題解</h2>
<p>找下一個升序排列，C++ STL 源碼剖析一書中有提及，<a href="http://algorithm.yuanbin.me/zh-hans/exhaustive_search/permutations.html">Permutations</a> 一小節中也有詳細介紹，下面簡要介紹一下字典序算法：</p>
<ol>
<li>從後往前尋找索引滿足 <code>a[k] &lt; a[k + 1]</code>, 如果此條件不滿足，則說明已遍歷到最後一個。</li>
<li>從後往前遍歷，找到第一個比<code>a[k]</code>大的數<code>a[l]</code>, 即<code>a[k] &lt; a[l]</code>.</li>
<li>交換<code>a[k]</code>與<code>a[l]</code>.</li>
<li>反轉<code>k + 1 ~ n</code>之間的元素。</li>
</ol>
<p>由於這道題中規定對於<code>[4,3,2,1]</code>, 輸出爲<code>[1,2,3,4]</code>, 故在第一步稍加處理即可。</p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    # @param num :  a list of integer
    # @return : a list of integer
    def nextPermutation(self, num):
        if num is None or len(num) &lt;= 1:
            return num
        # step1: find nums[i] &lt; nums[i + 1], Loop backwards
        i = 0
        for i in xrange(len(num) - 2, -1, -1):
            if num[i] &lt; num[i + 1]:
                break
            elif i == 0:
                # reverse nums if reach maximum
                num = num[::-1]
                return num
        # step2: find nums[i] &lt; nums[j], Loop backwards
        j = 0
        for j in xrange(len(num) - 1, i, -1):
            if num[i] &lt; num[j]:
                break
        # step3: swap betwenn nums[i] and nums[j]
        num[i], num[j] = num[j], num[i]
        # step4: reverse between [i + 1, n - 1]
        num[i + 1:len(num)] = num[len(num) - 1:i:-1]

        return num
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param nums: An array of integers
     * @return: An array of integers that&#39;s next permuation
     */
    vector&lt;int&gt; nextPermutation(vector&lt;int&gt; &amp;nums) {
        if (nums.empty() || nums.size() &lt;= 1) {
            return nums;
        }
        // step1: find nums[i] &lt; nums[i + 1]
        int i = 0;
        for (i = nums.size() - 2; i &gt;= 0; --i) {
            if (nums[i] &lt; nums[i + 1]) {
                break;
            } else if (0 == i) {
                // reverse nums if reach maximum
                reverse(nums, 0, nums.size() - 1);
                return nums;
            }
        }
        // step2: find nums[i] &lt; nums[j]
        int j = 0;
        for (j = nums.size() - 1; j &gt; i; --j) {
            if (nums[i] &lt; nums[j]) break;
        }
        // step3: swap betwenn nums[i] and nums[j]
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
        // step4: reverse between [i + 1, n - 1]
        reverse(nums, i + 1, nums.size() - 1);

        return nums;

    }

private:
    void reverse(vector&lt;int&gt;&amp; nums, int start, int end) {
        for (int i = start, j = end; i &lt; j; ++i, --j) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
    }
};
</code></pre>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param nums: an array of integers
     * @return: return nothing (void), do not return anything, modify nums in-place instead
     */
    public void nextPermutation(int[] nums) {
        if (nums == null || nums.length == 0) return;

        // step1: search the first nums[k] &lt; nums[k+1] backward
        int k = -1;
        for (int i = nums.length - 2; i &gt;= 0; i--) {
            if (nums[i] &lt; nums[i + 1]) {
                k = i;
                break;
            }
        }
        // if current rank is the largest, reverse it to smallest, return
        if (k == -1) {
            reverse(nums, 0, nums.length - 1);
            return;
        }

        // step2: search the first nums[k] &lt; nums[l] backward
        int l = nums.length - 1;
        while (l &gt; k &amp;&amp; nums[l] &lt;= nums[k]) l--;

        // step3: swap nums[k] with nums[l]
        int temp = nums[k];
        nums[k] = nums[l];
        nums[l] = temp;

        // step4: reverse between k+1 and nums.length-1;
        reverse(nums, k + 1, nums.length - 1);
    }

    private void reverse(int[] nums, int lb, int ub) {
        for (int i = lb, j = ub; i &lt; j; i++, j--) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>和 Permutation 一小節類似，這裏只需要注意在step 1中<code>i == -1</code>時需要反轉之以獲得最小的序列。對於有重復元素，只要在 step1和 step2中判斷元素大小時不取等號即可。Lintcode 上給的註釋要求（其實是 Leetcode 上的要求）和實際給出的輸出不一樣。</p>
<h3>複雜度分析</h3>
<p>最壞情況下，遍歷兩次原陣列，反轉一次陣列，時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 使用了 temp 臨時變量，空間複雜度可認爲是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Minimum Depth of Binary Tree]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/exhaustive_search/minimum_depth_of_binary_tree.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/exhaustive_search/minimum_depth_of_binary_tree.html">
        </link>
        <updated>2019-11-03T15:42:17Z</updated>
        <summary type="html"><![CDATA[<h1>Minimum Depth of Binary Tree</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">Minimum Depth of Binary Tree | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/minimum-depth-of-binary-tree/">(155) Minimum Depth of Binary Tree</a></li>
</ul>
<pre><code>Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path
from the root node down to the nearest leaf node.

Example
Given a binary tree as follow:

        1

     /     \

   2       3

          /    \

        4      5
The minimum depth is 2
</code></pre><h2>題解</h2>
<p>注意審題，題中的最小深度指的是從根節點到<strong>最近的葉子節點（因為題中的最小深度是the number of nodes，故該葉子節點不能是空節點）</strong>，所以需要單獨處理葉子節點為空的情況。此題使用 DFS 遞迴實現比較簡單。</p>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: An integer.
     */
    public int minDepth(TreeNode root) {
        if (root == null) return 0;

        int leftDepth = minDepth(root.left);
        int rightDepth = minDepth(root.right);

        // current node is not leaf node
        if (root.left == null) {
            return 1 + rightDepth;
        } else if (root.right == null) {
            return 1 + leftDepth;
        }

        return 1 + Math.min(leftDepth, rightDepth);
    }
}
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int depth(TreeNode* n){
        if(!n-&gt;left and !n-&gt;right) return 1;
        if(!n-&gt;left) return 1 + depth(n-&gt;right);
        if(!n-&gt;right) return 1 + depth(n-&gt;left);
        return 1 + min(depth(n-&gt;left), depth(n-&gt;right));
    }
    int minDepth(TreeNode* root) {
        if(!root) return 0;
        return depth(root);
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>建立好遞迴模型即可，左右子節點為空時需要單獨處理。</p>
<h3>複雜度分析</h3>
<p>每個節點遍歷一次，時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 不計函數呼叫堆疊空間的話空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Minimum Depth of Binary Tree</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">Minimum Depth of Binary Tree | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/minimum-depth-of-binary-tree/">(155) Minimum Depth of Binary Tree</a></li>
</ul>
<pre><code>Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path
from the root node down to the nearest leaf node.

Example
Given a binary tree as follow:

        1

     /     \

   2       3

          /    \

        4      5
The minimum depth is 2
</code></pre><h2>題解</h2>
<p>注意審題，題中的最小深度指的是從根節點到<strong>最近的葉子節點（因為題中的最小深度是the number of nodes，故該葉子節點不能是空節點）</strong>，所以需要單獨處理葉子節點為空的情況。此題使用 DFS 遞迴實現比較簡單。</p>
<h3>Java</h3>
<pre><code class="lang-java">/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: An integer.
     */
    public int minDepth(TreeNode root) {
        if (root == null) return 0;

        int leftDepth = minDepth(root.left);
        int rightDepth = minDepth(root.right);

        // current node is not leaf node
        if (root.left == null) {
            return 1 + rightDepth;
        } else if (root.right == null) {
            return 1 + leftDepth;
        }

        return 1 + Math.min(leftDepth, rightDepth);
    }
}
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int depth(TreeNode* n){
        if(!n-&gt;left and !n-&gt;right) return 1;
        if(!n-&gt;left) return 1 + depth(n-&gt;right);
        if(!n-&gt;right) return 1 + depth(n-&gt;left);
        return 1 + min(depth(n-&gt;left), depth(n-&gt;right));
    }
    int minDepth(TreeNode* root) {
        if(!root) return 0;
        return depth(root);
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>建立好遞迴模型即可，左右子節點為空時需要單獨處理。</p>
<h3>複雜度分析</h3>
<p>每個節點遍歷一次，時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 不計函數呼叫堆疊空間的話空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dynamic Programming]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/dynamic_programming/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/dynamic_programming/">
        </link>
        <updated>2019-11-03T15:42:17Z</updated>
        <summary type="html"><![CDATA[<h1>Dynamic Programming - 動態規劃</h1>
<!-- toc -->
<ul>
<li><a href="#單序列dpsequence">單序列(DP_Sequence)</a></li>
<li><a href="#雙序列dptwosequence">雙序列(DP_Two_Sequence)</a><ul>
<li><a href="#reference">Reference</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>動態規劃是一種「分治」的思想，通俗一點來說就是「大事化小，小事化無」的藝術。在將大問題化解爲小問題的「分治」過程中，保存對這些小問題已經處理好的結果，並供後面處理更大規模的問題時直接使用這些結果。嗯，感覺講了和沒講一樣，還是不會使用動規的思想解題...</p>
<p>下面看看知乎上的熊大大對動規比較「正經」的描述。</p>
<blockquote>
<p>動態規劃是通過拆分問題，定義問題狀態和狀態之間的關係，使得問題能夠以遞推（或者說分治）的方式去解決。</p>
</blockquote>
<p>以上定義言簡意賅，可直接用於實戰指導，不愧是參加過NOI的。</p>
<p>動規的思想雖然好理解，但是要真正活用起來就需要下點功夫了。建議看看下面知乎上的回答。</p>
<p>動態規劃最重要的兩個要點：</p>
<ol>
<li>狀態(狀態不太好找，可先從轉化方程入手分析)</li>
<li>狀態間的轉化方程(從題目的隱含條件出發尋找遞推關係)</li>
</ol>
<p>其他的要點則是如初始化狀態的確定(由狀態和轉化方程得知)，需要的結果(狀態轉移的終點)</p>
<p>動態規劃問題中一般從以下四個角度考慮：</p>
<ol>
<li>狀態(State)</li>
<li>狀態間的轉移方程(Function)</li>
<li>狀態的初始化(Initialization)</li>
<li>返回結果(Answer)</li>
</ol>
<p>動規適用的情形：</p>
<ol>
<li>最大值/最小值</li>
<li>有無可行解</li>
<li>求方案個數(如果需要列出所有方案，則一定不是動規，因爲全部方案爲指數級別複雜度，所有方案需要列出時往往用遞歸)</li>
<li>給出的數據不可隨便調整位置</li>
</ol>
<h2>單序列(DP_Sequence)</h2>
<p>單序列動態規劃的狀態通常定義爲：陣列前 i 個位置, 數字, 字母 或者 以第i個爲... 返回結果通常爲陣列的最後一個元素。</p>
<p>按照動態規劃的四要素，此類題可從以下四個角度分析。</p>
<ol>
<li>State: f[i] 前i個位置/數字/字母...</li>
<li>Function: f[i] = f[i-1]... 找遞推關係</li>
<li>Initialization: 根據題意進行必要的初始化</li>
<li>Answer: f[n-1]</li>
</ol>
<h2>雙序列(DP_Two_Sequence)</h2>
<p>一般有兩個陣列或者兩個字符串，計算其匹配關係。雙序列中常用二維陣列表示狀態轉移關係，但往往可以使用滾動陣列的方式對空間複雜度進行優化。舉個例子，以題 <a href="http://algorithm.yuanbin.me/zh-hans/dynamic_programming/distinct_subsequences.html">Distinct Subsequences</a> 爲例，狀態轉移方程如下：</p>
<pre><code>f[i+1][j+1] = f[i][j+1] + f[i][j] (if S[i] == T[j])
f[i+1][j+1] = f[i][j+1] (if S[i] != T[j])
</code></pre><p>從以上轉移方程可以看出 <code>f[i+1][*]</code> 只與其前一個狀態 <code>f[i][*]</code> 有關，而對於 <code>f[*][j]</code> 來說則基於當前索引又與前一個索引有關，故我們以遞推的方式省略第一維的空間，並以第一維作爲外循環，內循環爲 j, 由遞推關係可知在使用滾動陣列時，若內循環 j 仍然從小到大遍歷，那麼對於 <code>f[j+1]</code> 來說它得到的 <code>f[j]</code> 則是當前一輪(<code>f[i+1][j]</code>)的值，並不是需要的 <code>f[i][j]</code> 的值。所以若想得到上一輪的結果，必須在內循環使用逆推的方式進行。文字表述比較模糊，可以自行畫一個二維矩陣的轉移矩陣來分析，認識到這一點非常重要。</p>
<p>小結一下，使用滾動陣列的核心在於：</p>
<ol>
<li>狀態轉移矩陣中只能取 <code>f[i+1][*]</code> 和 <code>f[i][*]</code>, 這是使用滾動陣列的前提。</li>
<li>外循環使用 i, 內循環使用 j 並同時使用逆推，這是滾動陣列使用的具體實踐。</li>
</ol>
<p>程式碼如下：</p>
<pre><code class="lang-java">public class Solution {
    /**
     * @param S, T: Two string.
     * @return: Count the number of distinct subsequences
     */
    public int numDistinct(String S, String T) {
        if (S == null || T == null) return 0;
        if (S.length() &lt; T.length()) return 0;
        if (T.length() == 0) return 1;

        int[] f = new int[T.length() + 1];
        f[0] = 1;
        for (int i = 0; i &lt; S.length(); i++) {
            for (int j = T.length() - 1; j &gt;= 0; j--) {
                if (S.charAt(i) == T.charAt(j)) {
                        f[j + 1] += f[j];
                }
            }
        }

        return f[T.length()];
    }
}
</code></pre>
<p>紙上得來終覺淺，絕知此事要躬行。光說不練假把戲，下面就來幾道DP的題練練手。</p>
<h3>Reference</h3>
<ol>
<li><a href="http://www.zhihu.com/question/23995189">什麼是動態規劃？動態規劃的意義是什麼？ - 知乎</a> - 熊大大和王勐的回答值得細看，適合作爲動態規劃的科普和入門。維基百科上對動態規劃的描述感覺太過學術。</li>
<li><a href="http://www.hawstein.com/posts/dp-novice-to-advanced.html">動態規劃：從新手到專家</a> - Topcoder上的一篇譯作。</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h1>Dynamic Programming - 動態規劃</h1>
<!-- toc -->
<ul>
<li><a href="#單序列dpsequence">單序列(DP_Sequence)</a></li>
<li><a href="#雙序列dptwosequence">雙序列(DP_Two_Sequence)</a><ul>
<li><a href="#reference">Reference</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<p>動態規劃是一種「分治」的思想，通俗一點來說就是「大事化小，小事化無」的藝術。在將大問題化解爲小問題的「分治」過程中，保存對這些小問題已經處理好的結果，並供後面處理更大規模的問題時直接使用這些結果。嗯，感覺講了和沒講一樣，還是不會使用動規的思想解題...</p>
<p>下面看看知乎上的熊大大對動規比較「正經」的描述。</p>
<blockquote>
<p>動態規劃是通過拆分問題，定義問題狀態和狀態之間的關係，使得問題能夠以遞推（或者說分治）的方式去解決。</p>
</blockquote>
<p>以上定義言簡意賅，可直接用於實戰指導，不愧是參加過NOI的。</p>
<p>動規的思想雖然好理解，但是要真正活用起來就需要下點功夫了。建議看看下面知乎上的回答。</p>
<p>動態規劃最重要的兩個要點：</p>
<ol>
<li>狀態(狀態不太好找，可先從轉化方程入手分析)</li>
<li>狀態間的轉化方程(從題目的隱含條件出發尋找遞推關係)</li>
</ol>
<p>其他的要點則是如初始化狀態的確定(由狀態和轉化方程得知)，需要的結果(狀態轉移的終點)</p>
<p>動態規劃問題中一般從以下四個角度考慮：</p>
<ol>
<li>狀態(State)</li>
<li>狀態間的轉移方程(Function)</li>
<li>狀態的初始化(Initialization)</li>
<li>返回結果(Answer)</li>
</ol>
<p>動規適用的情形：</p>
<ol>
<li>最大值/最小值</li>
<li>有無可行解</li>
<li>求方案個數(如果需要列出所有方案，則一定不是動規，因爲全部方案爲指數級別複雜度，所有方案需要列出時往往用遞歸)</li>
<li>給出的數據不可隨便調整位置</li>
</ol>
<h2>單序列(DP_Sequence)</h2>
<p>單序列動態規劃的狀態通常定義爲：陣列前 i 個位置, 數字, 字母 或者 以第i個爲... 返回結果通常爲陣列的最後一個元素。</p>
<p>按照動態規劃的四要素，此類題可從以下四個角度分析。</p>
<ol>
<li>State: f[i] 前i個位置/數字/字母...</li>
<li>Function: f[i] = f[i-1]... 找遞推關係</li>
<li>Initialization: 根據題意進行必要的初始化</li>
<li>Answer: f[n-1]</li>
</ol>
<h2>雙序列(DP_Two_Sequence)</h2>
<p>一般有兩個陣列或者兩個字符串，計算其匹配關係。雙序列中常用二維陣列表示狀態轉移關係，但往往可以使用滾動陣列的方式對空間複雜度進行優化。舉個例子，以題 <a href="http://algorithm.yuanbin.me/zh-hans/dynamic_programming/distinct_subsequences.html">Distinct Subsequences</a> 爲例，狀態轉移方程如下：</p>
<pre><code>f[i+1][j+1] = f[i][j+1] + f[i][j] (if S[i] == T[j])
f[i+1][j+1] = f[i][j+1] (if S[i] != T[j])
</code></pre><p>從以上轉移方程可以看出 <code>f[i+1][*]</code> 只與其前一個狀態 <code>f[i][*]</code> 有關，而對於 <code>f[*][j]</code> 來說則基於當前索引又與前一個索引有關，故我們以遞推的方式省略第一維的空間，並以第一維作爲外循環，內循環爲 j, 由遞推關係可知在使用滾動陣列時，若內循環 j 仍然從小到大遍歷，那麼對於 <code>f[j+1]</code> 來說它得到的 <code>f[j]</code> 則是當前一輪(<code>f[i+1][j]</code>)的值，並不是需要的 <code>f[i][j]</code> 的值。所以若想得到上一輪的結果，必須在內循環使用逆推的方式進行。文字表述比較模糊，可以自行畫一個二維矩陣的轉移矩陣來分析，認識到這一點非常重要。</p>
<p>小結一下，使用滾動陣列的核心在於：</p>
<ol>
<li>狀態轉移矩陣中只能取 <code>f[i+1][*]</code> 和 <code>f[i][*]</code>, 這是使用滾動陣列的前提。</li>
<li>外循環使用 i, 內循環使用 j 並同時使用逆推，這是滾動陣列使用的具體實踐。</li>
</ol>
<p>程式碼如下：</p>
<pre><code class="lang-java">public class Solution {
    /**
     * @param S, T: Two string.
     * @return: Count the number of distinct subsequences
     */
    public int numDistinct(String S, String T) {
        if (S == null || T == null) return 0;
        if (S.length() &lt; T.length()) return 0;
        if (T.length() == 0) return 1;

        int[] f = new int[T.length() + 1];
        f[0] = 1;
        for (int i = 0; i &lt; S.length(); i++) {
            for (int j = T.length() - 1; j &gt;= 0; j--) {
                if (S.charAt(i) == T.charAt(j)) {
                        f[j + 1] += f[j];
                }
            }
        }

        return f[T.length()];
    }
}
</code></pre>
<p>紙上得來終覺淺，絕知此事要躬行。光說不練假把戲，下面就來幾道DP的題練練手。</p>
<h3>Reference</h3>
<ol>
<li><a href="http://www.zhihu.com/question/23995189">什麼是動態規劃？動態規劃的意義是什麼？ - 知乎</a> - 熊大大和王勐的回答值得細看，適合作爲動態規劃的科普和入門。維基百科上對動態規劃的描述感覺太過學術。</li>
<li><a href="http://www.hawstein.com/posts/dp-novice-to-advanced.html">動態規劃：從新手到專家</a> - Topcoder上的一篇譯作。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Triangle]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/dynamic_programming/triangle.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/dynamic_programming/triangle.html">
        </link>
        <updated>2019-11-03T15:42:18Z</updated>
        <summary type="html"><![CDATA[<h1>Triangle - Find the minimum path sum from top to bottom</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#method-1---traverse-without-hashmap">Method 1 - Traverse without hashmap</a></li>
<li><a href="#c-traverse-without-hashmap">C++ Traverse without hashmap</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#method-2---divide-and-conquer-without-hashmap">Method 2 - Divide and Conquer without hashmap</a></li>
<li><a href="#c-divide-and-conquer-without-hashmap">C++ Divide and Conquer without hashmap</a></li>
<li><a href="#method-3---divide-and-conquer-with-hashmap">Method 3 - Divide and Conquer with hashmap</a></li>
<li><a href="#c-divide-and-conquer-with-hashmap">C++ Divide and Conquer with hashmap</a></li>
<li><a href="#method-4---dynamic-programming">Method 4 - Dynamic Programming</a></li>
<li><a href="#c-from-bottom-to-top">C++ From Bottom to Top</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#c-from-top-to-bottom">C++ From Top to Bottom</a><ul>
<li><a href="#源碼解析">源碼解析</a></li>
</ul>
</li>
<li><a href="#java-from-top-to-bottom">Java From Top to Bottom</a><ul>
<li><a href="#源碼解析-1">源碼解析</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/triangle/">(109) Triangle</a></li>
</ul>
<pre><code>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

Note
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.

Example
For example, given the following triangle

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).
</code></pre><h2>題解</h2>
<p>題中要求最短路徑和，每次只能訪問下行的相鄰元素，將triangle視爲二維座標。此題方法較多，下面分小節詳述。</p>
<h3>Method 1 - Traverse without hashmap</h3>
<p>首先考慮最容易想到的方法——遞歸遍歷，逐個累加所有自上而下的路徑長度，最後返回這些不同的路徑長度的最小值。由於每個點往下都有2條路徑，使用此方法的時間複雜度約爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>, 顯然是不可接受的解，不過我們還是先看看其實現思路。</p>
<h3>C++ Traverse without hashmap</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param triangle: a list of lists of integers.
     * @return: An integer, minimum path sum.
     */
    int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) {
        if (triangle.empty()) {
            return -1;
        }

        int result = INT_MAX;
        dfs(0, 0, 0, triangle, result);

        return result;
    }

private:
    void dfs(int x, int y, int sum, vector&lt;vector&lt;int&gt; &gt; &amp;triangle, int &amp;result) {
        const int n = triangle.size();
        if (x == n) {
            if (sum &lt; result) {
                result = sum;
            }
            return;
        }

        dfs(x + 1, y, (sum + triangle[x][y]), triangle, result);
        dfs(x + 1, y + 1, (sum + triangle[x][y]), triangle, result);
    }
};
</code></pre>
<h3>源碼分析</h3>
<p><code>dfs()</code>的循環終止條件爲<code>x == n</code>，而不是<code>x == n - 1</code>，主要是方便在遞歸時sum均可使用<code>sum + triangle[x][y]</code>，而不必根據不同的y和y+1改變，代碼實現相對優雅一些。理解方式則變爲從第x行走到第x+1行時的最短路徑和，也就是說在此之前並不將第x行的元素值計算在內。</p>
<p>這種遍歷的方法時間複雜度如此之高的主要原因是因爲在n較大時遞歸計算了之前已經得到的結果，而這些結果計算一次後即不再變化，可再次利用。因此我們可以使用hashmap記憶已經計算得到的結果從而對其進行優化。</p>
<h3>Method 2 - Divide and Conquer without hashmap</h3>
<p>既然可以使用遞歸遍歷，當然也可以使用「分治」的方法來解。「分治」與之前的遍歷區別在於「分治」需要返回每次「分治」後的計算結果，下面看代碼實現。</p>
<h3>C++ Divide and Conquer without hashmap</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param triangle: a list of lists of integers.
     * @return: An integer, minimum path sum.
     */
    int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) {
        if (triangle.empty()) {
            return -1;
        }

        int result = dfs(0, 0, triangle);

        return result;
    }

private:
    int dfs(int x, int y, vector&lt;vector&lt;int&gt; &gt; &amp;triangle) {
        const int n = triangle.size();
        if (x == n) {
            return 0;
        }

        return min(dfs(x + 1, y, triangle), dfs(x + 1, y + 1, triangle))  + triangle[x][y];
    }
};
</code></pre>
<p>使用「分治」的方法代碼相對簡潔一點，接下來我們使用hashmap保存triangle中不同座標的點計算得到的路徑和。</p>
<h3>Method 3 - Divide and Conquer with hashmap</h3>
<p>新建一份大小和triangle一樣大小的hashmap，並對每個元素賦以<code>INT_MIN</code>以做標記區分。</p>
<h3>C++ Divide and Conquer with hashmap</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param triangle: a list of lists of integers.
     * @return: An integer, minimum path sum.
     */
    int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) {
        if (triangle.empty()) {
            return -1;
        }

        vector&lt;vector&lt;int&gt; &gt; hashmap(triangle);
        for (int i = 0; i != hashmap.size(); ++i) {
            for (int j = 0; j != hashmap[i].size(); ++j) {
                hashmap[i][j] = INT_MIN;
            }
        }
        int result = dfs(0, 0, triangle, hashmap);

        return result;
    }

private:
    int dfs(int x, int y, vector&lt;vector&lt;int&gt; &gt; &amp;triangle, vector&lt;vector&lt;int&gt; &gt; &amp;hashmap) {
        const int n = triangle.size();
        if (x == n) {
            return 0;
        }

        // INT_MIN means no value yet
        if (hashmap[x][y] != INT_MIN) {
            return hashmap[x][y];
        }
        int x1y = dfs(x + 1, y, triangle, hashmap);
        int x1y1 = dfs(x + 1, y + 1, triangle, hashmap);
        hashmap[x][y] =  min(x1y, x1y1) + triangle[x][y];

        return hashmap[x][y];
    }
};
</code></pre>
<p>由於已經計算出的最短路徑值不再重複計算，計算複雜度由之前的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>，變爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>, 每個座標的元素僅計算一次，故共計算的次數爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>n</mi><mo>≈</mo><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">1+2+...+n \approx O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mbin">+</span><span class="mord mathrm">2</span><span class="mbin">+</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mrel">≈</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<h3>Method 4 - Dynamic Programming</h3>
<p>從主章節中對動態規劃的簡介我們可以知道使用動態規劃的難點和核心在於<strong>狀態的定義及轉化方程的建立</strong>。那麼問題來了，到底如何去找適合這個問題的狀態及轉化方程呢？</p>
<p>我們仔細分析題中可能的狀態和轉化關係，發現從<code>triangle</code>中座標爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">triangle[x][y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 的元素出發，其路徑只可能爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>y</mi><mo>]</mo><mo>−</mo><mo>&gt;</mo><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo>[</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">triangle[x][y]-&gt;triangle[x+1][y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mord">−</span><span class="mrel">&gt;</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>y</mi><mo>]</mo><mo>−</mo><mo>&gt;</mo><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo>[</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">triangle[x][y]-&gt;triangle[x+1][y+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mord">−</span><span class="mrel">&gt;</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span>. 以點 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 作爲參考，那麼可能的狀態 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 就可以是：</p>
<ol>
<li>從 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 出發走到最後一行的最短路徑和</li>
<li>從 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathrm">0</span><span class="mclose">)</span></span></span></span> 走到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>的最短路徑和</li>
</ol>
<p>如果選擇1作爲狀態，則相應的狀態轉移方程爲：
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>{</mo><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>}</mo><mo>+</mo><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f_1(x,y) = min\{f_1(x+1, y), f_1(x+1, y+1)\} + triangle[x][y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mopen">{</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mclose">}</span><span class="mbin">+</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span></p>
<p>如果選擇2作爲狀態，則相應的狀態轉移方程爲：
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>{</mo><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>}</mo><mo>+</mo><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f_2(x,y) = min\{f_2(x-1, y), f_2(x-1, y-1)\} + triangle[x][y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mopen">{</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mclose">}</span><span class="mbin">+</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span></p>
<p>兩個狀態所對應的初始狀態分別爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><mn>0</mn><mo>≤</mo><mi>y</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f_1(n-1, y), 0 \leq y \leq n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord mathrm">0</span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mrel">≤</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f_2(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mopen">(</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathrm">0</span><span class="mclose">)</span></span></span></span>. 在代碼中應注意考慮邊界條件。下面分別就這種不同的狀態進行動態規劃。</p>
<h3>C++ From Bottom to Top</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param triangle: a list of lists of integers.
     * @return: An integer, minimum path sum.
     */
    int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) {
        if (triangle.empty()) {
            return -1;
        }

        vector&lt;vector&lt;int&gt; &gt; hashmap(triangle);

        // get the total row number of triangle
        const int N = triangle.size();
        for (int i = 0; i != N; ++i) {
            hashmap[N-1][i] = triangle[N-1][i];
        }

        for (int i = N - 2; i &gt;= 0; --i) {
            for (int j = 0; j &lt; i + 1; ++j) {
                hashmap[i][j] = min(hashmap[i + 1][j], hashmap[i + 1][j + 1]) + triangle[i][j];
            }
        }

        return hashmap[0][0];
    }
};
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>異常處理</li>
<li>使用hashmap保存結果</li>
<li>初始化<code>hashmap[N-1][i]</code>, 由於是自底向上，故初始化時保存最後一行元素</li>
<li>使用自底向上的方式處理循環</li>
<li>最後返回結果hashmap[0][0]</li>
</ol>
<p>從空間利用角度考慮也可直接使用triangle替代hashmap，但是此舉會改變triangle的值，不推薦。</p>
<h3>C++ From Top to Bottom</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param triangle: a list of lists of integers.
     * @return: An integer, minimum path sum.
     */
    int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) {
        if (triangle.empty()) {
            return -1;
        }

        vector&lt;vector&lt;int&gt; &gt; hashmap(triangle);

        // get the total row number of triangle
        const int N = triangle.size();
        //hashmap[0][0] = triangle[0][0];
        for (int i = 1; i != N; ++i) {
            for (int j = 0; j &lt;= i; ++j) {
                if (j == 0) {
                    hashmap[i][j] = hashmap[i - 1][j];
                }
                if (j == i) {
                    hashmap[i][j] = hashmap[i - 1][j - 1];
                }
                if ((j &gt; 0) &amp;&amp; (j &lt; i)) {
                    hashmap[i][j] = min(hashmap[i - 1][j], hashmap[i - 1][j - 1]);
                }
                hashmap[i][j] += triangle[i][j];
            }
        }

        int result = INT_MAX;
        for (int i = 0; i != N; ++i) {
            result = min(result, hashmap[N - 1][i]);
        }
        return result;
    }
};
</code></pre>
<h4>源碼解析</h4>
<p>自頂向下的實現略微有點複雜，在尋路時需要考慮最左邊和最右邊的邊界，還需要在最後返回結果時比較最小值。</p>
<h3>Java From Top to Bottom</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param triangle: a list of lists of integers.
     * @return: An integer, minimum path sum.
     */
    public int minimumTotal(int[][] triangle) {
        // write your code here
        if (triangle == null || triangle.length == 0) return 0;
        int[] last = new int[triangle.length];
        int[] current = new int[triangle.length];
        last[0] = triangle[0][0];
        current[0] = last[0];
        for (int i = 1; i &lt; triangle.length; i++) {
            for (int j = 0; j &lt; i + 1; j++) {
                int sum = Integer.MAX_VALUE;
                if (j != 0) {
                    sum = triangle[i][j] + last[j - 1];
                }
                if (j != i) {
                    sum = Math.min(sum, triangle[i][j] + last[j]);
                }
                current[j] = sum;
            }
            for (int k = 0; k &lt; i + 1; k++) last[k] = current[k];
        }
        int min = Integer.MAX_VALUE;
        for (int n : current) {
            min = Math.min(n, min);
        }
        return min;
    }
}
</code></pre>
<h4>源碼解析</h4>
<p>思路基本和上個解法一樣，但是在數組last中保留上一層的最短和的，因此不用hashmap，空間複雜度是O(n)</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Triangle - Find the minimum path sum from top to bottom</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#method-1---traverse-without-hashmap">Method 1 - Traverse without hashmap</a></li>
<li><a href="#c-traverse-without-hashmap">C++ Traverse without hashmap</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#method-2---divide-and-conquer-without-hashmap">Method 2 - Divide and Conquer without hashmap</a></li>
<li><a href="#c-divide-and-conquer-without-hashmap">C++ Divide and Conquer without hashmap</a></li>
<li><a href="#method-3---divide-and-conquer-with-hashmap">Method 3 - Divide and Conquer with hashmap</a></li>
<li><a href="#c-divide-and-conquer-with-hashmap">C++ Divide and Conquer with hashmap</a></li>
<li><a href="#method-4---dynamic-programming">Method 4 - Dynamic Programming</a></li>
<li><a href="#c-from-bottom-to-top">C++ From Bottom to Top</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#c-from-top-to-bottom">C++ From Top to Bottom</a><ul>
<li><a href="#源碼解析">源碼解析</a></li>
</ul>
</li>
<li><a href="#java-from-top-to-bottom">Java From Top to Bottom</a><ul>
<li><a href="#源碼解析-1">源碼解析</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/triangle/">(109) Triangle</a></li>
</ul>
<pre><code>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

Note
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.

Example
For example, given the following triangle

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).
</code></pre><h2>題解</h2>
<p>題中要求最短路徑和，每次只能訪問下行的相鄰元素，將triangle視爲二維座標。此題方法較多，下面分小節詳述。</p>
<h3>Method 1 - Traverse without hashmap</h3>
<p>首先考慮最容易想到的方法——遞歸遍歷，逐個累加所有自上而下的路徑長度，最後返回這些不同的路徑長度的最小值。由於每個點往下都有2條路徑，使用此方法的時間複雜度約爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>, 顯然是不可接受的解，不過我們還是先看看其實現思路。</p>
<h3>C++ Traverse without hashmap</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param triangle: a list of lists of integers.
     * @return: An integer, minimum path sum.
     */
    int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) {
        if (triangle.empty()) {
            return -1;
        }

        int result = INT_MAX;
        dfs(0, 0, 0, triangle, result);

        return result;
    }

private:
    void dfs(int x, int y, int sum, vector&lt;vector&lt;int&gt; &gt; &amp;triangle, int &amp;result) {
        const int n = triangle.size();
        if (x == n) {
            if (sum &lt; result) {
                result = sum;
            }
            return;
        }

        dfs(x + 1, y, (sum + triangle[x][y]), triangle, result);
        dfs(x + 1, y + 1, (sum + triangle[x][y]), triangle, result);
    }
};
</code></pre>
<h3>源碼分析</h3>
<p><code>dfs()</code>的循環終止條件爲<code>x == n</code>，而不是<code>x == n - 1</code>，主要是方便在遞歸時sum均可使用<code>sum + triangle[x][y]</code>，而不必根據不同的y和y+1改變，代碼實現相對優雅一些。理解方式則變爲從第x行走到第x+1行時的最短路徑和，也就是說在此之前並不將第x行的元素值計算在內。</p>
<p>這種遍歷的方法時間複雜度如此之高的主要原因是因爲在n較大時遞歸計算了之前已經得到的結果，而這些結果計算一次後即不再變化，可再次利用。因此我們可以使用hashmap記憶已經計算得到的結果從而對其進行優化。</p>
<h3>Method 2 - Divide and Conquer without hashmap</h3>
<p>既然可以使用遞歸遍歷，當然也可以使用「分治」的方法來解。「分治」與之前的遍歷區別在於「分治」需要返回每次「分治」後的計算結果，下面看代碼實現。</p>
<h3>C++ Divide and Conquer without hashmap</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param triangle: a list of lists of integers.
     * @return: An integer, minimum path sum.
     */
    int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) {
        if (triangle.empty()) {
            return -1;
        }

        int result = dfs(0, 0, triangle);

        return result;
    }

private:
    int dfs(int x, int y, vector&lt;vector&lt;int&gt; &gt; &amp;triangle) {
        const int n = triangle.size();
        if (x == n) {
            return 0;
        }

        return min(dfs(x + 1, y, triangle), dfs(x + 1, y + 1, triangle))  + triangle[x][y];
    }
};
</code></pre>
<p>使用「分治」的方法代碼相對簡潔一點，接下來我們使用hashmap保存triangle中不同座標的點計算得到的路徑和。</p>
<h3>Method 3 - Divide and Conquer with hashmap</h3>
<p>新建一份大小和triangle一樣大小的hashmap，並對每個元素賦以<code>INT_MIN</code>以做標記區分。</p>
<h3>C++ Divide and Conquer with hashmap</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param triangle: a list of lists of integers.
     * @return: An integer, minimum path sum.
     */
    int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) {
        if (triangle.empty()) {
            return -1;
        }

        vector&lt;vector&lt;int&gt; &gt; hashmap(triangle);
        for (int i = 0; i != hashmap.size(); ++i) {
            for (int j = 0; j != hashmap[i].size(); ++j) {
                hashmap[i][j] = INT_MIN;
            }
        }
        int result = dfs(0, 0, triangle, hashmap);

        return result;
    }

private:
    int dfs(int x, int y, vector&lt;vector&lt;int&gt; &gt; &amp;triangle, vector&lt;vector&lt;int&gt; &gt; &amp;hashmap) {
        const int n = triangle.size();
        if (x == n) {
            return 0;
        }

        // INT_MIN means no value yet
        if (hashmap[x][y] != INT_MIN) {
            return hashmap[x][y];
        }
        int x1y = dfs(x + 1, y, triangle, hashmap);
        int x1y1 = dfs(x + 1, y + 1, triangle, hashmap);
        hashmap[x][y] =  min(x1y, x1y1) + triangle[x][y];

        return hashmap[x][y];
    }
};
</code></pre>
<p>由於已經計算出的最短路徑值不再重複計算，計算複雜度由之前的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>，變爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>, 每個座標的元素僅計算一次，故共計算的次數爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>n</mi><mo>≈</mo><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">1+2+...+n \approx O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mbin">+</span><span class="mord mathrm">2</span><span class="mbin">+</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mrel">≈</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span>.</p>
<h3>Method 4 - Dynamic Programming</h3>
<p>從主章節中對動態規劃的簡介我們可以知道使用動態規劃的難點和核心在於<strong>狀態的定義及轉化方程的建立</strong>。那麼問題來了，到底如何去找適合這個問題的狀態及轉化方程呢？</p>
<p>我們仔細分析題中可能的狀態和轉化關係，發現從<code>triangle</code>中座標爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">triangle[x][y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 的元素出發，其路徑只可能爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>y</mi><mo>]</mo><mo>−</mo><mo>&gt;</mo><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo>[</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">triangle[x][y]-&gt;triangle[x+1][y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mord">−</span><span class="mrel">&gt;</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>y</mi><mo>]</mo><mo>−</mo><mo>&gt;</mo><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo>[</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">triangle[x][y]-&gt;triangle[x+1][y+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mord">−</span><span class="mrel">&gt;</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span>. 以點 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 作爲參考，那麼可能的狀態 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 就可以是：</p>
<ol>
<li>從 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 出發走到最後一行的最短路徑和</li>
<li>從 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathrm">0</span><span class="mclose">)</span></span></span></span> 走到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>的最短路徑和</li>
</ol>
<p>如果選擇1作爲狀態，則相應的狀態轉移方程爲：
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>{</mo><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>}</mo><mo>+</mo><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f_1(x,y) = min\{f_1(x+1, y), f_1(x+1, y+1)\} + triangle[x][y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mopen">{</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mclose">}</span><span class="mbin">+</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span></p>
<p>如果選擇2作爲狀態，則相應的狀態轉移方程爲：
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>{</mo><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>}</mo><mo>+</mo><mi>t</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f_2(x,y) = min\{f_2(x-1, y), f_2(x-1, y-1)\} + triangle[x][y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit">m</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mopen">{</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mclose">}</span><span class="mbin">+</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mopen">[</span><span class="mord mathit">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span></p>
<p>兩個狀態所對應的初始狀態分別爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><mn>0</mn><mo>≤</mo><mi>y</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f_1(n-1, y), 0 \leq y \leq n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord mathrm">0</span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mrel">≤</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f_2(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.10764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mopen">(</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord mathrm">0</span><span class="mclose">)</span></span></span></span>. 在代碼中應注意考慮邊界條件。下面分別就這種不同的狀態進行動態規劃。</p>
<h3>C++ From Bottom to Top</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param triangle: a list of lists of integers.
     * @return: An integer, minimum path sum.
     */
    int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) {
        if (triangle.empty()) {
            return -1;
        }

        vector&lt;vector&lt;int&gt; &gt; hashmap(triangle);

        // get the total row number of triangle
        const int N = triangle.size();
        for (int i = 0; i != N; ++i) {
            hashmap[N-1][i] = triangle[N-1][i];
        }

        for (int i = N - 2; i &gt;= 0; --i) {
            for (int j = 0; j &lt; i + 1; ++j) {
                hashmap[i][j] = min(hashmap[i + 1][j], hashmap[i + 1][j + 1]) + triangle[i][j];
            }
        }

        return hashmap[0][0];
    }
};
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>異常處理</li>
<li>使用hashmap保存結果</li>
<li>初始化<code>hashmap[N-1][i]</code>, 由於是自底向上，故初始化時保存最後一行元素</li>
<li>使用自底向上的方式處理循環</li>
<li>最後返回結果hashmap[0][0]</li>
</ol>
<p>從空間利用角度考慮也可直接使用triangle替代hashmap，但是此舉會改變triangle的值，不推薦。</p>
<h3>C++ From Top to Bottom</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param triangle: a list of lists of integers.
     * @return: An integer, minimum path sum.
     */
    int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) {
        if (triangle.empty()) {
            return -1;
        }

        vector&lt;vector&lt;int&gt; &gt; hashmap(triangle);

        // get the total row number of triangle
        const int N = triangle.size();
        //hashmap[0][0] = triangle[0][0];
        for (int i = 1; i != N; ++i) {
            for (int j = 0; j &lt;= i; ++j) {
                if (j == 0) {
                    hashmap[i][j] = hashmap[i - 1][j];
                }
                if (j == i) {
                    hashmap[i][j] = hashmap[i - 1][j - 1];
                }
                if ((j &gt; 0) &amp;&amp; (j &lt; i)) {
                    hashmap[i][j] = min(hashmap[i - 1][j], hashmap[i - 1][j - 1]);
                }
                hashmap[i][j] += triangle[i][j];
            }
        }

        int result = INT_MAX;
        for (int i = 0; i != N; ++i) {
            result = min(result, hashmap[N - 1][i]);
        }
        return result;
    }
};
</code></pre>
<h4>源碼解析</h4>
<p>自頂向下的實現略微有點複雜，在尋路時需要考慮最左邊和最右邊的邊界，還需要在最後返回結果時比較最小值。</p>
<h3>Java From Top to Bottom</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param triangle: a list of lists of integers.
     * @return: An integer, minimum path sum.
     */
    public int minimumTotal(int[][] triangle) {
        // write your code here
        if (triangle == null || triangle.length == 0) return 0;
        int[] last = new int[triangle.length];
        int[] current = new int[triangle.length];
        last[0] = triangle[0][0];
        current[0] = last[0];
        for (int i = 1; i &lt; triangle.length; i++) {
            for (int j = 0; j &lt; i + 1; j++) {
                int sum = Integer.MAX_VALUE;
                if (j != 0) {
                    sum = triangle[i][j] + last[j - 1];
                }
                if (j != i) {
                    sum = Math.min(sum, triangle[i][j] + last[j]);
                }
                current[j] = sum;
            }
            for (int k = 0; k &lt; i + 1; k++) last[k] = current[k];
        }
        int min = Integer.MAX_VALUE;
        for (int n : current) {
            min = Math.min(n, min);
        }
        return min;
    }
}
</code></pre>
<h4>源碼解析</h4>
<p>思路基本和上個解法一樣，但是在數組last中保留上一層的最短和的，因此不用hashmap，空間複雜度是O(n)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Backpack]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/dynamic_programming/backpack.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/dynamic_programming/backpack.html">
        </link>
        <updated>2019-11-03T15:42:18Z</updated>
        <summary type="html"><![CDATA[<h1>Backpack</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#example">Example</a></li>
<li><a href="#note">Note</a></li>
<li><a href="#challenge">Challenge</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#題解1">題解1</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#題解2">題解2</a><ul>
<li><a href="#c---2d-vector">C++ - 2D vector</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#c---1d-vector">C++ - 1D vector</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/backpack/">(92) Backpack</a></li>
</ul>
<h3>Problem Statement</h3>
<p>Given <em>n</em> items with size <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>, an integer <em>m</em> denotes the size of a backpack.
How full you can fill this backpack?</p>
<h4>Example</h4>
<p>If we have <code>4</code> items with size <code>[2, 3, 5, 7]</code>, the backpack size is 11, we can
select <code>[2, 3, 5]</code>, so that the max size we can fill this backpack is <code>10</code>. If
the backpack size is <code>12</code>. we can select <code>[2, 3, 7]</code> so that we can fulfill
the backpack.</p>
<p>You function should return the max size we can fill in the given backpack.</p>
<h4>Note</h4>
<p>You can not divide any item into small pieces.</p>
<h4>Challenge</h4>
<p>O(n x m) time and O(m) memory.</p>
<p>O(n x m) memory is also acceptable if you do not know how to optimize memory.</p>
<h2>題解1</h2>
<p>本題是典型的01揹包問題，每種類型的物品最多只能選擇一件。參考前文 <a href="http://algorithm.yuanbin.me/zh-hans/basics_algorithm/knapsack.html">Knapsack</a> 中總結的解法，這個題中可以將揹包的 size 理解爲傳統揹包中的重量；題目問的是能達到的最大 size, 故可將每個揹包的 size 類比爲傳統揹包中的價值。</p>
<p>考慮到數組索引從0開始，故定義狀態<code>bp[i + 1][j]</code>爲前 <code>i</code> 個物品中選出重量不超過<code>j</code>時總價值的最大值。狀態轉移方程則爲分<code>A[i] &gt; j</code> 與否兩種情況考慮。初始化均爲0，相當於沒有放任何物品。</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param m: An integer m denotes the size of a backpack
     * @param A: Given n items with size A[i]
     * @return: The maximum size
     */
    public int backPack(int m, int[] A) {
        if (A == null || A.length == 0) return 0;

        final int M = m;
        final int N = A.length;
        int[][] bp = new int[N + 1][M + 1];

        for (int i = 0; i &lt; N; i++) {
            for (int j = 0; j &lt;= M; j++) {
                if (A[i] &gt; j) {
                    bp[i + 1][j] = bp[i][j];
                } else {
                    bp[i + 1][j] = Math.max(bp[i][j], bp[i][j - A[i]] + A[i]);
                }
            }
        }

        return bp[N][M];
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>注意索引及初始化的值，尤其是 N 和 M 的區別，內循環處可等於 M。</p>
<h3>複雜度分析</h3>
<p>兩重 for 循環，時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mbin">×</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 二維矩陣的空間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mbin">×</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 一維矩陣的空間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mclose">)</span></span></span></span>.</p>
<h2>題解2</h2>
<p>接下來看看 <a href="http://www.jiuzhang.com/solutions/backpack/">九章算法</a> 的題解，<strong>這種解法感覺不是很直觀，推薦使用題解1的解法。</strong></p>
<ol>
<li>狀態: result[i][S] 表示前i個物品，取出一些物品能否組成體積和爲S的揹包</li>
<li>狀態轉移方程: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>S</mi><mo>]</mo><mo>=</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>S</mi><mo>−</mo><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mtext> </mtext><mi>o</mi><mi>r</mi><mtext> </mtext><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>S</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][S] = f[i-1][S-A[i]] ~or~ f[i-1][S]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mbin">−</span><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mord mathit"><span class="mspace"> </span><span class="mord mathit">o</span></span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit"><span class="mspace"> </span><span class="mord mathit" style="margin-right:0.10764em;">f</span></span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span> (A[i]爲第i個物品的大小)<ul>
<li>欲從前i個物品中取出一些組成體積和爲S的揹包，可從兩個狀態轉換得到。<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>S</mi><mo>−</mo><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i-1][S-A[i]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mbin">−</span><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span>: <strong>放入第i個物品</strong>，前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span> 個物品能否取出一些體積和爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>−</mo><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">S-A[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mbin">−</span><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span></span></span></span> 的揹包。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>S</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i-1][S]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span>: <strong>不放入第i個物品</strong>，前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span> 個物品能否取出一些組成體積和爲S的揹包。</li>
</ol>
</li>
</ul>
</li>
<li>狀態初始化: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mn>1</mn><mo>⋯</mo><mi>n</mi><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo separator="true">;</mo><mtext> </mtext><mi>f</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>[</mo><mn>1</mn><mo>⋯</mo><mi>m</mi><mo>]</mo><mo>=</mo><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">f[1 \cdots n][0]=true; ~f[0][1 \cdots m]=false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="minner">⋯</span><span class="mord mathit">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathrm">0</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">e</span><span class="mpunct">;</span><span class="mord mathit"><span class="mspace"> </span><span class="mord mathit" style="margin-right:0.10764em;">f</span></span><span class="mopen">[</span><span class="mord mathrm">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="minner">⋯</span><span class="mord mathit">m</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">s</span><span class="mord mathit">e</span></span></span></span>. 前1~n個物品組成體積和爲0的揹包始終爲真，其他情況爲假。</li>
<li>返回結果: 尋找使 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>n</mi><mo>]</mo><mo>[</mo><mi>S</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[n][S]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span> 值爲true的最大S (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>S</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1 \leq S \leq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mrel">≤</span><span class="mord mathit">m</span></span></span></span>)</li>
</ol>
<h3>C++ - 2D vector</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param m: An integer m denotes the size of a backpack
     * @param A: Given n items with size A[i]
     * @return: The maximum size
     */
    int backPack(int m, vector&lt;int&gt; A) {
        if (A.empty() || m &lt; 1) {
            return 0;
        }

        const int N = A.size() + 1;
        const int M = m + 1;
        vector&lt;vector&lt;bool&gt; &gt; result;
        result.resize(N);
        for (vector&lt;int&gt;::size_type i = 0; i != N; ++i) {
            result[i].resize(M);
            std::fill(result[i].begin(), result[i].end(), false);
        }

        result[0][0] = true;
        for (int i = 1; i != N; ++i) {
            for (int j = 0; j != M; ++j) {
                if (j &lt; A[i - 1]) {
                    result[i][j] = result[i - 1][j];
                } else {
                    result[i][j] = result[i - 1][j] || result[i - 1][j - A[i - 1]];
                }
            }
        }

        // return the largest i if true
        for (int i = M; i &gt; 0; --i) {
            if (result[N - 1][i - 1]) {
                return (i - 1);
            }
        }
        return 0;
    }
};
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>異常處理</li>
<li>初始化結果矩陣，注意這裏需要使用<code>resize</code>而不是<code>reserve</code>，否則可能會出現段錯誤</li>
<li>實現狀態轉移邏輯，一定要分<code>j &lt; A[i - 1]</code>與否來討論</li>
<li>返回結果，只需要比較<code>result[N - 1][i - 1]</code>的結果，返回true的最大值</li>
</ol>
<p>狀態轉移邏輯中代碼可以進一步簡化，即：</p>
<pre><code>        for (int i = 1; i != N; ++i) {
            for (int j = 0; j != M; ++j) {
                result[i][j] = result[i - 1][j];
                if (j &gt;= A[i - 1] &amp;&amp; result[i - 1][j - A[i - 1]]) {
                    result[i][j] = true;
                }
            }
        }
</code></pre><p>考慮揹包問題的核心——狀態轉移方程，如何優化此轉移方程？原始方案中用到了二維矩陣來保存result，注意到result的第i行僅依賴於第i-1行的結果，那麼能否用一維數組來代替這種隱含的關係呢？我們<strong>在內循環j處遞減即可</strong>。如此即可避免<code>result[i][S]</code>的值由本輪<code>result[i][S-A[i]]</code>遞推得到。</p>
<h3>C++ - 1D vector</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param m: An integer m denotes the size of a backpack
     * @param A: Given n items with size A[i]
     * @return: The maximum size
     */
    int backPack(int m, vector&lt;int&gt; A) {
        if (A.empty() || m &lt; 1) {
            return 0;
        }

        const int N = A.size();
        vector&lt;bool&gt; result;
        result.resize(m + 1);
        std::fill(result.begin(), result.end(), false);

        result[0] = true;
        for (int i = 0; i != N; ++i) {
            for (int j = m; j &gt;= 0; --j) {
                if (j &gt;= A[i] &amp;&amp; result[j - A[i]]) {
                    result[j] = true;
                }
            }
        }

        // return the largest i if true
        for (int i = m; i &gt; 0; --i) {
            if (result[i]) {
                return i;
            }
        }
        return 0;
    }
};
</code></pre>
<h3>複雜度分析</h3>
<p>兩重 for 循環，時間複雜度均爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mbin">×</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 二維矩陣的空間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mbin">×</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 一維矩陣的空間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li>《挑戰程序設計競賽》第二章</li>
<li><a href="http://www.cnblogs.com/EdwardLiu/p/4269149.html">Lintcode: Backpack - neverlandly - 博客園</a></li>
<li><a href="http://www.jiuzhang.com/problem/58/">九章算法 | 揹包問題</a></li>
<li><a href="http://cuitianyi.com/blog/%E3%80%8A%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B9%9D%E8%AE%B2%E3%80%8B2-0-alpha1/">崔添翼 § 翼若垂天之雲 › 《揹包問題九講》2.0 alpha1</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Backpack</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#example">Example</a></li>
<li><a href="#note">Note</a></li>
<li><a href="#challenge">Challenge</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#題解1">題解1</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#題解2">題解2</a><ul>
<li><a href="#c---2d-vector">C++ - 2D vector</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#c---1d-vector">C++ - 1D vector</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/backpack/">(92) Backpack</a></li>
</ul>
<h3>Problem Statement</h3>
<p>Given <em>n</em> items with size <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span>, an integer <em>m</em> denotes the size of a backpack.
How full you can fill this backpack?</p>
<h4>Example</h4>
<p>If we have <code>4</code> items with size <code>[2, 3, 5, 7]</code>, the backpack size is 11, we can
select <code>[2, 3, 5]</code>, so that the max size we can fill this backpack is <code>10</code>. If
the backpack size is <code>12</code>. we can select <code>[2, 3, 7]</code> so that we can fulfill
the backpack.</p>
<p>You function should return the max size we can fill in the given backpack.</p>
<h4>Note</h4>
<p>You can not divide any item into small pieces.</p>
<h4>Challenge</h4>
<p>O(n x m) time and O(m) memory.</p>
<p>O(n x m) memory is also acceptable if you do not know how to optimize memory.</p>
<h2>題解1</h2>
<p>本題是典型的01揹包問題，每種類型的物品最多只能選擇一件。參考前文 <a href="http://algorithm.yuanbin.me/zh-hans/basics_algorithm/knapsack.html">Knapsack</a> 中總結的解法，這個題中可以將揹包的 size 理解爲傳統揹包中的重量；題目問的是能達到的最大 size, 故可將每個揹包的 size 類比爲傳統揹包中的價值。</p>
<p>考慮到數組索引從0開始，故定義狀態<code>bp[i + 1][j]</code>爲前 <code>i</code> 個物品中選出重量不超過<code>j</code>時總價值的最大值。狀態轉移方程則爲分<code>A[i] &gt; j</code> 與否兩種情況考慮。初始化均爲0，相當於沒有放任何物品。</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param m: An integer m denotes the size of a backpack
     * @param A: Given n items with size A[i]
     * @return: The maximum size
     */
    public int backPack(int m, int[] A) {
        if (A == null || A.length == 0) return 0;

        final int M = m;
        final int N = A.length;
        int[][] bp = new int[N + 1][M + 1];

        for (int i = 0; i &lt; N; i++) {
            for (int j = 0; j &lt;= M; j++) {
                if (A[i] &gt; j) {
                    bp[i + 1][j] = bp[i][j];
                } else {
                    bp[i + 1][j] = Math.max(bp[i][j], bp[i][j - A[i]] + A[i]);
                }
            }
        }

        return bp[N][M];
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>注意索引及初始化的值，尤其是 N 和 M 的區別，內循環處可等於 M。</p>
<h3>複雜度分析</h3>
<p>兩重 for 循環，時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mbin">×</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 二維矩陣的空間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mbin">×</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 一維矩陣的空間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mclose">)</span></span></span></span>.</p>
<h2>題解2</h2>
<p>接下來看看 <a href="http://www.jiuzhang.com/solutions/backpack/">九章算法</a> 的題解，<strong>這種解法感覺不是很直觀，推薦使用題解1的解法。</strong></p>
<ol>
<li>狀態: result[i][S] 表示前i個物品，取出一些物品能否組成體積和爲S的揹包</li>
<li>狀態轉移方程: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>S</mi><mo>]</mo><mo>=</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>S</mi><mo>−</mo><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mtext> </mtext><mi>o</mi><mi>r</mi><mtext> </mtext><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>S</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][S] = f[i-1][S-A[i]] ~or~ f[i-1][S]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mbin">−</span><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mord mathit"><span class="mspace"> </span><span class="mord mathit">o</span></span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit"><span class="mspace"> </span><span class="mord mathit" style="margin-right:0.10764em;">f</span></span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span> (A[i]爲第i個物品的大小)<ul>
<li>欲從前i個物品中取出一些組成體積和爲S的揹包，可從兩個狀態轉換得到。<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>S</mi><mo>−</mo><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i-1][S-A[i]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mbin">−</span><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span>: <strong>放入第i個物品</strong>，前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span> 個物品能否取出一些體積和爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>−</mo><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">S-A[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mbin">−</span><span class="mord mathit">A</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span></span></span></span> 的揹包。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>S</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i-1][S]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span>: <strong>不放入第i個物品</strong>，前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span> 個物品能否取出一些組成體積和爲S的揹包。</li>
</ol>
</li>
</ul>
</li>
<li>狀態初始化: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mn>1</mn><mo>⋯</mo><mi>n</mi><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo separator="true">;</mo><mtext> </mtext><mi>f</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>[</mo><mn>1</mn><mo>⋯</mo><mi>m</mi><mo>]</mo><mo>=</mo><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">f[1 \cdots n][0]=true; ~f[0][1 \cdots m]=false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="minner">⋯</span><span class="mord mathit">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathrm">0</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">e</span><span class="mpunct">;</span><span class="mord mathit"><span class="mspace"> </span><span class="mord mathit" style="margin-right:0.10764em;">f</span></span><span class="mopen">[</span><span class="mord mathrm">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathrm">1</span><span class="minner">⋯</span><span class="mord mathit">m</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">s</span><span class="mord mathit">e</span></span></span></span>. 前1~n個物品組成體積和爲0的揹包始終爲真，其他情況爲假。</li>
<li>返回結果: 尋找使 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>n</mi><mo>]</mo><mo>[</mo><mi>S</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[n][S]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathit">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span> 值爲true的最大S (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>S</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1 \leq S \leq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mrel">≤</span><span class="mord mathit">m</span></span></span></span>)</li>
</ol>
<h3>C++ - 2D vector</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param m: An integer m denotes the size of a backpack
     * @param A: Given n items with size A[i]
     * @return: The maximum size
     */
    int backPack(int m, vector&lt;int&gt; A) {
        if (A.empty() || m &lt; 1) {
            return 0;
        }

        const int N = A.size() + 1;
        const int M = m + 1;
        vector&lt;vector&lt;bool&gt; &gt; result;
        result.resize(N);
        for (vector&lt;int&gt;::size_type i = 0; i != N; ++i) {
            result[i].resize(M);
            std::fill(result[i].begin(), result[i].end(), false);
        }

        result[0][0] = true;
        for (int i = 1; i != N; ++i) {
            for (int j = 0; j != M; ++j) {
                if (j &lt; A[i - 1]) {
                    result[i][j] = result[i - 1][j];
                } else {
                    result[i][j] = result[i - 1][j] || result[i - 1][j - A[i - 1]];
                }
            }
        }

        // return the largest i if true
        for (int i = M; i &gt; 0; --i) {
            if (result[N - 1][i - 1]) {
                return (i - 1);
            }
        }
        return 0;
    }
};
</code></pre>
<h3>源碼分析</h3>
<ol>
<li>異常處理</li>
<li>初始化結果矩陣，注意這裏需要使用<code>resize</code>而不是<code>reserve</code>，否則可能會出現段錯誤</li>
<li>實現狀態轉移邏輯，一定要分<code>j &lt; A[i - 1]</code>與否來討論</li>
<li>返回結果，只需要比較<code>result[N - 1][i - 1]</code>的結果，返回true的最大值</li>
</ol>
<p>狀態轉移邏輯中代碼可以進一步簡化，即：</p>
<pre><code>        for (int i = 1; i != N; ++i) {
            for (int j = 0; j != M; ++j) {
                result[i][j] = result[i - 1][j];
                if (j &gt;= A[i - 1] &amp;&amp; result[i - 1][j - A[i - 1]]) {
                    result[i][j] = true;
                }
            }
        }
</code></pre><p>考慮揹包問題的核心——狀態轉移方程，如何優化此轉移方程？原始方案中用到了二維矩陣來保存result，注意到result的第i行僅依賴於第i-1行的結果，那麼能否用一維數組來代替這種隱含的關係呢？我們<strong>在內循環j處遞減即可</strong>。如此即可避免<code>result[i][S]</code>的值由本輪<code>result[i][S-A[i]]</code>遞推得到。</p>
<h3>C++ - 1D vector</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param m: An integer m denotes the size of a backpack
     * @param A: Given n items with size A[i]
     * @return: The maximum size
     */
    int backPack(int m, vector&lt;int&gt; A) {
        if (A.empty() || m &lt; 1) {
            return 0;
        }

        const int N = A.size();
        vector&lt;bool&gt; result;
        result.resize(m + 1);
        std::fill(result.begin(), result.end(), false);

        result[0] = true;
        for (int i = 0; i != N; ++i) {
            for (int j = m; j &gt;= 0; --j) {
                if (j &gt;= A[i] &amp;&amp; result[j - A[i]]) {
                    result[j] = true;
                }
            }
        }

        // return the largest i if true
        for (int i = m; i &gt; 0; --i) {
            if (result[i]) {
                return i;
            }
        }
        return 0;
    }
};
</code></pre>
<h3>複雜度分析</h3>
<p>兩重 for 循環，時間複雜度均爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mbin">×</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 二維矩陣的空間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m \times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mbin">×</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 一維矩陣的空間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mclose">)</span></span></span></span>.</p>
<h2>Reference</h2>
<ul>
<li>《挑戰程序設計競賽》第二章</li>
<li><a href="http://www.cnblogs.com/EdwardLiu/p/4269149.html">Lintcode: Backpack - neverlandly - 博客園</a></li>
<li><a href="http://www.jiuzhang.com/problem/58/">九章算法 | 揹包問題</a></li>
<li><a href="http://cuitianyi.com/blog/%E3%80%8A%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B9%9D%E8%AE%B2%E3%80%8B2-0-alpha1/">崔添翼 § 翼若垂天之雲 › 《揹包問題九講》2.0 alpha1</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Climbing Stairs]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/dynamic_programming/climbing_stairs.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/dynamic_programming/climbing_stairs.html">
        </link>
        <updated>2019-11-03T15:42:18Z</updated>
        <summary type="html"><![CDATA[<h1>Climbing Stairs</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#c-1">C++</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/climbing-stairs/">(111) Climbing Stairs</a></li>
</ul>
<pre><code>You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps.
In how many distinct ways can you climb to the top?

Example
Given an example n=3 , 1+1+1=2+1=1+2=3

return 3
</code></pre><h2>題解</h2>
<p>題目問的是到達頂端的方法數，我們採用序列類問題的通用分析方法，可以得到如下四要素：</p>
<ol>
<li>State: f[i] 爬到第i級的方法數</li>
<li>Function: f[i]=f[i-1]+f[i-2]</li>
<li>Initialization: f[0]=1,f[1]=1</li>
<li>Answer: f[n]</li>
</ol>
<p>尤其注意狀態轉移方程的寫法，f[i]只可能由兩個中間狀態轉化而來，一個是f[i-1]，由f[i-1]到f[i]其方法總數並未增加；另一個是f[i-2]，由f[i-2]到f[i]隔了兩個臺階，因此有1+1和2兩個方法，因此容易寫成 f[i]=f[i-1]+f[i-2]+1，但仔細分析後能發現，由f[i-2]到f[i]的中間狀態f[i-1]已經被利用過一次，故f[i]=f[i-1]+f[i-2]. 使用動規思想解題時需要分清『重疊子狀態』, 如果有重複的需要去掉。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param n: An integer
     * @return: An integer
     */
    int climbStairs(int n) {
        if (n &lt; 1) {
            return 0;
        }

        vector&lt;int&gt; ret(n + 1, 1);

        for (int i = 2; i != n + 1; ++i) {
            ret[i] = ret[i - 1] + ret[i - 2];
        }

        return ret[n];
    }
};
</code></pre>
<ol>
<li>異常處理</li>
<li>初始化n+1個元素，初始值均爲1。之所以用n+1個元素是下標分析起來更方便</li>
<li>狀態轉移方程</li>
<li>返回ret[n]</li>
</ol>
<p>初始化ret[0]也爲1，可以認爲到第0級也是一種方法。</p>
<p>以上答案的空間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>，仔細觀察後可以發現在狀態轉移方程中，我們可以使用三個變數來替代長度爲n+1的數組。具體程式碼可參考 <a href="http://www.jiuzhang.com/solutions/climbing-stairs/">climbing-stairs | 九章算法 </a></p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    def climbStairs(n):
        if n &lt; 1:
            return 0

        l = r = 1
        for _ in xrange(n - 1):
            l, r = r, r + l
        return r
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param n: An integer
     * @return: An integer
     */
    int climbStairs(int n) {
        if (n &lt; 1) {
            return 0;
        }

        int ret0 = 1, ret1 = 1, ret2 = 1;

        for (int i = 2; i != n + 1; ++i) {
            ret0 = ret1 + ret2;
            ret2 = ret1;
            ret1 = ret0;
        }

        return ret0;
    }
};
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1>Climbing Stairs</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#c">C++</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#c-1">C++</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/climbing-stairs/">(111) Climbing Stairs</a></li>
</ul>
<pre><code>You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps.
In how many distinct ways can you climb to the top?

Example
Given an example n=3 , 1+1+1=2+1=1+2=3

return 3
</code></pre><h2>題解</h2>
<p>題目問的是到達頂端的方法數，我們採用序列類問題的通用分析方法，可以得到如下四要素：</p>
<ol>
<li>State: f[i] 爬到第i級的方法數</li>
<li>Function: f[i]=f[i-1]+f[i-2]</li>
<li>Initialization: f[0]=1,f[1]=1</li>
<li>Answer: f[n]</li>
</ol>
<p>尤其注意狀態轉移方程的寫法，f[i]只可能由兩個中間狀態轉化而來，一個是f[i-1]，由f[i-1]到f[i]其方法總數並未增加；另一個是f[i-2]，由f[i-2]到f[i]隔了兩個臺階，因此有1+1和2兩個方法，因此容易寫成 f[i]=f[i-1]+f[i-2]+1，但仔細分析後能發現，由f[i-2]到f[i]的中間狀態f[i-1]已經被利用過一次，故f[i]=f[i-1]+f[i-2]. 使用動規思想解題時需要分清『重疊子狀態』, 如果有重複的需要去掉。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param n: An integer
     * @return: An integer
     */
    int climbStairs(int n) {
        if (n &lt; 1) {
            return 0;
        }

        vector&lt;int&gt; ret(n + 1, 1);

        for (int i = 2; i != n + 1; ++i) {
            ret[i] = ret[i - 1] + ret[i - 2];
        }

        return ret[n];
    }
};
</code></pre>
<ol>
<li>異常處理</li>
<li>初始化n+1個元素，初始值均爲1。之所以用n+1個元素是下標分析起來更方便</li>
<li>狀態轉移方程</li>
<li>返回ret[n]</li>
</ol>
<p>初始化ret[0]也爲1，可以認爲到第0級也是一種方法。</p>
<p>以上答案的空間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>，仔細觀察後可以發現在狀態轉移方程中，我們可以使用三個變數來替代長度爲n+1的數組。具體程式碼可參考 <a href="http://www.jiuzhang.com/solutions/climbing-stairs/">climbing-stairs | 九章算法 </a></p>
<h3>Python</h3>
<pre><code class="lang-python">class Solution:
    def climbStairs(n):
        if n &lt; 1:
            return 0

        l = r = 1
        for _ in xrange(n - 1):
            l, r = r, r + l
        return r
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    /**
     * @param n: An integer
     * @return: An integer
     */
    int climbStairs(int n) {
        if (n &lt; 1) {
            return 0;
        }

        int ret0 = 1, ret1 = 1, ret2 = 1;

        for (int i = 2; i != n + 1; ++i) {
            ret0 = ret1 + ret2;
            ret2 = ret1;
            ret1 = ret0;
        }

        return ret0;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Graph]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/graph/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/graph/">
        </link>
        <updated>2019-11-03T15:42:18Z</updated>
        <summary type="html"><![CDATA[<h1>Graph</h1>
<p>本章主要總結圖與搜索相關題目。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Graph</h1>
<p>本章主要總結圖與搜索相關題目。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Data Structure]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/data_structure/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/data_structure/">
        </link>
        <updated>2019-11-03T15:42:19Z</updated>
        <summary type="html"><![CDATA[<h1>Data Structure</h1>
<p>本章主要總結如 Queue, Stack 等資料結構相關的題目。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Data Structure</h1>
<p>本章主要總結如 Queue, Stack 等資料結構相關的題目。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Problem Misc]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/problem_misc/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/problem_misc/">
        </link>
        <updated>2019-11-03T15:42:19Z</updated>
        <summary type="html"><![CDATA[<h1>Problem Misc</h1>
<p>本章主要總結暫時不方便歸到其他章節的題目。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Problem Misc</h1>
<p>本章主要總結暫時不方便歸到其他章節的題目。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[String to Integer]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/problem_misc/string_to_integer.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/problem_misc/string_to_integer.html">
        </link>
        <updated>2019-11-03T15:42:19Z</updated>
        <summary type="html"><![CDATA[<h1>String to Integer</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/string-to-integer-atoi/">String to Integer (atoi) | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/string-to-integeratoi/">(54) String to Integer(atoi)</a></li>
</ul>
<pre><code>Implement function atoi to convert a string to an integer.

If no valid conversion could be performed, a zero value is returned.

If the correct value is out of the range of representable values,
INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.

Example
&quot;10&quot; =&gt; 10

&quot;-1&quot; =&gt; -1

&quot;123123123123123&quot; =&gt; 2147483647

&quot;1.0&quot; =&gt; 1
</code></pre><h2>題解</h2>
<p>經典的字符串轉整數題，邊界條件比較多，比如是否需要考慮小數點，空白及非法字符的處理，正負號的處理，科學計數法等。最先處理的是空白字符，然後是正負號，接下來只要出現非法字符(包含正負號，小數點等，無需對這兩類單獨處理)即退出，否則按照正負號的整數進位加法處理。</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param str: A string
     * @return An integer
     */
    public int atoi(String str) {
        if (str == null || str.length() == 0) return 0;

        // trim left and right spaces
        String strTrim = str.trim();
        int len = strTrim.length();
        // sign symbol for positive and negative
        int sign = 1;
        // index for iteration
        int i = 0;
        if (strTrim.charAt(i) == &#39;+&#39;) {
            i++;
        } else if (strTrim.charAt(i) == &#39;-&#39;) {
            sign = -1;
            i++;
        }

        // store the result as long to avoid overflow
        long result = 0;
        while (i &lt; len) {
            if (strTrim.charAt(i) &lt; &#39;0&#39; || strTrim.charAt(i) &gt; &#39;9&#39;) {
                break;
            }
            result = 10 * result + sign * (strTrim.charAt(i) - &#39;0&#39;);
            // overflow
            if (result &gt; Integer.MAX_VALUE) {
                return Integer.MAX_VALUE;
            } else if (result &lt; Integer.MIN_VALUE) {
                return Integer.MIN_VALUE;
            }
            i++;
        }

        return (int)result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>符號位使用整數型表示，便於後期相乘相加。在 while 循環中需要注意判斷是否已經溢位，如果放在 while 循環外面則有可能超過 long 型範圍。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    bool overflow(string str, string help){
        if(str.size() &gt; help.size()) return true;
        else if(str.size() &lt; help.size()) return false;
        for(int i = 0; i &lt; str.size(); i++){
            if(str[i] &gt; help[i]) return true;
            else if(str[i] &lt; help[i]) return false;
        }
        return false;
    }
    int myAtoi(string str) {
        // ans: number, sign: +1 or -1
        int ans = 0;
        int sign = 1;
        int i = 0;
        int N = str.size();

        // eliminate spaces
        while(i &lt; N){
            if(isspace(str[i]))
                i++;
            else
                break;
        }

        // if the whole string contains only spaces, return
        if(i == N) return ans;


        if(str[i] == &#39;+&#39;) 
            i++;
        else if(str[i] == &#39;-&#39;){
            sign = -1;
            i++;
        }

        // &quot;help&quot; gets the string of valid numbers
        string help;
        while(i &lt; N){
            if(&#39;0&#39; &lt;= str[i] and str[i] &lt;= &#39;9&#39;)
                help += str[i++];
            else
                break;
        }

        const string maxINT = &quot;2147483647&quot;;
        const string minINT = &quot;2147483648&quot;;

        // test whether overflow, test only number parts with both signs

        if(sign == 1){
            if(overflow(help, maxINT)) return INT_MAX;
        }
        else{
            if(overflow(help, minINT)) return INT_MIN;
        }

        for(int j=0; j&lt;help.size(); j++){
            ans = 10 * ans + int(help[j] - &#39;0&#39;);
        }

        return ans*sign;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>C++解法並沒有假設任何內建的string演算法，因此也適合使用在純C語言的字元陣列上，此外溢位的判斷直接使用字串用一個輔助函數比大小，這樣如果面試官要求改成string to long 也有辦法應付，不過此方法會變成machine-dependent，嚴格來說還需要寫一個輔助小函數把<code>INT_MAX</code>和<code>INT_MIN</code>轉換成字串來使用，這邊就先省略了，有興趣的同學可以自己嘗試練習。</p>
<h3>複雜度分析</h3>
<p>略</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.jiuzhang.com/solutions/string-to-integer-atoi/">String to Integer (atoi) 參考程序 Java/C++/Python</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>String to Integer</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/string-to-integer-atoi/">String to Integer (atoi) | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/string-to-integeratoi/">(54) String to Integer(atoi)</a></li>
</ul>
<pre><code>Implement function atoi to convert a string to an integer.

If no valid conversion could be performed, a zero value is returned.

If the correct value is out of the range of representable values,
INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.

Example
&quot;10&quot; =&gt; 10

&quot;-1&quot; =&gt; -1

&quot;123123123123123&quot; =&gt; 2147483647

&quot;1.0&quot; =&gt; 1
</code></pre><h2>題解</h2>
<p>經典的字符串轉整數題，邊界條件比較多，比如是否需要考慮小數點，空白及非法字符的處理，正負號的處理，科學計數法等。最先處理的是空白字符，然後是正負號，接下來只要出現非法字符(包含正負號，小數點等，無需對這兩類單獨處理)即退出，否則按照正負號的整數進位加法處理。</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param str: A string
     * @return An integer
     */
    public int atoi(String str) {
        if (str == null || str.length() == 0) return 0;

        // trim left and right spaces
        String strTrim = str.trim();
        int len = strTrim.length();
        // sign symbol for positive and negative
        int sign = 1;
        // index for iteration
        int i = 0;
        if (strTrim.charAt(i) == &#39;+&#39;) {
            i++;
        } else if (strTrim.charAt(i) == &#39;-&#39;) {
            sign = -1;
            i++;
        }

        // store the result as long to avoid overflow
        long result = 0;
        while (i &lt; len) {
            if (strTrim.charAt(i) &lt; &#39;0&#39; || strTrim.charAt(i) &gt; &#39;9&#39;) {
                break;
            }
            result = 10 * result + sign * (strTrim.charAt(i) - &#39;0&#39;);
            // overflow
            if (result &gt; Integer.MAX_VALUE) {
                return Integer.MAX_VALUE;
            } else if (result &lt; Integer.MIN_VALUE) {
                return Integer.MIN_VALUE;
            }
            i++;
        }

        return (int)result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>符號位使用整數型表示，便於後期相乘相加。在 while 循環中需要注意判斷是否已經溢位，如果放在 while 循環外面則有可能超過 long 型範圍。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    bool overflow(string str, string help){
        if(str.size() &gt; help.size()) return true;
        else if(str.size() &lt; help.size()) return false;
        for(int i = 0; i &lt; str.size(); i++){
            if(str[i] &gt; help[i]) return true;
            else if(str[i] &lt; help[i]) return false;
        }
        return false;
    }
    int myAtoi(string str) {
        // ans: number, sign: +1 or -1
        int ans = 0;
        int sign = 1;
        int i = 0;
        int N = str.size();

        // eliminate spaces
        while(i &lt; N){
            if(isspace(str[i]))
                i++;
            else
                break;
        }

        // if the whole string contains only spaces, return
        if(i == N) return ans;


        if(str[i] == &#39;+&#39;) 
            i++;
        else if(str[i] == &#39;-&#39;){
            sign = -1;
            i++;
        }

        // &quot;help&quot; gets the string of valid numbers
        string help;
        while(i &lt; N){
            if(&#39;0&#39; &lt;= str[i] and str[i] &lt;= &#39;9&#39;)
                help += str[i++];
            else
                break;
        }

        const string maxINT = &quot;2147483647&quot;;
        const string minINT = &quot;2147483648&quot;;

        // test whether overflow, test only number parts with both signs

        if(sign == 1){
            if(overflow(help, maxINT)) return INT_MAX;
        }
        else{
            if(overflow(help, minINT)) return INT_MIN;
        }

        for(int j=0; j&lt;help.size(); j++){
            ans = 10 * ans + int(help[j] - &#39;0&#39;);
        }

        return ans*sign;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>C++解法並沒有假設任何內建的string演算法，因此也適合使用在純C語言的字元陣列上，此外溢位的判斷直接使用字串用一個輔助函數比大小，這樣如果面試官要求改成string to long 也有辦法應付，不過此方法會變成machine-dependent，嚴格來說還需要寫一個輔助小函數把<code>INT_MAX</code>和<code>INT_MIN</code>轉換成字串來使用，這邊就先省略了，有興趣的同學可以自己嘗試練習。</p>
<h3>複雜度分析</h3>
<p>略</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.jiuzhang.com/solutions/string-to-integer-atoi/">String to Integer (atoi) 參考程序 Java/C++/Python</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Minimum Subarray]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/problem_misc/minimum_subarray.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/problem_misc/minimum_subarray.html">
        </link>
        <updated>2019-11-03T15:42:19Z</updated>
        <summary type="html"><![CDATA[<h1>Minimum Subarray</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/minimum-subarray/">(44) Minimum Subarray</a></li>
</ul>
<pre><code>Given an array of integers, find the subarray with smallest sum.

Return the sum of the subarray.

Example
For [1, -1, -2, 1], return -3

Note
The subarray should contain at least one integer.
</code></pre><h2>題解</h2>
<p>題目 <a href="http://algorithm.yuanbin.me/zh-hans/dynamic_programming/maximum_subarray.html">Maximum Subarray</a> 的變形，使用區間和容易理解和實現。</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param nums: a list of integers
     * @return: A integer indicate the sum of minimum subarray
     */
    public int minSubArray(ArrayList&lt;Integer&gt; nums) {
        if (nums == null || nums.isEmpty()) return -1;

        int sum = 0, maxSum = 0, minSub = Integer.MAX_VALUE;
        for (int num : nums) {
            maxSum = Math.max(maxSum, sum);
            sum += num;
            minSub = Math.min(minSub, sum - maxSum);
        }

        return minSub;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>略</p>
<h3>複雜度分析</h3>
<p>略</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Minimum Subarray</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/minimum-subarray/">(44) Minimum Subarray</a></li>
</ul>
<pre><code>Given an array of integers, find the subarray with smallest sum.

Return the sum of the subarray.

Example
For [1, -1, -2, 1], return -3

Note
The subarray should contain at least one integer.
</code></pre><h2>題解</h2>
<p>題目 <a href="http://algorithm.yuanbin.me/zh-hans/dynamic_programming/maximum_subarray.html">Maximum Subarray</a> 的變形，使用區間和容易理解和實現。</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param nums: a list of integers
     * @return: A integer indicate the sum of minimum subarray
     */
    public int minSubArray(ArrayList&lt;Integer&gt; nums) {
        if (nums == null || nums.isEmpty()) return -1;

        int sum = 0, maxSum = 0, minSub = Integer.MAX_VALUE;
        for (int num : nums) {
            maxSum = Math.max(maxSum, sum);
            sum += num;
            minSub = Math.min(minSub, sum - maxSum);
        }

        return minSub;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>略</p>
<h3>複雜度分析</h3>
<p>略</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Valid Sudoku]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/problem_misc/valid_sudoku.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/problem_misc/valid_sudoku.html">
        </link>
        <updated>2019-11-03T15:42:20Z</updated>
        <summary type="html"><![CDATA[<h1>Valid Sudoku</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/valid-sudoku/">Valid Sudoku | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/valid-sudoku/">(389) Valid Sudoku</a></li>
</ul>
<pre><code>Determine whether a Sudoku is valid.

The Sudoku board could be partially filled,
where empty cells are filled with the character ..

Example
The following partially filed sudoku is valid.
</code></pre><p><img src="../../shared-files/images/valid-sudoku.png" alt="valid-sudoku.png"></p>
<pre><code>Valid Sudoku

Note
A valid Sudoku board (partially filled) is not necessarily solvable.
Only the filled cells need to be validated.
Clarification
What is Sudoku?

http://sudoku.com.au/TheRules.aspx
https://zh.wikipedia.org/wiki/%E6%95%B8%E7%8D%A8
https://en.wikipedia.org/wiki/Sudoku
http://baike.baidu.com/subview/961/10842669.htm
</code></pre><h2>題解</h2>
<p>看懂數獨的含義就好了，分為三點考慮，一是每行無重複數字；二是每列無重複數字；三是小的九宮格中無重複數字。</p>
<h3>Java</h3>
<pre><code class="lang-java">class Solution {
    /**
      * @param board: the board
        @return: wether the Sudoku is valid
      */
    public boolean isValidSudoku(char[][] board) {
        if (board == null || board.length == 0) return false;

        // check row
        for (int i = 0; i &lt; 9; i++) {
            boolean[] numUsed = new boolean[9];
            for (int j = 0; j &lt; 9; j++) {
                if (isDuplicate(board[i][j], numUsed)) {
                    return false;
                }
            }
        }

        // check column
        for (int i = 0; i &lt; 9; i++) {
            boolean[] numUsed = new boolean[9];
            for (int j = 0; j &lt; 9; j++) {
                if (isDuplicate(board[j][i], numUsed)) {
                    return false;
                }
            }
        }

        // check sub box
        for (int i = 0; i &lt; 9; i = i + 3) {
            for (int j = 0; j &lt; 9; j = j + 3) {
                if (!isValidBox(board, i, j)) {
                    return false;
                }
            }
        }

        return true;
    }

    private boolean isValidBox(char[][] box, int x, int y) {
        boolean[] numUsed = new boolean[9];
        for (int i = x; i &lt; x + 3; i++) {
            for (int j = y; j &lt; y + 3; j++) {
                if (isDuplicate(box[i][j], numUsed)) {
                    return false;
                }
            }
        }
        return true;
    }

    private boolean isDuplicate(char c, boolean[] numUsed) {
        if (c == &#39;.&#39;) {
            return false;
        } else if (numUsed[c - &#39;1&#39;]) {
            return true;
        } else {
            numUsed[c - &#39;1&#39;] = true;
            return false;
        }
    }
}
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    bool isValidBlock(vector&lt;int&gt;&amp; v){
        bool ans = true;
        for(int i = 0; i &lt; v.size(); i++){
            if(v[i] &gt; 1)
                ans = false;
            v[i] = 0;
        }
        return ans;
    }
    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        vector&lt;int&gt; num(9, 0);

        //row
        for(int i=0; i&lt;9; i++){
            for(int j=0; j&lt;9; j++){
                char n = board[i][j];
                if(&#39;1&#39; &lt;= n and n &lt;= &#39;9&#39;)
                    num[n - &#39;1&#39;] ++;
            }

            if(!isValidBlock(num))
                return false;
        }

        //col

        for(int j=0; j&lt;9; j++){
            for(int i=0; i&lt;9; i++){
                char n = board[i][j];
                if(&#39;1&#39; &lt;= n and n &lt;= &#39;9&#39;)
                    num[n - &#39;1&#39;]++;
            }
            if(!isValidBlock(num))
                return false;
        }

        //block

        for(int row = 0; row &lt; 3; row++){
            for(int col = 0; col &lt; 3; col++){
                for(int i = 0; i &lt; 3; i++){
                    for(int j = 0; j &lt; 3; j++){
                        char n = board[3*row +i][3*col+j];
                        if(&#39;1&#39; &lt;= n and  n &lt;= &#39;9&#39;)
                            num[n - &#39;1&#39;]++;
                    }
                }
                if(!isValidBlock(num))
                    return false;
            }
        }
        return true;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>首先實現兩個小的子功能模塊判斷是否有重複和小的九宮格是否重複。</p>
<h3>複雜度分析</h3>
<p>略</p>
<h2>Reference</h2>
<ul>
<li>Soulmachine 的 leetcode 題解</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Valid Sudoku</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/valid-sudoku/">Valid Sudoku | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/valid-sudoku/">(389) Valid Sudoku</a></li>
</ul>
<pre><code>Determine whether a Sudoku is valid.

The Sudoku board could be partially filled,
where empty cells are filled with the character ..

Example
The following partially filed sudoku is valid.
</code></pre><p><img src="../../shared-files/images/valid-sudoku.png" alt="valid-sudoku.png"></p>
<pre><code>Valid Sudoku

Note
A valid Sudoku board (partially filled) is not necessarily solvable.
Only the filled cells need to be validated.
Clarification
What is Sudoku?

http://sudoku.com.au/TheRules.aspx
https://zh.wikipedia.org/wiki/%E6%95%B8%E7%8D%A8
https://en.wikipedia.org/wiki/Sudoku
http://baike.baidu.com/subview/961/10842669.htm
</code></pre><h2>題解</h2>
<p>看懂數獨的含義就好了，分為三點考慮，一是每行無重複數字；二是每列無重複數字；三是小的九宮格中無重複數字。</p>
<h3>Java</h3>
<pre><code class="lang-java">class Solution {
    /**
      * @param board: the board
        @return: wether the Sudoku is valid
      */
    public boolean isValidSudoku(char[][] board) {
        if (board == null || board.length == 0) return false;

        // check row
        for (int i = 0; i &lt; 9; i++) {
            boolean[] numUsed = new boolean[9];
            for (int j = 0; j &lt; 9; j++) {
                if (isDuplicate(board[i][j], numUsed)) {
                    return false;
                }
            }
        }

        // check column
        for (int i = 0; i &lt; 9; i++) {
            boolean[] numUsed = new boolean[9];
            for (int j = 0; j &lt; 9; j++) {
                if (isDuplicate(board[j][i], numUsed)) {
                    return false;
                }
            }
        }

        // check sub box
        for (int i = 0; i &lt; 9; i = i + 3) {
            for (int j = 0; j &lt; 9; j = j + 3) {
                if (!isValidBox(board, i, j)) {
                    return false;
                }
            }
        }

        return true;
    }

    private boolean isValidBox(char[][] box, int x, int y) {
        boolean[] numUsed = new boolean[9];
        for (int i = x; i &lt; x + 3; i++) {
            for (int j = y; j &lt; y + 3; j++) {
                if (isDuplicate(box[i][j], numUsed)) {
                    return false;
                }
            }
        }
        return true;
    }

    private boolean isDuplicate(char c, boolean[] numUsed) {
        if (c == &#39;.&#39;) {
            return false;
        } else if (numUsed[c - &#39;1&#39;]) {
            return true;
        } else {
            numUsed[c - &#39;1&#39;] = true;
            return false;
        }
    }
}
</code></pre>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    bool isValidBlock(vector&lt;int&gt;&amp; v){
        bool ans = true;
        for(int i = 0; i &lt; v.size(); i++){
            if(v[i] &gt; 1)
                ans = false;
            v[i] = 0;
        }
        return ans;
    }
    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        vector&lt;int&gt; num(9, 0);

        //row
        for(int i=0; i&lt;9; i++){
            for(int j=0; j&lt;9; j++){
                char n = board[i][j];
                if(&#39;1&#39; &lt;= n and n &lt;= &#39;9&#39;)
                    num[n - &#39;1&#39;] ++;
            }

            if(!isValidBlock(num))
                return false;
        }

        //col

        for(int j=0; j&lt;9; j++){
            for(int i=0; i&lt;9; i++){
                char n = board[i][j];
                if(&#39;1&#39; &lt;= n and n &lt;= &#39;9&#39;)
                    num[n - &#39;1&#39;]++;
            }
            if(!isValidBlock(num))
                return false;
        }

        //block

        for(int row = 0; row &lt; 3; row++){
            for(int col = 0; col &lt; 3; col++){
                for(int i = 0; i &lt; 3; i++){
                    for(int j = 0; j &lt; 3; j++){
                        char n = board[3*row +i][3*col+j];
                        if(&#39;1&#39; &lt;= n and  n &lt;= &#39;9&#39;)
                            num[n - &#39;1&#39;]++;
                    }
                }
                if(!isValidBlock(num))
                    return false;
            }
        }
        return true;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>首先實現兩個小的子功能模塊判斷是否有重複和小的九宮格是否重複。</p>
<h3>複雜度分析</h3>
<p>略</p>
<h2>Reference</h2>
<ul>
<li>Soulmachine 的 leetcode 題解</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Add Binary]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/problem_misc/add_binary.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/problem_misc/add_binary.html">
        </link>
        <updated>2019-11-03T15:42:20Z</updated>
        <summary type="html"><![CDATA[<h1>Add Binary</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/add-binary/">Add Binary | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/add-binary/">(408) Add Binary</a></li>
</ul>
<pre><code>Given two binary strings, return their sum (also a binary string).

For example,
a = &quot;11&quot;
b = &quot;1&quot;
Return &quot;100&quot;.
</code></pre><h2>題解</h2>
<p>用字串模擬二進制的加法，加法操作一般使用自後往前遍歷的方法，不同位大小需要補零。</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param a a number
     * @param b a number
     * @return the result
     */
    public String addBinary(String a, String b) {
        if (a == null || a.length() == 0) return b;
        if (b == null || b.length() == 0) return a;

        StringBuilder sb = new StringBuilder();
        int aLen = a.length(), bLen = b.length();

        int carry = 0;
        for (int ia = aLen - 1, ib = bLen - 1; ia &gt;= 0 || ib &gt;= 0; ia--, ib--) {
            // replace with 0 if processed
            int aNum = (ia &lt; 0) ? 0 : a.charAt(ia) - &#39;0&#39;;
            int bNum = (ib &lt; 0) ? 0 : b.charAt(ib) - &#39;0&#39;;

            int num = (aNum + bNum + carry) % 2;
            carry = (aNum + bNum + carry) / 2;
            sb.append(num);
        }
        if (carry == 1) sb.append(1);

        // important!
        sb.reverse();
        String result = sb.toString();
        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>用到的技巧主要有兩點，一是兩個數位數大小不一時用0補上，二是最後需要判斷最高位的進位是否為1。最後需要反轉字符串，因為我們是從低位往高位迭代的。雖然可以使用 insert 避免最後的 reverse 操作，但如此一來時間複雜度就從 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 變為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span> 了。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    // helper functions
    char XOR(char x, char y) {
        return x == y ? &#39;0&#39; : &#39;1&#39;;
    }
    char CARRY(char x, char y){
        return (x == &#39;1&#39; and y == &#39;1&#39;) ? &#39;1&#39; : &#39;0&#39;;
    }
    string addBinary(string a, string b) {
        if(a.size() &lt; b.size())
            swap(a,b);

        int i = a.size()-1;
        int j = b.size()-1;
        char carry =&#39;0&#39;;

        while(0 &lt;= i) {
            char tmp = a[i];
            a[i] = XOR(tmp, carry);
            carry = CARRY(tmp, carry);
            if(0 &lt;= j) {
                tmp = a[i];
                a[i] = XOR(tmp, b[j]);
                carry = XOR(carry, CARRY(tmp, b[j]));
            }
            i--; j--;
        }

        if(carry == &#39;1&#39;)
            a = &quot;1&quot; + a;
        return a;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>C++的解法採用了直接操作char的作法，模擬硬體半加器(half adder)的行為，先確保a的長度不小於b的長度後，下標從尾到頭逐位相加，小心處理進位即可。</p>
<h3>複雜度分析</h3>
<p>Java解法遍歷兩個字串，時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. reverse 操作時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 故總的時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 使用了 StringBuilder 作為臨時存儲對象，空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<p>C++解法時間複雜度也是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>，計算過程中使用的臨時變數，額外空間複雜度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>，實際整體空間複雜度則取決於最後我們要將答案擴張一位時，函數的實現方法，最差可能達到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Add Binary</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a></li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#c">C++</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/add-binary/">Add Binary | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/add-binary/">(408) Add Binary</a></li>
</ul>
<pre><code>Given two binary strings, return their sum (also a binary string).

For example,
a = &quot;11&quot;
b = &quot;1&quot;
Return &quot;100&quot;.
</code></pre><h2>題解</h2>
<p>用字串模擬二進制的加法，加法操作一般使用自後往前遍歷的方法，不同位大小需要補零。</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param a a number
     * @param b a number
     * @return the result
     */
    public String addBinary(String a, String b) {
        if (a == null || a.length() == 0) return b;
        if (b == null || b.length() == 0) return a;

        StringBuilder sb = new StringBuilder();
        int aLen = a.length(), bLen = b.length();

        int carry = 0;
        for (int ia = aLen - 1, ib = bLen - 1; ia &gt;= 0 || ib &gt;= 0; ia--, ib--) {
            // replace with 0 if processed
            int aNum = (ia &lt; 0) ? 0 : a.charAt(ia) - &#39;0&#39;;
            int bNum = (ib &lt; 0) ? 0 : b.charAt(ib) - &#39;0&#39;;

            int num = (aNum + bNum + carry) % 2;
            carry = (aNum + bNum + carry) / 2;
            sb.append(num);
        }
        if (carry == 1) sb.append(1);

        // important!
        sb.reverse();
        String result = sb.toString();
        return result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>用到的技巧主要有兩點，一是兩個數位數大小不一時用0補上，二是最後需要判斷最高位的進位是否為1。最後需要反轉字符串，因為我們是從低位往高位迭代的。雖然可以使用 insert 避免最後的 reverse 操作，但如此一來時間複雜度就從 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 變為 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">)</span></span></span></span> 了。</p>
<h3>C++</h3>
<pre><code class="lang-c++">class Solution {
public:
    // helper functions
    char XOR(char x, char y) {
        return x == y ? &#39;0&#39; : &#39;1&#39;;
    }
    char CARRY(char x, char y){
        return (x == &#39;1&#39; and y == &#39;1&#39;) ? &#39;1&#39; : &#39;0&#39;;
    }
    string addBinary(string a, string b) {
        if(a.size() &lt; b.size())
            swap(a,b);

        int i = a.size()-1;
        int j = b.size()-1;
        char carry =&#39;0&#39;;

        while(0 &lt;= i) {
            char tmp = a[i];
            a[i] = XOR(tmp, carry);
            carry = CARRY(tmp, carry);
            if(0 &lt;= j) {
                tmp = a[i];
                a[i] = XOR(tmp, b[j]);
                carry = XOR(carry, CARRY(tmp, b[j]));
            }
            i--; j--;
        }

        if(carry == &#39;1&#39;)
            a = &quot;1&quot; + a;
        return a;
    }
};
</code></pre>
<h3>源碼分析</h3>
<p>C++的解法採用了直接操作char的作法，模擬硬體半加器(half adder)的行為，先確保a的長度不小於b的長度後，下標從尾到頭逐位相加，小心處理進位即可。</p>
<h3>複雜度分析</h3>
<p>Java解法遍歷兩個字串，時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. reverse 操作時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 故總的時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 使用了 StringBuilder 作為臨時存儲對象，空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>.</p>
<p>C++解法時間複雜度也是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>，計算過程中使用的臨時變數，額外空間複雜度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>，實際整體空間複雜度則取決於最後我們要將答案擴張一位時，函數的實現方法，最差可能達到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Reverse Integer]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/problem_misc/reverse_integer.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/problem_misc/reverse_integer.html">
        </link>
        <updated>2019-11-03T15:42:20Z</updated>
        <summary type="html"><![CDATA[<h1>Reverse Integer</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#example">Example</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/reverse-integer/">Reverse Integer | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/reverse-integer/">(413) Reverse Integer</a></li>
</ul>
<h3>Problem Statement</h3>
<p>Reverse digits of an integer. Returns 0 when the reversed integer overflows (signed 32-bit integer).</p>
<h4>Example</h4>
<p>Given x = 123, return 321</p>
<p>Given x = -123, return -321</p>
<h2>題解</h2>
<p>初看這道題覺得先將其轉換爲字符串然後轉置一下就好了，但是仔細一想這種方法存在兩種缺陷，一是負號需要單獨處理，而是轉置後開頭的0也需要處理。另一種方法是將原數字逐個彈出，然後再將彈出的數字組裝爲新數字，乍看以爲需要用到 stack ，實際上卻是 queue... 所以根本不需要輔助資料結構。關於正負號的處理，我最開始是單獨處理的，後來看其他答案時才發現根本就不用分正負考慮。因爲<code>-1 / 10 = 0</code>.</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param n the integer to be reversed
     * @return the reversed integer
     */
    public int reverseInteger(int n) {
        long result = 0;
        while (n != 0) {
            result = n % 10 + 10 * result;
            n /= 10;
        }

        if (result &lt; Integer.MIN_VALUE || result &gt; Integer.MAX_VALUE) {
            return 0;
        }
        return (int)result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>注意 lintcode 和 leetcode 的方法名不一樣。使用 long 型保存中間結果，最後判斷是否溢出。</p>
<h2>Reference</h2>
<ul>
<li><a href="https://github.com/FreeTymeKiyan/LeetCode-Sol-Res/blob/master/Easy/ReverseInt.java">LeetCode-Sol-Res/ReverseInt.java at master · FreeTymeKiyan/LeetCode-Sol-Res</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Reverse Integer</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#example">Example</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#題解">題解</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>leetcode: <a href="https://leetcode.com/problems/reverse-integer/">Reverse Integer | LeetCode OJ</a></li>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/reverse-integer/">(413) Reverse Integer</a></li>
</ul>
<h3>Problem Statement</h3>
<p>Reverse digits of an integer. Returns 0 when the reversed integer overflows (signed 32-bit integer).</p>
<h4>Example</h4>
<p>Given x = 123, return 321</p>
<p>Given x = -123, return -321</p>
<h2>題解</h2>
<p>初看這道題覺得先將其轉換爲字符串然後轉置一下就好了，但是仔細一想這種方法存在兩種缺陷，一是負號需要單獨處理，而是轉置後開頭的0也需要處理。另一種方法是將原數字逐個彈出，然後再將彈出的數字組裝爲新數字，乍看以爲需要用到 stack ，實際上卻是 queue... 所以根本不需要輔助資料結構。關於正負號的處理，我最開始是單獨處理的，後來看其他答案時才發現根本就不用分正負考慮。因爲<code>-1 / 10 = 0</code>.</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param n the integer to be reversed
     * @return the reversed integer
     */
    public int reverseInteger(int n) {
        long result = 0;
        while (n != 0) {
            result = n % 10 + 10 * result;
            n /= 10;
        }

        if (result &lt; Integer.MIN_VALUE || result &gt; Integer.MAX_VALUE) {
            return 0;
        }
        return (int)result;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>注意 lintcode 和 leetcode 的方法名不一樣。使用 long 型保存中間結果，最後判斷是否溢出。</p>
<h2>Reference</h2>
<ul>
<li><a href="https://github.com/FreeTymeKiyan/LeetCode-Sol-Res/blob/master/Easy/ReverseInt.java">LeetCode-Sol-Res/ReverseInt.java at master · FreeTymeKiyan/LeetCode-Sol-Res</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Find the Missing Number]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/problem_misc/find_the_missing_number.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/problem_misc/find_the_missing_number.html">
        </link>
        <updated>2019-11-03T15:42:20Z</updated>
        <summary type="html"><![CDATA[<h1>Find the Missing Number</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#example">Example</a></li>
<li><a href="#challenge">Challenge</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#題解1---位運算">題解1 - 位運算</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#題解2---桶排序">題解2 - 桶排序</a><ul>
<li><a href="#java-1">Java</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/find-the-missing-number/">(196) Find the Missing Number</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-missing-number/">Find the Missing Number - GeeksforGeeks</a></li>
</ul>
<h3>Problem Statement</h3>
<p>Given an array contains <em>N</em> numbers of 0 .. <em>N</em>, find which number doesn&#39;t exist in the array.</p>
<h4>Example</h4>
<p>Given <em>N</em> = <code>3</code> and the array <code>[0, 1, 3]</code>, return <code>2</code>.</p>
<h4>Challenge</h4>
<p>Do it in-place with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span> extra memory and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> time.</p>
<h2>題解1 - 位運算</h2>
<p>和找單數的題類似，這裡我們不妨試試位運算中 Exlcusive Or (XOR) 的思路。最開始自己想到的是利用相鄰項異或結果看是否會有驚喜，然而發現 <code>a^(a+1) != a^a + a^1</code> 之後眼淚掉下來... 如果按照找單數的做法，首先對陣列所有元素異或，得到數<code>x1</code>, 現在的問題是如何利用<code>x1</code>得到缺失的數，由於找單數中其他數都是成對出現的，故最後的結果即是單數，這裏每個數都是單數，怎麼辦呢？我們現在再來分析下如果沒有缺失數的話會是怎樣呢？假設所有元素異或得到數<code>x2</code>, 數<code>x1</code>和<code>x2</code>有什麼差異呢？假設缺失的數是<code>x0</code>，那麼容易知道<code>x2 = x1 ^ x0</code>, 相當於現在已知<code>x1</code>和<code>x2</code>，要求<code>x0</code>. 根據 <a href="http://algorithm.yuanbin.me/zh-hans/basics_misc/bit_manipulation.html">Bit Manipulation</a> 中總結的交換律，<code>x0 = x1 ^ x2</code>.</p>
<p>位運算的題往往比較靈活，需要好好利用常用等式變換。</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param nums: an array of integers
     * @return: an integer
     */
    public int findMissing(int[] nums) {
        if (nums == null || nums.length == 0) return -1;

        // get xor from 0 to N excluding missing number
        int x1 = 0;
        for (int i : nums) {
            x1 ^= i;
        }

        // get xor from 0 to N
        int x2 = 0;
        for (int i = 0; i &lt;= nums.length; i++) {
            x2 ^= i;
        }

        // missing = x1 ^ x2;
        return x1 ^ x2;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>略</p>
<h3>複雜度分析</h3>
<p>遍歷原陣列和 N+1大小的陣列，時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>題解2 - 桶排序</h2>
<p>非常簡單直觀的想法——排序後檢查缺失元素，但是此題中要求時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 因此如果一定要用排序來做，那一定是使用非比較排序如桶排序或者計數排序。題中另一提示則是要求只使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span> 的額外空間，那麼這就是在提示我們應該使用原地交換。根據題意，元素應無重複，可考慮使用桶排，索引和值一一對應即可。第一重 for 循環遍歷原陣列，內循環使用 while, 調整索引處對應的值，直至相等或者索引越界爲止，for 循環結束時桶排結束。最後再遍歷一次陣列找出缺失元素。</p>
<p>初次接觸這種題還是比較難想到使用桶排這種思想的，尤其是利用索引和值一一對應這一特性找出缺失元素，另外此題在實際實現時不容易做到 bug-free, while 循環處容易出現死循環。</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param nums: an array of integers
     * @return: an integer
     */
    public int findMissing(int[] nums) {
        if (nums == null || nums.length == 0) return -1;

        bucketSort(nums);
        // find missing number
        for (int i = 0; i &lt; nums.length; i++) {
            if (nums[i] != i) {
                return i;
            }
        }

        return nums.length;
    }

    private void bucketSort(int[] nums) {
        for (int i = 0; i &lt; nums.length; i++) {
            while (nums[i] != i) {
                // ignore nums[i] == nums.length
                if (nums[i] == nums.length) {
                    break;
                }
                int nextNum = nums[nums[i]];
                nums[nums[i]] = nums[i];
                nums[i] = nextNum;
            }
        }
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>難點一在於正確實現桶排，難點二在於陣列元素中最大值 N 如何處理。N 有三種可能：</p>
<ol>
<li>N 不在原陣列中，故最後應該返回 N</li>
<li>N 在原陣列中，但不在陣列中的最後一個元素</li>
<li>N 在原陣列中且在陣列最後一個元素</li>
</ol>
<p>其中情況1在遍歷桶排後的陣列時無返回，最後返回 N.</p>
<p>其中2和3在 while 循環處均會遇到 break 跳出，即當前這個索引所對應的值要麼最後還是 N，要麼就是和索引相同的值。如果最後還是 N, 也就意味着原陣列中缺失的是其他值，如果最後被覆蓋掉，那麼桶排後的陣列不會出現 N, 且缺失的一定是 N 之前的數。</p>
<p>綜上，這裏的實現無論 N 出現在哪個索引都能正確返回缺失值。實現上還是比較巧妙的，所以說在沒做過這類題時要在短時間內 bug-free 比較難，當然也可能是我比較菜...</p>
<p>另外一個難點在於如何保證或者證明 while 一定不會出現死循環，可以這麼理解，如果 while 條件不成立且未出現<code>nums.length</code>這個元素，那麼就一定會使得一個元素正確入桶，又因爲沒有重復元素出現，故一定不會出現死循環。</p>
<h3>複雜度分析</h3>
<p>桶排時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>. 遍歷原陣列找缺失數時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 故總的時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Find the Missing Number</h1>
<!-- toc -->
<ul>
<li><a href="#question">Question</a><ul>
<li><a href="#problem-statement">Problem Statement</a><ul>
<li><a href="#example">Example</a></li>
<li><a href="#challenge">Challenge</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#題解1---位運算">題解1 - 位運算</a><ul>
<li><a href="#java">Java</a></li>
<li><a href="#源碼分析">源碼分析</a></li>
<li><a href="#複雜度分析">複雜度分析</a></li>
</ul>
</li>
<li><a href="#題解2---桶排序">題解2 - 桶排序</a><ul>
<li><a href="#java-1">Java</a></li>
<li><a href="#源碼分析-1">源碼分析</a></li>
<li><a href="#複雜度分析-1">複雜度分析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2>Question</h2>
<ul>
<li>lintcode: <a href="http://www.lintcode.com/en/problem/find-the-missing-number/">(196) Find the Missing Number</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-missing-number/">Find the Missing Number - GeeksforGeeks</a></li>
</ul>
<h3>Problem Statement</h3>
<p>Given an array contains <em>N</em> numbers of 0 .. <em>N</em>, find which number doesn&#39;t exist in the array.</p>
<h4>Example</h4>
<p>Given <em>N</em> = <code>3</code> and the array <code>[0, 1, 3]</code>, return <code>2</code>.</p>
<h4>Challenge</h4>
<p>Do it in-place with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span> extra memory and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> time.</p>
<h2>題解1 - 位運算</h2>
<p>和找單數的題類似，這裡我們不妨試試位運算中 Exlcusive Or (XOR) 的思路。最開始自己想到的是利用相鄰項異或結果看是否會有驚喜，然而發現 <code>a^(a+1) != a^a + a^1</code> 之後眼淚掉下來... 如果按照找單數的做法，首先對陣列所有元素異或，得到數<code>x1</code>, 現在的問題是如何利用<code>x1</code>得到缺失的數，由於找單數中其他數都是成對出現的，故最後的結果即是單數，這裏每個數都是單數，怎麼辦呢？我們現在再來分析下如果沒有缺失數的話會是怎樣呢？假設所有元素異或得到數<code>x2</code>, 數<code>x1</code>和<code>x2</code>有什麼差異呢？假設缺失的數是<code>x0</code>，那麼容易知道<code>x2 = x1 ^ x0</code>, 相當於現在已知<code>x1</code>和<code>x2</code>，要求<code>x0</code>. 根據 <a href="http://algorithm.yuanbin.me/zh-hans/basics_misc/bit_manipulation.html">Bit Manipulation</a> 中總結的交換律，<code>x0 = x1 ^ x2</code>.</p>
<p>位運算的題往往比較靈活，需要好好利用常用等式變換。</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param nums: an array of integers
     * @return: an integer
     */
    public int findMissing(int[] nums) {
        if (nums == null || nums.length == 0) return -1;

        // get xor from 0 to N excluding missing number
        int x1 = 0;
        for (int i : nums) {
            x1 ^= i;
        }

        // get xor from 0 to N
        int x2 = 0;
        for (int i = 0; i &lt;= nums.length; i++) {
            x2 ^= i;
        }

        // missing = x1 ^ x2;
        return x1 ^ x2;
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>略</p>
<h3>複雜度分析</h3>
<p>遍歷原陣列和 N+1大小的陣列，時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2>題解2 - 桶排序</h2>
<p>非常簡單直觀的想法——排序後檢查缺失元素，但是此題中要求時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 因此如果一定要用排序來做，那一定是使用非比較排序如桶排序或者計數排序。題中另一提示則是要求只使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span> 的額外空間，那麼這就是在提示我們應該使用原地交換。根據題意，元素應無重複，可考慮使用桶排，索引和值一一對應即可。第一重 for 循環遍歷原陣列，內循環使用 while, 調整索引處對應的值，直至相等或者索引越界爲止，for 循環結束時桶排結束。最後再遍歷一次陣列找出缺失元素。</p>
<p>初次接觸這種題還是比較難想到使用桶排這種思想的，尤其是利用索引和值一一對應這一特性找出缺失元素，另外此題在實際實現時不容易做到 bug-free, while 循環處容易出現死循環。</p>
<h3>Java</h3>
<pre><code class="lang-java">public class Solution {
    /**
     * @param nums: an array of integers
     * @return: an integer
     */
    public int findMissing(int[] nums) {
        if (nums == null || nums.length == 0) return -1;

        bucketSort(nums);
        // find missing number
        for (int i = 0; i &lt; nums.length; i++) {
            if (nums[i] != i) {
                return i;
            }
        }

        return nums.length;
    }

    private void bucketSort(int[] nums) {
        for (int i = 0; i &lt; nums.length; i++) {
            while (nums[i] != i) {
                // ignore nums[i] == nums.length
                if (nums[i] == nums.length) {
                    break;
                }
                int nextNum = nums[nums[i]];
                nums[nums[i]] = nums[i];
                nums[i] = nextNum;
            }
        }
    }
}
</code></pre>
<h3>源碼分析</h3>
<p>難點一在於正確實現桶排，難點二在於陣列元素中最大值 N 如何處理。N 有三種可能：</p>
<ol>
<li>N 不在原陣列中，故最後應該返回 N</li>
<li>N 在原陣列中，但不在陣列中的最後一個元素</li>
<li>N 在原陣列中且在陣列最後一個元素</li>
</ol>
<p>其中情況1在遍歷桶排後的陣列時無返回，最後返回 N.</p>
<p>其中2和3在 while 循環處均會遇到 break 跳出，即當前這個索引所對應的值要麼最後還是 N，要麼就是和索引相同的值。如果最後還是 N, 也就意味着原陣列中缺失的是其他值，如果最後被覆蓋掉，那麼桶排後的陣列不會出現 N, 且缺失的一定是 N 之前的數。</p>
<p>綜上，這裏的實現無論 N 出現在哪個索引都能正確返回缺失值。實現上還是比較巧妙的，所以說在沒做過這類題時要在短時間內 bug-free 比較難，當然也可能是我比較菜...</p>
<p>另外一個難點在於如何保證或者證明 while 一定不會出現死循環，可以這麼理解，如果 while 條件不成立且未出現<code>nums.length</code>這個元素，那麼就一定會使得一個元素正確入桶，又因爲沒有重復元素出現，故一定不會出現死循環。</p>
<h3>複雜度分析</h3>
<p>桶排時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>. 遍歷原陣列找缺失數時間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 故總的時間複雜度爲 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 空間複雜度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Part III - Contest]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/part_iii_contest/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/part_iii_contest/">
        </link>
        <updated>2019-11-03T15:42:21Z</updated>
        <summary type="html"><![CDATA[<h1>Part III - Contest</h1>
<p>本節主要總結一些如 Google APAC, Microsoft 校招等線上測試的題目。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Part III - Contest</h1>
<p>本節主要總結一些如 Google APAC, Microsoft 校招等線上測試的題目。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Appendix I Interview and Resume]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/appendix_i_interview_and_resume/</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/appendix_i_interview_and_resume/">
        </link>
        <updated>2019-11-03T15:42:21Z</updated>
        <summary type="html"><![CDATA[<h1>Appendix I Interview and Resume</h1>
<p>本章主要總結一些技術面試和撰寫履歷方面的注意事項。</p>
]]></summary>
        <content type="html"><![CDATA[<h1>Appendix I Interview and Resume</h1>
<p>本章主要總結一些技術面試和撰寫履歷方面的注意事項。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tags]]></title>
        <id>https://algorithm.yuanbin.me/zh-tw/tags.html</id>
        <link href="https://algorithm.yuanbin.me/zh-tw/tags.html">
        </link>
        <updated>2019-11-03T15:42:21Z</updated>
        <summary type="html"><![CDATA[<h1>Tags</h1>
<h2>Quick Sort</h2>
<ul>
<li><a href="integer_array/kth_largest_element.md">Kth Largest Element</a></li>
</ul>
<h2>Divide and Conquer</h2>
<ul>
<li><a href="integer_array/kth_largest_element.md">Kth Largest Element</a></li>
</ul>
<h2>Medium</h2>
<ul>
<li><a href="integer_array/kth_largest_element.md">Kth Largest Element</a></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1>Tags</h1>
<h2>Quick Sort</h2>
<ul>
<li><a href="integer_array/kth_largest_element.md">Kth Largest Element</a></li>
</ul>
<h2>Divide and Conquer</h2>
<ul>
<li><a href="integer_array/kth_largest_element.md">Kth Largest Element</a></li>
</ul>
<h2>Medium</h2>
<ul>
<li><a href="integer_array/kth_largest_element.md">Kth Largest Element</a></li>
</ul>
]]></content>
    </entry>
</feed>